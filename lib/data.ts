export const initailMessage = {
    role: 'system',
    contents: [
        {
        text: 
            `🚀GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA COMPUTER HARDWARE COMPUTER HARDWARE DEVICE The computer system essentially consists of three components: input devices, central processing unit and output devices. In the computer terminology, a device can be referred as a unit of hardware, which is capable of providing input to the computer or receiving output or both. The input devices are used to provide data to the central processing unit (CPU) for processing. After processing, the input data are converted into meaningful information and this output is presented to the user with the help of output devices. When the term 'device' is used, it includes keyboard, mouse, display monitors, printers and other hardware units. The aim of this chapter is to familiarize you with various types of output and output devices along with their advantages, disadvantages and applications. Learning objectives. At the end of this chapter, student will be able to - - - I. Describe common input and output devices and their functioning Describe common primary and secondary storage devices and their functioning Classify primary and secondary storage devices in order of performance and capacity INPUT DEVICES An input device can be defined as an electromechanical device that allows the user to feed data into the computer for analysis and storage, and to give commands to the computer. The computer accepts input in two ways; manually and directly. In the case of manual data entry, the user enters the data into the computer by hand, for example, by using the keyboard and the mouse. A user can also enter the data directly by transferring information automatically from a source document (like from check using MICR) into the computer. Some of the commonly used input devices are keyboard, pointing devices like mouse and joystick, speech recognition system, digital camera, scanners and so on. I.1 Keying devices These are devices that convert typed numbers, letters and special characters into machine readable form examples: keyboard and keypad I.1.1 Keyboard A keyboard is the most common data entry device. The keyboard is designed like a regular typewriter with a few additional keys. The data are entered into the computer by using various keys. There are different types of keyboard layouts such as QWERTY, DVORAK and AZERTY, but the most common layout is the QWERTY. I.1.2 Keypad This is a small keyboard used with hand held devices i.e. cell phones, calculators, notebooks, etc. I.2 Pointing Devices These are devices used to control the pointer/cursor on the screen. Some commonly pointing devices are: mouse, trackball, joystick, light pen, touch screen and trackpad. I.2.1 Mouse A mouse is a small rectangular-shaped hand-held pointing device, it usually contains two or three buttons, which can be used to input commands or the data. The mouse may be classified as a mechanical mouse or an optical mouse, based on the technology it uses. → A mechanical mouse uses a rubber ball at the bottom surface, which rotates as the mouse is moved along a flat surface to move the cursor. → An optical mouse uses a light beam instead of a rotating ball to detect the movement across a specially patterned mouse pad. I.2.2 Trackball Page 1 CSC-AL NOTES KOUANGA INNOCENTA GBHS-BAFOUSSAM A trackball is another pointing device that resembles a ball nestled in a square cradle and serves as an alternative to a mouse. In general, the trackball is like a mouse turned upside down. It has a ball, which can be rotated by fingers in any direction, and the cursor moves accordingly. I.2.3 Joystick A joystick is a device that moves in all directions and controls the movement of the cursor. The basic design of a joystick consists of a stick that is attached to a plastic base with a flexible rubber sheath. These plastic base houses a circuit board beneath the stick. I.2.4 Light Pen A light pen (sometimes called a mouse pen) is a hand-held electro-optical pointing device, which when touched or aimed closely at a connected computer monitor will allow the computer to determine the position of the pen on the screen. It images and selects objects on the display screen by directly It is a pen-like device, which is connected to the machine by a I.2.5 Touch Screen facilitates drawing pointing to the objects. cable. A touch screen is a special kind of display screen device, which is placed on the computer monitor to allow direct selection or activation of the computer when the user touches the screen. I.2.6 Trackpad A trackpad (also referred to as touchpad) is a stationary pointing device that works by sensing the movement of fingers across a small sensitive surface and translating them into the pointer movement on the screen. It is generally used in laptops, but can also be connected to the PC through a cord. NOTE: The device manufactured by Apple is referred to as trackpad while the device manufactured by others is known as touchpad. I.3 Scanning devices These are devices that capture data directly into the computer. They can also be defined as devices that use a magnetic or photo-electric source to scan and convert images into electric signals that can be processed by an electronic apparatus, such as a computer. They are commonly used to: - - - - - Convert a text document into an electronic file; Convert a photograph into an electronic graphic file; Sense an image to be sent over a voice frequency Circuit, such as a fax machine; Reproduce text and images, as with a copier. - Scanners are classified according to technology used to capture data namely: optical and magnetic scanners. - - II.3.1 Optical scanners These scanners capture data using optical or light technology. Examples of optical scanners a) Bar Code Reader A bar code is a machine-readable code in the form of parallel vertical lines of varying widths. It is commonly used for labelling goods that are available in super markets and numbering books in libraries. This code is sensed and read by a bar code reader using reflective light. The information recorded in the bar code reader is then fed into the computer, which recognizes the information from the thickness and spacing of the bars. b) Optical mark recognition - Optical mark recognition (OMR) is the process of detecting the intended marked responses. A mark registers significantly less light than presence of the Page 2 CSC-AL NOTES KOUANGA INNOCENTA GBHS-BAFOUSSAM surrounding paper. The optical mark reading is done by a special device known as optical mark reader. Generally, this technology is used to read answer sheets (MCQ tests). - - c) Optical Character Recognition A scanner converts an input document into an electronic format that can be stored on the disk. If the document to be scanned contains text, optical character recognition (OCR) software is needed to translate the bitmap image of the text to the ASCII codes that the computer can interpret as letters, numbers and special characters. - - d) Scanner A scanner is an input device that converts a document into an electronic format that can be stored on the disk. Moreover, they can store images in both grey scale and colour mode. The two most common types of scanners are hand-held scanner and flat-bed scanner. - → Hand-held Scanner: A hand-held scanner consists of light emitting diodes, which are placed over the document to be scanned. This scanner performs the scanning of the document very slowly from the top to the bottom with its light on. - → Flat-bed Scanner: A flat-bed scanner is similar to a photocopier machine. It consists of a box containing a glass plate on its top and a lid that covers the glass plate. This glass plate is used for placing the document to be scanned. II.3.2 Magnetic scanners These scanners use magnetic technology to capture handwritten and magnetic strip data. Some examples of optical scanners are: a) Magnetic-Ink Character Recognition (MICR): You must have seen special magnetic encoding using characters, printed on the bottom of a check. The characters are printed using a special ink, which contains iron particles that can be magnetized. To recognize these magnetic-ink characters, a magnetic-ink character reader (MICR) is used. It reads the characters by examining their shapes in a matrix form and the information is then passed on to the computer. The banking industry prefers MICR to OCR as the MICR gives extra security against forgeries such as colour copies of payroll checks or hand-altered characters on a check. If a document has been forged, say a counterfeit check produced using a colour photocopying machine, the magnetic-ink line will either not respond to the magnetic fields or will produce an incorrect code when scanned a device designed to recover the information in the magnetic characters. using b) Digital camera: Also known as a digicam, A digital camera stores images digitally rather than recording them on a film. Once a picture has been taken, it can be transferred to a computer system and then manipulated with an image editing software and printed. c) webcam Short form of web camera, is a portable video camera, which captures live video or images that may be viewed in real time over the network or the Internet. It is just a small digital camera that is either in-built in your computer (in most laptops) or can be connected through a USB port. I.4 Other input devices Other input devices of computer include: Touch screen: It is an electronic visual display that can detect the presence and location of a touch within the display area Interactive whiteboard (IWB): This is a large interactive display that connects to a computer and projector. A projector projects the computer's desktop onto the board's surface where users control the computer using a pen, finger, stylus, or other device. The board is typically mounted to a wall or floor stand. Page 3 CSC-AL NOTES KOUANGA INNOCENTA GBHS-BAFOUSSAM Speech Recognition System: Speech recognition is one of the most interactive systems to communicate with the computer. The user can simply instruct the computer with the help of a microphone (along with speech recognition software) what task to be performed. It is the technology by which sounds, words or phrases spoken by the individuals are converted into digital signals, and these signals are transformed computer generated texts commands. II. OUTPUT DEVICES into or An output device is an electromechanical device, which converts machine-readable information into human readable form. The basic functioning of output device is just the opposite of the input device, that is, the data are 'fed into' the computer system through the input device, while the output is 'taken out' from the computer through the output device. II.1 Types of Output Output is the data that has been processed into useful information. It can be displayed or viewed on a monitor, printed on a printer or listened through speakers or a headset. Generally, there are two basic categories of output: Hard copy output and soft copy output → Hard Copy refers to the recorded information copied from a computer onto the paper or some other durable surface such as microfilm. Hard copy output is permanent and a relatively stable form of output. → Soft Copy is the electronic version of an output, which usually resides in the computer memory and/or on the disk. Unlike hard copy, soft copy is not a permanent form of output and is not tangible, that is, it cannot be touched. II.2 Printers A printer prints information and data from the computer onto a paper. The quality of a printer is determined by its resolution. Resolution is used to describe the sharpness and clarity of an image. The higher the resolution, the better the image. For printers, the resolution is measured in dots per inch (dpi). The more dots per inch, the better will be the quality of image. Printers are divided into two basic categories: impact printers and non impact printers. Impact printers use some sort of physical contact with the paper to make a mark onto it, while non-impact printers use techniques other than to transfer ink onto it. II.2.1 Impact Printers An impact printer uses pins or hammers that press an inked ribbon against the paper to make a mark on the paper. Some impact printers can print only one character at a time, while others can print an entire line. The three most commonly used impact printers are dot matrix printers, daisy wheel printers and drum printers. Some characteristics of impact printers are as follows: • In impact printers, there is physical contact with the paper to produce an image. • They are relatively cheap. The primary recurring costs for these printers are the ink ribbons and paper. • Due to being robust and low cost, they are useful for bulk printing. • They can withstand dusty environment, vibrations and extreme temperature. • They are ideal for printing multiple copies (i.e. carbon copies) because they can easily print through many layers of paper. • Due to its striking activity, the impact printers are very noisy. • Since they are mechanical in nature, they tend to be slow. Page 4 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA a) Dot Matrix Printers Dot matrix printer (also known as the wire matrix printer) uses the oldest printing technology and it prints one character at a time. It prints characters and images as pattern of dots. The speed of dot matrix printers is measured in characters per second (cps). b) Daisy Wheel Printer Daisy wheel printers produce high-resolution output and are more reliable than dot matrix printers. They can have speed up to 90 cps. However, daisy wheel printers give only alphanumeric output. They cannot print graphics and cannot change fonts unless the print wheel is physically replaced. Daisy wheel printers are slower and more expensive than dot matrix printers. c) Drum Printers The dot matrix and daisy wheel printers are character or serial printers, that is, they print one character at a time. However, drum printer is a line printer; it can print a line in a single operation. Although such printers are much faster than character printers, they tend to be quite loud, have limited multifront capability and often produce lower print quality than most recent printing technologies. Line printers are designed for heavy printing applications. II.2.2 Non-impact Printers In this printer, the print head does not make any contact with the paper, and no inked ribbon is required. Ink can be sprayed against the paper and then heat and pressure are used to fuse a fine black powder into the shape of a character. The major technologies competing in the market of nonimpact printers are ink-jet and laser. Some characteristics of non-impact printers are as follows: • They are faster than impact printers because they have fewer moving parts. • They are quieter than impact printers • They possess the ability to change typefaces automatically. • They produce high-quality graphics. • They cannot print carbon copies. a) Ink-jet Printers An inkjet printer is a printer that places extremely small droplets of ink onto paper to create an image. Ink-jet printers are costlier than dot matrix printers, but the quality is much better. These printers can print any shape of character, which a user can specify as they produce printed output as pattern of tiny dots. Ink-jet printers typically print with a resolution of 600 dpi or more. Due to the high resolution, these printers produce high quality graphics and text printouts. b) Laser Printers A laser printer provides the highest quality text and images for personal computers today. It is a very fast printer, which operates on the same principle as that of a photocopy machine. They are also known as page printers because they process and store the entire page before they actually print it. Today, the resolution of most printers is 600 dpi. They are quiet and fast, able to print 4–32 text-only pages per minute for individual microcomputers and up to 200 pages/min for mainframes (more than 2000 lines/min). Laser printers are often faster than ink-jet printers but are more expensive to buy and maintain than the other printers. Page 5 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA c) Hydra Printer Hybrid document reproduction apparatus (HYDRA) printer, popularly known as all-in-one printer, is a device that consolidates the capabilities of multiple devices in one machine. It may include some or all of the devices like printer, scanner, photocopier and fax machine. Following are the features that must be considered while evaluating these printers: Print speed, Maximum resolution, Memory card compatibility, Scanner resolution, Fax speed II.3 Plotters A plotter is a pen-based output device that is attached to a computer for making vector graphics, that is, images created by a series of many straight lines. It is used to draw high-resolution charts, graphs, blueprints, maps, circuit diagrams and other line-based diagrams. It is similar to a printer, but it draws lines using a pen. They are mainly used for computer aided design (CAD) and computer aided manufacturing (CAM) applications such as printing out plans for houses or car parts. II.4 Monitor The monitor is the most frequently used output device for producing soft copy output. A computer monitor is a TV-like display attached to the computer on which the output can be displayed and viewed. Monitors are available in various sizes like 14, 15, 17, 19 and 21 inches. The larger the size of the monitor, the more expensive it is. The size of the display is described based on two parameters: aspect ratio and screen size. Aspect ratio is the ratio of the width of the display screen to the height, that is, the ratio of vertical points to the horizontal points necessary to produce equal length lines in both directions on the screen. The screen clarity depends on three basic qualities, which are as follows: • Resolution: It refers to the number of pixels in the horizontal and vertical directions on the screen. A pixel (px) is the smallest portion of an image or display that a computer is capable of printing or displaying. In medium-resolution graphics, pixels are large, whereas in high resolution graphics, pixels are small. • Dot Pitch: It is the measurement of the diagonal distance between the two like-coloured (red, green or blue) pixels on a display screen. It is measured in millimetres and common dot pitches are 0.51, 0.31, 0.28, 0.27, 0.26 and 0.25 mm. Smaller the dot pitch, sharper will be the image when displayed on the monitor. Generally, a dot pitch of less than 0.31 mm provides clear images. • Refresh Rate: It is the number of times per second the pixels are recharged so that their glow remains bright. A refresh rate of 60 Hz means the image is redrawn 60 times a second. The higher the refresh rate, the more solid the image looks on the screen, that is, it does not flicker. II.5.1 Cathode Ray Tube Monitors CRT is the electron beams within a monitor that move across your screen either interlaced or non interlaced hitting phosphor dots on the inside glass tube. Within the CRT are three electron guns, red, green, and blue. Each of these guns streams a steady flow of electrons, left to right, for each line of your monitor. II.5.2 Liquid Crystal Display Monitors LCD is a flat display technology used in laptops, cell phones, calculators and, flat screen displays. The LCD is made of two sheets of a flexible polarizing material with a layer of liquid crystal solution between the two. The LCD does not refresh like a traditional CRT monitor, Instead, the display is created by sending various voltages of electricity to cells of liquid crystal causing the liquid crystal to untwist at the rate of electricity applied, generating 64 different shades per cell. Page 6 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA Comparison between LCD and CRT • Size: An LCD is lightweight and compact, which saves desktop space as compared to a CRT. • Resolution: An LCD is designed to work in a single resolution, while CRT is designed for many resolutions. • Pixel Density: Pixel density of LCD is generally not as tight as the dot pitch in CRT, but for most applications, the density is acceptable. • Brightness: The illuminated phosphor of a CRT is not nearly as bright as what the LCD can produce with its florescent backlight. • Power Consumption: An LCD consumes significantly less power than CRT and has a low emission risk. Typically, the LCD consumes approximately half of the power of a typical CRT. • Cost: Prices for LCD screens are quite high but they are coming down. They are still much more expensive than a CRT. • Viewing Angle: A CRT can be viewed at almost any angle, but an LCD is best viewed 'head on'. • Viewing Area: The frame around the glass screen of the monitor causes the viewable area of the screen to be smaller than an LCD. • Weight: A CRT monitor can weigh 40 pounds or more depending on the size of the monitor. II.5.3 Other Types of Monitors Although CRT and LCD displays are the most commonly used, other kinds of displays also exist. Some of them are as follows: • Plasma Display: A plasma display (also known as thin-panel) is constructed by filling a gas (neon or xenon) between the two glass plates. One glass plate consists of vertical conductors and the other consists of horizontal conductors. The advantage of plasma display is that it has the capability of producing more than 16 million colours and is lighter and less bulky than CRT. However, it is heavier than LCD display and requires more power. • Thin-film Electroluminescent Display: This display is similar to the plasma display except the fact that the space between the glass plates is filled with phosphorescent substance (usually zinc sulphide doped with manganese) instead of gas. The main problem with thin-film electroluminescent displays is that they require more power. II.5. Projectors projector is an output device, which is used to project information from a computer onto a large screen, so that it can be simultaneously viewed by a large group of people. Projection display is commonly used for classroom training or conference room or for multimedia presentations with a large audience. Like monitors, projectors provide a temporary, soft copy output. II.6 Electronic Whiteboard Electronic whiteboard is an interactive presentation device that works electronically to display digital images, drawings and text in different colours. The whiteboard is generally mounted on the wall and is connected to a computer and a projector. The projector projects the computer desktop on the whiteboard and the user can interact with it using electromagnetic pens, fingers or other pointing devices. The electromagnetic pens can be configured to any colour or width. A user can activate programs, applications and menus, as well as can enter text using either onscreen keyboard or handwriting recognition utility. II.7 Headphones and Headsets Headphone is an audio device equipped with a pair of speakers, which are attached to a headstrap worn by the users. For such applications, headset is used instead of headphone. A headset is a combination of one or two speakers and a microphone with both the speaker and the microphone attached to a head strap Page 7 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA II.8 Terminals Computer terminal is a special unit that can perform as both input and output. A terminal is an I/O device that uses a keyboard for input and a monitor for output. Hence, a terminal is also known as video display terminal (VDT). The terminals can be categorized into the following types • Dumb Terminal: It refers to a terminal that has no processing or programming capabilities. It is designed to communicate exclusively with a host computer. Usually, it consists of a screen and keyboard used to access a host computer. • Smart Terminal: Smart terminal has built-in processing capability and memory, but does not have its own storage capacity. In comparison to the dumb terminal, smart terminal can communicate and retrieve the data and can perform a limited processing of its own, that is, editing or verification of the data. • Intelligent Terminal: An intelligent terminal has memory and in-built microprocessors, hence also known as user-programmable terminal. This terminal can independently perform a certain number of jobs without even interacting with the mainframe. Although they are intelligent terminals, some workstations are designed without disk drives. Due to this, the restricted data cannot be downloaded or copied. III. GENERALITIES ON COMPUTER MEMORY III.1 What is a computer memory? Computer memory is any physical device capable of storing information temporarily or permanently. III.2 Memory representation For measuring computer memory, a standard unit is required. Although the smallest unit of data that a computer can deal with is a bit, the computers generally do not deal with a single bit. Instead, they deal with a group of eight bits, which is referred as 'byte'. Various units used to measure computer memory are as follows: • Bit: It is the smallest unit of data on a machine and a single bit can hold only one of two values: 0 or 1. Bit is represented by lower case b. • A nibble is a collection of 4 bits. • Byte: A unit of eight bits is known as a byte. Hence, a byte is able to contain any binary number between 00000000 and 11111111. It is represented by upper case B. • Kilobyte: In a decimal system, kilo stands for 1000, but in a binary system, kilo refers to 1024. Therefore, a kilobyte is equal to 1024 bytes. It is usually represented as KB. • Megabyte: It comprises 1024 kilobytes or 10,48,576 bytes. However, since this number is hard to remember, a megabyte can be thought of as million bytes. Megabyte is the standard unit of measurement of RAM and is represented as MB. • Gigabyte: It consists of 1024 megabytes (10,73,741,824 bytes). It is the standard unit of measurement for hard disks and is often represented as GB. • Terabyte: It refers to 1024 gigabytes and is often represented as TB. Terabyte memory is usually associated with only super computers Page 8 CSC-AL NOTES KOUANGA INNOCENTA GBHS-BAFOUSSAM NOTE: In modern computers, groupings of bytes (usually 2 or 4) called computer words can represent larger 'chunks' of information. III.3 Memory characteristics Computer memories can be differentiated by evaluating certain core characteristics. These core characteristics are volatility, mutability, accessibility, and addressability. III.3.1. Volatility → Non-volatile memory will retain the stored information even if it is not constantly supplied with electric power. It is suitable for long-term storage of information. → Volatile memory requires constant power to maintain the stored information. The fastest memory technologies of today are volatile ones. III.3.2. Mutability → Read/write storage or mutable storage allows information to be overwritten at any time. → Read only storage: retains the information stored at the time of manufacture → Write once storage (Write Once Read Many) allows the information to be written only once at some point after manufacture. These are called immutable storage. Examples include CD-ROM and CD-R → Slow write, fast read storage: Read/write storage, which allows information to be overwritten multiple times, but with the write operation being much slower than the read operation. Examples include CD RW and flash memory. III.3.3. Accessibility Access Mode: Access mode refers to the way the data are accessed from the memory. → Random access: Any location in storage can be accessed at any moment in approximately the same amount of time. Such characteristic is well suited for primary and secondary storage. → Sequential access: The accessing of pieces of information will be in a serial order, one after the other; therefore, the time to access a particular piece of information depends upon which piece of information was last accessed. Such characteristic is typical of off-line storage. → Direct access: In some cases, the data are accessed neither in a random nor in a sequential fashion, but using a combination of both the modes. This type of semi-random mode exists in the magnetic disk. III.3.5. Addressability → Location-addressable: Each individually accessible unit of information in storage is selected with its numerical memory address. → File addressable: Information is divided into files of variable length, and a particular file is selected with human-readable directory and file names. In modern computers, secondary, tertiary and off-line storage use file systems. → Content-addressable: Each individually accessible unit of information is selected based on the basis of (part of) the contents stored there. Content-addressable storage can be implemented using software (computer program) or hardware (computer device), with hardware being faster but more expensive option. Hardware content addressable memory is often used in a computer's CPU cache. Other characteristics of computer memory involve • Access time: Access time is the time required between the request made for read/write operation and the time it takes for the completion of the request. Generally, the access time is measured for read operations only. Disk access time depends on the following three parameters: → Seek Time: It is the time required to position the read/write head over the desired track, as soon as a read/write command is received by the disk unit → Latency: It is the time required to spin the desired sector under the read/write head, once the read/write head is positioned on the desired track Page 9 CSC-AL NOTES KOUANGA INNOCENTA GBHS-BAFOUSSAM → Transfer Rate: the transfer rate is the number of characters or words that a device can transfer per second after it has been positioned at the beginning of the record. As the transfer rate is negligible as compared to seek time and latency, Average access time = Average seek time + Average latency • Storage capacity: Storage capacity refers to the size of the memory, that is, the amount of data that can be stored in the memory. • Cost: The cost of memory is valued by estimating the cost per bit of storage, that is, the cost of a storage unit for a given storage capacity. III.4 Types of Memory These are the fundamental types of memory in a computer system: a) Primary storage device: The primary memory allows the computer to store data for immediate manipulation and to keep track of what is currently being processed. There are two main types of primary storage: - - Main memory (RAM and ROM) and Internal processor memories (Cache memory and registers). b) Secondary Memory: This is also known as auxiliary memory. It differs from primary storage in that it is not directly accessible by the CPU. c) Tertiary Storage: Tertiary storage is very large storage which is separate from the computer. The most obvious example of tertiary storage is an automated storage facility where mechanical arms retrieve media and load it into large computers. Other tertiary storage may simply be off-grounds locations which allow vital data in various mediums to be safe-guarded for security purposes- fire, theft, etc. d) Off-line Storage: Offline storage is storage media which can be inserted into the computer and used but which can then be removed from the computer and stored elsewhere. Floppy drives, CD drives, and DVD drives might also alternately be considered secondary storage because their drives are usually installed in the computer but the key here is the media the data is stored on. III.5 Storage technologies Most commonly used data storage technologies are semiconductor, magnetic, and optical, while paper still sees some limited usage. Some other fundamental storage technologies have also been used in the past or are proposed for development.  Magnetic storage media: Magnetic storage uses different patterns of magnetization on a magnetically coated surface to store information. In modern computers, magnetic storage will take these forms: Magnetic disk (Floppy disk, Hard disk drive) and Magnetic tape data storage.  Optical storage media: The typical optical disc, stores information in deformities on the surface of a circular disc and reads this information by illuminating the surface with a laser diode and observing the reflection.  Semiconductor storage media: Semiconductor memory uses semiconductor-based integrated circuits to store information. A semiconductor memory chip may contain millions of tiny transistors or capacitors. Both volatile and non-volatile forms of semiconductor memory exist.  Magneto-optical disc storage media: Magneto-optical disc storage is optical disc storage where the magnetic state on a ferromagnetic surface stores information. The information is read optically and written by combining magnetic and optical methods. Page 10 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA III.6 Memory hierarchy A "memory hierarchy" in computer storage distinguishes each level in the "hierarchy" by response time. Since response time, complexity, and capacity are related, the levels may also be distinguished by the controlling technology. The figure below illustrates the memory hierarchy. IV. PRIMARY STORAGE DEVICE The primary memory allows the computer to store data for immediate manipulation and to keep track of what is currently being processed. There exist two main types of primary storage device: Main memories and internal processor memories II.1 Main memory Broadly primary memory can be of two types RAM (Random Access Memory) and ROM (Read only memory). Every computer comes with a small amount of ROM, which contains the boot firmware called BIOS (Basic Input Output System). II.1.1 Random Access Memory (RAM) 1. What is RAM? RAM is the place where the computer temporarily stores its operating system, application programs and current data so that the computer's processor can reach them quickly and easily. RAM allows the computer to store data for immediate manipulation and to keep track of what is currently being processed. RAM is much faster to read from and write to than the other kinds of storage in a computer (like hard disk or floppy disk). The major limitation of this type of memory is that it is volatile. It means that when the power is turned off, the contents of the primary memory are lost forever. NOTE: Random access memory is also called read/write memory because, unlike read-only memory (ROM) that does not allow any write operation, random access memory allows CPU to read as well as write data and instructions into it. 2. Types of RAM There are two types of random-access memory, which are as follows: a) Dynamic RAM (DRAM): This RAM must be continually refreshed (pulse of current through all the memory cells) to maintain the data. This is done by placing the memory on a refresh circuit that rewrites the data several hundred times per second. DRAM is used for most system memory because it is cheap and small. Some of the most popular DRAM technologies are briefed as follows: • Fast Page Mode DRAM (FPM DRAM): It is also called as page mode DRAM. It is the original form of DRAM. FPM DRAM is slow and has an access time of 60–120 ns. Due to its slow speed, FPM DRAM is replaced by EDO RAM. • EDO (Extended Data Output) RAM: In an EDO RAMs, any memory location can be accessed. It is 10–15 per cent faster than FPM DRAM and is usually found on 66 MHz motherboards. EDO memory further enhances the method of access. • Burst Extended Data Output DRAM (BEDO DRAM): Original EDO RAM was too slow for the newer systems being developed at that time. Therefore, a new method of memory access, known as bursting, had to be developed to speed up the memory access. • SDRAM (Synchronous DRAMS), It is the most common type of RAM used in systems today. This implies that the data stored in the memory is refreshed at system speed. Also, the data are accessed in memory at system speed. SDRAM employs the bursting technology to improve the performance. • DDR-SDRAM (Double Data Rate – SDRAM): This DRAM is similar to SDRAM except that it has higher bandwidth, which means greater speed. Therefore, the transfer rate of the data becomes doubles. Page 11 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA • Rambus DRAM (RDRAM): It was developed by Rambus, Inc. and endorsed by Intel as the successor to SDRAM. b) Static RAM (SRAM): This RAM retains the data as long as power is provided to the memory chip. It need not be 'refreshed' periodically. It is very fast but much more expensive than DRAM. SRAM is often used as cache memory due to its high speed. SRAM comes in following types: • Asynchronous SRAM (ASRAM): It is an older type of SRAM used in many PCs for L2 cache, which works independently of the system clock. Thus, the CPU must wait for data requested. • Burst SRAM (BSRAM): Burst SRAM (also known as Synch Burst SRAM or synchronous SRAM) is synchronized with the system clock. This allows it to be more easily synchronized with any device that accesses it and the access time is also less. However, it is expensive. • Pipeline Burst SRAM (PB SRAM): PB SRAM requests are pipelined; larger packets of data are sent to the memory at once and acted on very quickly. This type of SRAM is often used because it can operate at speeds higher than 66 MHz 3. Main memory organisation The main memory of computer system is organized into an array of small storage areas known as cells, which are serially linked together. Each cell is indexed by a unique number, called the address of the cell and is capable of storing a fixed number of bits, called the word length of the memory. The word length is an important architectural factor, which typically relates to the CPU and is usually the size of its registers in bits. The word lengths typically range from 8, 16, 32 bits to 64 bits and accordingly the computers are termed as 8-bit, 16-bit, 32-bit and 64-bit computers. The higher the word length, the more powerful a computer is. The total number of memory cells that can be uniquely addressed by CPU depends on the total number of address lines in an address bus. If there are n lines in the address bus then there are 2n addressable locations in the memory. 4. Fixed and Variable Word Length Memory The main memory of a computer can be designed in two ways: fixed word length and variable word length. → In fixed word length memory system, each memory location stores a fixed number of characters, which are equal to the word length of the computer. The computers that employ fixed word length memory approach are called word-addressable computers. In such computers, the storage space is always allocated in multiples of word length. → In variable word length memory system, the memory is designed in such a way that each memory location can store only one character. Hence, the word 'HI' will occupy only 2 bytes, 'MIKE' will occupy 4 bytes, and 'COMPUTER' will occupy 8 bytes of memory. The computers that employ variable word length memory approach are called characteraddressable computers II.1.2 Read Only Memory 1. What is ROM? Short for Read-Only Memory, ROM is a type of "built-in" memory that is capable of holding data and having that data read from the chip, but not written to. Unlike Random Access Memory (RAM), ROM is non-volatile which means it keeps its contents regardless if it has power or not. NB: The term ROM is used to describe any type of memory or media that is read only. For example, a CD-ROM Page 12 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA 2. Types of ROM Memories in the ROM family are distinguished by the methods used to write data on them and the number of times they can be rewritten. There are different types of ROMs, which are as follows: • Masked ROM: The very first ROMs, known as masked ROMs, were hard-wired devices that contained a pre-programmed set of data or instructions. • Programmable ROM (PROM): This form of ROM is initially blank. The user or manufacturer can write data/program on it by using special devices. However, once the program or data is written in PROM chip, it cannot be changed. • Erasable Programmable ROM (EPROM): An EPROM is programmed in exactly the same manner as a PROM. However, unlike PROMs, an EPROM can be erased and reprogrammed repeatedly. It can be erased by simply exposing it to a strong source of ultraviolet (UV) light for a certain amount of time. • Electrically Erasable Programmable ROM (EEPROM): This type of ROM can be erased by an electrical charge and then written to by using slightly higher-than-normal voltage. EEPROM can be erased one byte at a time, rather than erasing the entire chip with UV light. Hence, the process of re-programming is flexible, but slow. • Flash ROM: flash ROM, also called flash BIOS or flash memory, is a type of ROM that can be erased and re-programmed in blocks. II.2 Internal Processor Memories These memories are placed within the CPU (processor) or is attached to a special fast bus. Internal memory usually includes cache memory and special registers, both of which can be directly accessed by the processor. This memory is used for temporary storage of data and instructions on which the CPU is currently working. Processor memory is the fastest among all the memories, but is most expensive also. II.2.1 Cache Memory Cache memory is used by the central processing unit of a computer to reduce the average time to access memory. The cache is a smaller, faster memory which stores copies of the data from the most frequently used main memory locations. As long as most memory accesses are to cached memory locations, the average latency of memory accesses will be closer to the cache latency than to the latency of main memory. The advantage of cache memory is that the CPU does not have to use the motherboard’s system bus for data transfer. Whenever data must be passed through the system bus, the data transfer speed slows to the motherboard’s capability. The CPU can process data much faster by avoiding the bottleneck created by the system bus. Cache memory is sometimes described in levels of closeness and accessibility to the microprocessor. There are three main types of cache memory: → L1 cache: It is small and is built inside the CPU. It is fast as compared to L2 cache → L2 cache: It is large but slower and is mounted on the motherboard → Most computers today come with L3 cache which is built out of the CPU Page 13 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA II.2.2 Registers The central processing unit (CPU) contains a number of memory locations which are individually addressable and reserved for specific purpose. These memory locations are called registers. CPU instructions operate on these values directly. Registers are at the top of the memory hierarchy, and provide the fastest way for a CPU to access data. On RISC processors, all data must be moved into a register before it can be operated. On CISC (Intel) chips, there are a few operations that can load data from RAM, process it, and save the result back out, but the fastest operations work directly with registers. The number of registers that a CPU has and the size of each (number of bits) help determine the power and speed of a CPU. For example a 32-bit CPU is one in which each register is 32 bits wide. Therefore, each CPU instruction can manipulate 32 bits of data. Some characteristics of CPU registers are: • Very fast (access times of a few nanoseconds) • Low capacity (usually less than 200 bytes) • Very limited expansion capabilities (a change in CPU architecture would be required) Expensive (more than one dollar/byte) Types of register Types of Registers are as Followings → Memory Address Register(MAR) : This register holds the memory addresses of data and instructions. This register is used to access data and instructions from memory during the execution phase of an instruction. → Program Counter (PC): It holds the address of the memory location of the next instruction when the current instruction is executed by the microprocessor. → Accumulator Register: This Register is used for storing the Results those are produced by the System. When the CPU will generate Some Results after the Processing then all the Results will be Stored into the AC Register. → Memory Data Register (MDR) : MDR is the register of a computer's control unit that contains the data to be stored in the computer storage (e.g. RAM), or the data after a fetch from the computer storage. → Index Register (IR) : Also known as base register. An index register in a computer's CPU is a processor register used for modifying operand addresses during the run of a program. → Memory Buffer Register (MBR): This register holds the contents of data or instruction read from, or written in memory. It means that this register is used to store data/instruction coming from the memory or going to the memory. → Data Register: A register used in microcomputers to temporarily store data being transmitted to or from a peripheral device. V. SECONDARY STORAGE DEVICES This is also known as auxiliary memory. It differs from primary storage in that it is not directly accessible by the CPU. The secondary memory provides backup storage for instructions (computer programs) and data. The instructions and data stored on secondary storage devices are permanent in nature. They can only be removed if the user wants it so or the device is destroyed. III.1 Magnetic Tape Magnetic tape is a recording medium consisting of a thin tape with a coating of a fine magnetic material, used for recording analogue or digital data. Data is stored in frames across the width of the tape. The frames are grouped into blocks or records which are separated from Page 14 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA other blocks by gaps. Magnetic tape is a serial access medium, similar to an audio cassette, and so data (like the songs on a music tape) cannot be quickly located. However large amounts of information can be stored within magnetic tape. This characteristic has prompted its use in the regular backing up of hard disks. Advantages and disadvantage of Magnetic Tapes The following are advantages and disadvantages of magnetic tape Advantages of magnetic tape Disadvantages of magnetic tape Probably the cheapest form of storage per megabyte of storage Serial access so can be quite slow to access data Can store large amounts of data - up to 1 Terabyte per tape cartridge Need a special piece of equipment to record and read the data on the tape Can be set up to do the back up overnight or over the weekend The data may be corrupted if the tape is placed near a strong magnetic field e.g. a large speaker or magnet They are portable because they are compact in size, lightweight and removable. the data on such devices are difficult to recover even if a minor bit error occurs. They are not flexible as compared to other media types when file updating requires record insertion or deletion. III.2 Magnetic Disk III.2.1 What is a Magnetic Disk? The magnetic disks are the most widely used and popular medium for direct access secondary storage. They offer high storage capacity and reliability and have capability to access the stored data directly. A magnetic disk comprises a thin piece of plastic/metal circular plate/platter, which is coated with a magnetic oxide layer. The data are represented as magnetized spots on the disk. Data are recorded on the disk in the form of tiny invisible magnetized and non-magnetized spots (representing 1s and 0s) on the coated surfaces of the disk III.2.2 Storage Organization of a Magnetic Disk A disk’s surface is divided into a number of invisible concentric circles called tracks the tracks are numbered consecutively from outermost to innermost starting from zero. The number of tracks on a disk may be as few as 40 on small, low-capacity disks, to several thousand on large, high-capacity disks. Each track of a disk is subdivided into sectors There are 8 or more sectors per track. A sector typically contains 512 bytes. Disk drives are designed to read/write only whole sectors at a time. The track sectors are grouped into a collection known as cluster. It refers to the basic allocation unit for storage on a disk, consisting of one or more-track sectors. The number of track sectors that make up one cluster depends on the type and size of the media. The term 'cluster' also refers to the minimum amount of disk space used by a single file. Even if the file occupies only part of a cluster, the entire cluster is allocated to the file and marked as used space. III.2.3 Disk formatting Disk formatting is the process of preparing a new disk by the computer system in which the disk is to be used. There exist two type of formatting: a) Low-level disk formatting - Disk drive’s read/write head lays down a magnetic pattern on the disk’s surface Page 15 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA - Enables the disk drive to organize and store the data in the data organization defined for the disk drive of the computer b) OS-level disk formatting - - - Creates the File Allocation Table (FAT) that is a table with the sector and track locations of data Leaves sufficient space for FAT to grow Scans and marks bad sectors III.2.4 Master Boot Record (MBR) The Master Boot Record, created when you create the first partition on the hard disk, is probably the most important data structure on the disk. It is the first sector on every disk. The location is always track (cylinder) 0, side (head) 0, and sector 1.The Master Boot Record contains the Partition Table for the disk and a small amount of executable code. The Master Boot Record then finds the system partition's starting location on the disk, and loads a copy of its Partition Boot Sector into memory. The Master Boot Record then transfers execution to executable code in the Partition Boot Sector. III.2.5 Storage Capacity of a Magnetic Disk Several parameters must be considered while finding out the capacity of a magnetic disk. These parameters include number of recording surfaces, number of tracks per surface, number of sectors per track and number of bytes per sector. Therefore, one can define storage capacity of a disk as a multiple of all the above parameters. No. of disk platters = 4, No. of usable surfaces = 6. A set of corresponding tracks on all the 6 surfaces is called a cylinder. Storage capacity of a disk system = Number of recording surfaces x Number of tracks per surface x Number of sectors per track x Number of bytes per sector III.2.6 Advantages of Magnetic Disks → More suitable than magnetic tapes for a wider range of applications because they support direct access of data → Random access property enables them to be used simultaneously by multiple users as a shared device. → Suitable for both on-line and off-line storage of data → the cost per bit of storage is low for magnetic disks. → An additional cost benefit is that magnetic disks can be erased and reused many times → Floppy disks and zip disks are compact and light in weight. Hence, they are easy to handle and store. → Very large amount of data can be stored in a small storage space Page 16 CSC-AL NOTES KOUANGA INNOCENTA GBHS-BAFOUSSAM → Data transfer rate for a magnetic disk system is normally higher than a tape system III.2.7 Limitations of Magnetic Disks → A disk crash or drive failure often results in loss of entire stored data. It is not easy to recover the lost data. → Some types of magnetic disks are not so easily portable like magnetic tapes → the cost of magnetic disks is low, but the cost of magnetic tapes is even lower → Must be stored in a dust-free environment → They possess slow data access speed as compared to the magnetic disks. III.2.8 Types of Magnetic Disk All magnetic disks come in the form of round platters. These disks are available in different sizes, shapes and designs. Some are attached to the read/write head assembly, whereas some are available in the form of removable disks. Broadly, magnetic disks can be classified into three types: floppy disk, hard disk and zip disk. 1) Floppy disks A floppy disk, or diskette, is a disk storage medium composed of a disk of thin and flexible magnetic storage medium, sealed in a rectangular plastic carrier lined with fabric that removes dust particles. Floppy disks are read and written by a floppy disk drive (FDD). Floppy diskettes are small, inexpensive, readily available, easy to store and have a good shelf life, if stored properly. The two types of floppy disks in use today are: → 5¼-inch diskette, whose diameter is 5¼-inch. It is encased in a square, flexible vinyl jacket → 3½-inch diskette, whose diameter is 3½-inch. It is encased in a square, hard plastic jacket Size (Diameter in inches) N° of surfaces N° of tracks N° of sectors/tracks N° of bytes/sector 5 ¼ 2 40 9 512 Capacity in bytes Approximate capacity 3 ½ 368640 2 80 36 512 360 KB 3 ½ 2949120 2 80 18 2.88 MB 512 1474560 1.44 MB 2) Hard disk A hard disk drive (HDD) is a data storage device used for storing and retrieving digital information using rapidly rotating disks (platters) coated with magnetic material. An HDD retains its data even when powered off. Data is read in a random-access manner, meaning individual blocks of data can be stored or retrieved in any order rather than sequentially. An HDD consists of one or more rigid ("hard") rapidly rotating disks (platters) with magnetic heads arranged on a moving actuator arm to read and write data to the surfaces. Depending on how they are packaged, hard disks are of three types: Zip/Bernoulli disks, Disk packs, Winchester disks 3) Zip disk A Zip drive is a small, portable disk drive used primarily for backing up and archiving personal computer files. Zip drives and disks come in two sizes. The 100 megabyte size actually holds 100,431,872 bytes of data or the equivalent of 70 floppy diskettes. There is also a 250-megabyte drive and disk. III.3 Optical Disk III.3.1 What is an Optical Disk? Page 17 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA An optical disk is a storage medium from which data is read and to which it is written by lasers. The typical optical disc, stores information in deformities on the surface of a circular disc and reads this information by illuminating the surface with a laser diode and observing the reflection. The optical disk storage system consists of a rotating disk coated with a thin layer of metal (aluminium, gold or silver) that acts as a reflective surface and a laser beam, which is used as a read/write head for recording the data onto the disk. There are three basic types of optical disks:  CD-ROM : Like audio CDs, CD-ROMs come with data already encoded onto them. The data is permanent and can be read any number of times, but CD-ROMs cannot be modified.  WORM : Stands for write-once, read -many. With a WORM disk drive, you can write data onto a WORM disk, but only once. After that, the WORM disk behaves just like a CD-ROM.  Erasable: Optical disks that can be erased and loaded with new data, just like magnetic disks. These are often referred to as EO (erasable optical) disks. III.3.1 Types of Optical Disks a) Compact Disk Compact disk is the most popular and the least expensive type of optical disk. It was originally intended only for storing music (in the form of digital audio) and can record about 80 minutes of uninterrupted playing time. A CD is capable of being used as a data storage device along with storing of digital audio. Compact disks are available in various formats: CD-ROM (compact disk-read-only memory), CD-R (compact disk recordable) and CD-RW (compact disk-rewritable) disks. - - - A CD-ROM disk comes with pre-recorded data by the manufactures and can be read but cannot be altered. CD-R is a type of WORM (write once-read many) disk that allows you to record your own data. Once written, the data on the CD-R can be read but cannot be altered. A CD-RW disk is rewritable version of CD-R, which means, it allows writing, erasing and rewriting of the data several times. The data recorded on all CD formats can be read using the CD-ROM drive; however, to write data on CD-R and CD-RW disks, one needs a special peripheral device known as CD-writer (or CD-burner) b) Digital Versatile Disk DVD, initially called digital video disk, is a high-capacity data storage medium. NOTE: Like CDs, DVDs are also available in different formats: DVD-ROM, DVD-R and DVDRW. c) Blu-ray Disk A Blu-ray Disc is a high-density optical disc storage medium, which is used for the storage of all high-definition digital formats like audio, video, and play-station games and so on. They have the same physical appearance as a DVD. The name “BLU-RAY” is actually a combination of the colour “blue” and “ray”. Here blue refers to the blue colour of the laser that is used for its reading and ray refers to the optical ray. Like CDs and DVDs, Blu-ray disks are also available in different formats: • BD-ROM: It comes with pre-recorded content that can only be read. • BD-R: It is a WORM type of disk on which you can record data only once. • BD-RW: It is similar to BD-R disk, but the difference is that it is rewritable. This means that the data can be erased and recorded a number of times on the same disk. • BD-RE: It is also a rewritable disk, but is used only for high-definition audio/video and television recording Blu-Ray Disc (BD) vs DVD • Both of them have the same physical appearance. [Thickness = 1.2 mm] • The single layer Blu-ray disc can store up to 27 GB data. A single layer DVD can hold only 4.7 GB of data. • A DVD needs two substrates and they should be bonded. But a Blu-ray disc requires only one substrate. Page 18 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA • The production cost of Blu-ray is lesser than that of a DVD because there is no need for bonding of substrates. • The Blu-Ray disc uses violet-blue laser with improved lens specifications, while a DVD uses red laser. III.4 Magneto-Optical Disk As implied by the name, these disks use a hybrid of magnetic and optical technologies. A magnetooptical disk writes magnetically (with thermal assist) and reads optically using the laser beam. A magneto-optical disk drive is so designed that an inserted disk will be exposed to a magnet on the label side and to the light (laser beam) on the opposite side. III.5 Memory Stick Memory Stick also known as 'Memory Card' is a digital storage device, which is designed to be used with portable electronic devices such as mobile phone, digital camera, PDA, iPod and so on. It was launched in 1998 by Sony and immediately gained popularity due to its support for fast data transfer speed and large storage capacity. Nowadays, several different standards or formats of Memory Stick are available in the market, which are as follows: • Memory Stick PRO (SP): It supports marginally higher data transfer speed than the original one and provides theoretical storage capacity of up to 32 GB • Memory Stick Duo (SD): It is a small size Memory Stick for small, pocket-sized devices such as mobiles, music players, digital cameras, and so on. • Memory Stick PRO Duo: Although Memory Stick Duo fulfils the need of smaller memory card for pocket-sized devices, it is superseded by Memory Stick PRO Duo because of its slow transfer rate and limited storage capacity of 128 MB. Memory Stick PRO Duo provides larger memory space (up to 32 GB) and high speed of data transfer to/from the card. • Memory Stick PRO-HG Duo: Unlike Memory Stick PRO which has a parallel interface of 4 bits, Memory Stick PRO HG Duo has 8-bit parallel interface. In addition, the clock frequency has increased from 40 to 60 MHz in the Memory Stick Pro-HG Duo. • Memory Stick Micro (M2): It is a light and compact storage medium, which comes in the dimension of 15 × 12.5 × 1.2 mm3. It offers large storage capacity ranging from 16 MB to 32 GB and transfer speed of 160 Mb/s. III.6 Universal Serial Bus Universal Serial Bus (USB) (developed by Intel) is a set of connectivity specification that establishes communication between personal computers and devices such as mouse, keyboard, pen drive and external hard disk drives. a) Pen Drive The flash drive is a high storage (ranging from 1 to 512 GB) capacity device and is physically small enough to fit into a pocket. In addition, it is fast, robust and reliable, and requires very less power to operate, which it gets through USB port and hence no battery is required. b) External Hard Disk Drive External hard disk drive is a type of hard drive that resides in its own enclosure (called hard drive cage) outside the computer case and is connected to the system through Page 19 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA Page 20 interfaces like USB. The internal structure and functioning of external hard disk drive is similar to the internal hard disk drive. Hence, external hard disk drive is a reliable and high-capacity storage media. In addition, it is portable and provides plug and play feature. III.7 Mass Storage Devices To get a vast amount of storage capacity in a computer system, a different kind of storage system is used. In such type of system, multiple units of similar kinds of storage media are associated together to form a chain of mass storage devices. These storage media may include multiple magnetic tape reels or cartridges, multiple arrays of magnetic disks or multiple CD-ROMs as storage devices. However, they have huge amount of storage capacity and possess minimum cost per bit storage. Mass storage devices are cost-effective option to the online tapes and disks storage in situations where large storage capacity is required and where prompt data access is not essential. When used as offline storage, they are referred as an archival storage. Broadly speaking, mass storage devices are categorized into three types: • Redundant Array of Inexpensive Disks (RAID): The basic idea of RAID is to combine multiple hard disks into an array of disk drives to obtain high performance, large capacity and reliability. These arrays of drives appear to the host computer as a single logical drive. • Automated Tape Library: An automated tape library comprises numerous sets of magnetic tapes along with their drives and controllers mounted in a single unit. The unit comprises one or more tape drives to perform read/write operations on the tapes in the tape library. • CD-ROM Jukebox: A CD-ROM jukebox comprises numerous sets of CD-ROM disks along with their drives and controllers mounted in a single unit. The unit comprises one or more CD-ROM drives to perform read/write operations on the CD-ROM in the jukebox. In the multiple CD-ROM drive environments, these CD ROMs can be simultaneously read or written, resulting in the speedy rate of data transfer. EXERCISE ON HARDWARE 1. When referring to storage devices name the two types of access and describe how they operate? 2. A mail order company keeps details of transactions stored on magnetic disc. A backup copy is also held on magnetic tape. i) Why does the company make a backup copy of the transactions? ii) Why can the company hold the back up on tape and not need to use disc? 3. Fred saves his report to disc and decides to print it out using the school’s laser printer. The school has the same type of pc as Fred and uses the same type and format of disc. However, Fred finds he cannot load his report on the school computer. Why is this? 4. Describe the differences between hard disc, CD ROM and WORM as methods of backing store? 5. Staff in a store carry out a stock check every week and input the data using OCR. The store is considering using palm top computers for the stock checks. Suggest 2 advantages palm tops have over OCR forms? 6. Sandie buys a new computer. It is described as a multimedia computer. Suggest one input and one output device it may have to warrant this description? Question [Special mock 2 Feb 2014 PCHS Bamenda] 1. The diagram bellow shows coded data that could be input into a computer 76143072497 (a) What is the name of the above method of input GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA Page 21 (b) Where would the above method of input be applied? (c) For the application you have given in the above question, state two items of information this type of input may represent. 2- with reasons, briefly describe the most appropriate type of printer or output device for the output of: (a) customer invoices on multi-part stationery (b) letters to customers (c) detailed engineering designs 3- What is a terminal? Name two types of terminal with short description of each 4- State what is meant by each of the following and give an example of where each is used. (a) Magnetic Ink Character Recognition (MICR) (b) Optical Mark Reader (OMR) (c) Distinguish LCD monitor and CRT monitor COMPUTER SOFTWARE Table of Contents I. INTRODUCTION TO SOFTWARE ............................................................................................ 22 I.1 Definition of software .................................................................................................................. 22 I.2 Relation between hardware and software .................................................................................... 22 I.3 Ways of acquiring computer software ......................................................................................... 22 II. CLASSIFICATION OF SOFTWARE .......................................................................................... 22 II.1 Classification of software based on task .................................................................................... 22 II.2 Classification of software based on source ................................................................................ 28 II.3 Classification of software based on licence ................................................................................ 28 II.4 Other type of software ................................................................................................................ 29 EXERCISES ON SOFTWARE ............................................................................................................ 30 GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA I. INTRODUCTION TO SOFTWARE I.1 Definition of software Software, by definition, is the collection of computer programs, procedures and documentation that performs different tasks on a computer system. It actually tells the computer what to do and how to do it. Software may enter the computer through one of following three ways. (i) (ii) (iii) I may be build into the computer circuit in the form of firmware. It may be loaded into the computer from a secondary storage device such as CD ROM or hard disk drives It is also be typed into the computer with the aid of the keyboard and programming tools I.2 Relation between hardware and software Software refers to the computer programs that are loaded into a computer system, and hardware refers to all the visible devices, which are assembled together to build a computer system. The blending of software and hardware gives life to a computer system. Even though hardware is the physical part of a computer, it is nothing unless it has software to control it. Hardware and software then share a special relationship. If hardware is the 'heart' of a computer system, software is its 'soul'. Both are complimentary to each other. Hardware is of no use without software and software cannot be used without hardware. I.3 Ways of acquiring computer software Software can enter the computer through different channels. Some of the common ways of acquiring computer software include: (i) (ii) (iii) (iv) (v) II. Buying the computer: when you buy a new computer from the shop, you are usually supplied with some software for free, from the computer manufacturer Buying the software from a shop: Downloading the software from a website for free (freeware) or after paying some money to the vendor Ordering from the vendor either by email, fax or postal letter. Here you also need to pay for the product before it is sent to you. Copying from other people’s machines: This is what most Cameroonians do and it is what referred to as software piracy. Software piracy is illegal and therefore punishable by law CLASSIFICATION OF SOFTWARE Computer software can be organized into categories based on common function, task, or field of use. We can then categorize software in different ways. II.1 Classification of software based on task GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA Based on the kind of task they perform, software can be divided into two major groups: System software and application software. The diagram below gives a simplified hierarchical organization of the main parts of software in a general-purpose computer. At the highest level of this hierarchy lies the application software, whose services are carried out by the underlying system software. Computers operate by executing software programs. This involves passing the instructions from the application software, through the system software to the hardware that ultimately receives the instruction as machine code. Each instruction causes the computer to carry out an operation such as data transmission, data processing, data storage or data control. II.1.1 System software System software is a type of computer software that controls the operation of the computer and provides facilities that extend the general capabilities of the machine. This provides the basic functions for computer usage and helps to run the computer hardware and system. It includes a combination of the following: 1) Operating system An operating system is a group of computer programs that coordinates all the activities among computer hardware devices. This is the most important type of system software in a computer. A user can’t run an application program on the computer except it is self booting without the Operating System. Operating systems are contained in almost all devices including mobile phones. (to be extended in the next chapter) Functions of an operating system An operating system executes many functions to operate computer system efficiently. Among them, four essential functions are the followings.  Resource Management: An operating system manages a collection of computer hardware resources by using a variety of programs. It manages CPU, primary memory, virtual memory, secondary storage devices, input/output peripherals, and other devices.  Task Management: The function of the operating system that controls the running of many tasks. It manages one program or many programs within a computer system simultaneously. That is, this function of operating system manages the completion of users' tasks.  File management: This is a function that manages data files. An operating system contains file management programs that provide the ability to create, delete, enter, change, ask, and access of files of data. The operating system keeps track of where files are located on the hard drive through the type of file system. The type two main types of file system most used in windows OS are File Allocation table (FAT) or New Technology File system (NTFS).  User Interface: It is a function of an operating system that allows users to interact with a computer. The two main types of user interfaces are: command line and a graphical user interface (GUI). With a command line interface, the user interacts with the operating system by typing commands to perform specific tasks. An example of a command line interface is DOS (disk operating system). GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA Examples of popular modern operating systems include Android, BSD, iOS, Linux (ubuntu, Knoppix, Dreamlinux, …) OS X, QNX, Microsoft Windows(Windows 95, 2000, Vista, 7, 8, …), Windows Phone, and IBM z/OS. All these, except Windows, Windows Phone and z/OS, share roots in UNIX. 2) Utility program This is system software designed to help analyse, configure, optimise or maintain a computer. A single piece will be called a utility or tool. Some Well-known utility software include:  Antivirus programs: They are used to detect and eliminate computer viruses and related malicious software. Some examples are: avast, AVG, Avira, BitDefender, Norton  Backup programs: They help to make copies of all information valuable to a computer or information system and store it safe. The information can be restored in the event of disk failure or other accidents that will lead to data loss.  Data Recovery: As the name implies, data recovery programs are used to recover data. Since disk drives or other hardware may fail, these utilities are essential to recover data in such a scenario.  Data Compression programs: They make the data more compact, reducing the space occupied by the data.  Disk management program : These are program involving formatting and arranging disk files in an orderly manner.  Memory management software : It handles locations in RAM where data put their current data. It can move certain memory-resident items out of the way so as to increase the memory space.  The Server: In the context of client-Server architecture, a server is a computer program running to serve the requests of other programs – “the clients”. The clients may run on the same systems or through networks. 3) Programming software It is the type of software that is used for creating other software. Another name for programming software is Integrated Development Environment (IDE). An IDE normally consist of a source code editor, a translator (compiler or interpreter) and a debugger. - - - Editor: It is a programming tool that is used for creating and modifying application programs. It helps the computer user to enter, search, delete, replace, copy and insert text or sections of a text in a desired position. Compiler: It is used to convert a complete program written in a high-level language (such as Pascal and C) into a program in machine language. Interpreter: A program which translates the program statements into machine language one line at a time as the program is running. GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA - - - - Assembler: A programming tool that convert a program in assembly language into program in machine language. Debugger: It is a program that is used for locating and correcting programming errors. Linker: A linker or link Editor is a program that takes one or more objects generated by the compiler and combines them to a single executable program.. Loader: Loader is a kind of system software, which is responsible for loading and relocation of the executable program in the main memory. The functions of a loader include assigning load time space for storage, that is, storage allocation and assisting a program to execute appropriately. 4) Device driver Device drivers are computer programs that allow higher level computer programs to communicate and interact with a hardware device. All hardware devices have the devices drivers that communicate with them through the computer bus to which the hardware is connected. Drivers are hardware dependent and operating system specific. Some specific categories of device drivers are Logical Device Drivers (LDD) which are written by the Operating System vendors Physical Device Drivers (PDD) which are written and implemented by the hardware vendor. To solve device driver crises, Microsoft has created the Windows Drivers Foundation (WDF) which collects and keeps all device drivers as a database. II.1.2 Application software Although system software has the vital job of controlling and managing the computer, it is the application software that lets you carry out the tasks for which the system was purchased. It enables the end users to accomplish certain specific tasks. Business software, databases and educational software are some forms of application software. Different word processors, which are dedicated to specialized tasks to be performed by the user, are other examples of application software. a) General purpose software A general purpose application, sometimes known as ‘off-the-shelf’ is the sort of software that you use at home and school. Examples include word processors, spreadsheets, databases, desktop publishing packages, graphics packages etc. GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA This type of software tries to be a ‘jack-of-all-trades’. It provides many features that the majority of users will want e.g. formatting text, creating charts, organising tables. But it does try to be’ all things to all people’ and so there will be a vast number of features that you may never use e.g. statistical functions, mail merge. This makes the storage size of these applications fairly large. There are several good reasons for using general purpose software:  It is relatively cheap  It is easily available from most computer shops  It will have been thoroughly tested so there won’t be any serious problems or bugs  There will be lots of user support i.e. books, user guides, online help and discussion forums on the Internet Examples of General Purpose Application Software:  Desktop Publishing Software - Often used to create graphics for point of sale displays, promotional items, trade show exhibits, retail package designs and outdoor signs. In very simple words, it could be said that it is a page maker application.  Word-Processing Software - Used for the production (including composition, editing, formatting, and possibly printing) of any sort of printable material. This software enables users to create, format, edit and print electronic documents (Letters, reports, articles, …). The most popular examples of this type of software are MS Word, WordPad and Word Perfect, Libreoffice writter.  Spreadsheet Software - Used for any kind of spreadsheet work including analysis, planning or modeling. This is a general purpose software with many functions. Spreadsheet software are used for creating documents to manage and organize numerical data. It is used to perform calculations on rows and columns of data Microsoft Excel, Lotus 1-2-3 and Apple Numbers are some examples of spreadsheet  Database Database is a structured collection of data. A computer database relies on database software to organize data and enable database users to perform database operations. Database software allows users to store and retrieve data from databases. Examples are Oracle, MSAccess, EasyPhp, etc.  Graphic package Allow you to create pictures and edit photographs. Example software: CorelDraw. Paint Shop Pro.  Presentation Software: The software that is used to display information in the form of a slide show is known as presentation software. This type of software includes three functions, namely, editing that allows insertion and formatting of text, methods to include graphics in the text and a functionality of executing slide shows. Microsoft PowerPoint and Micromedia director are the best example of presentation softwareWeb design application b) Specific purpose software Function-specific software are highly specialized software that are designed to handle specific tasks. They're more limited in what they can do, but they usually perform much better than a general purpose program in a specific task. For example, TurboTax (a tax preparation package) is a special purpose application. Sure, it adds and subtracts numbers like a spreadsheet, but you can't use it to plan your monthly budget. It does only one thing - prepare tax returns. Other examples of special purpose GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA application software are web browsers, calculators, media players, calendar programs etc. Again, make sure that you don't use brand names!  Communications software: Used to send messages and emails Example software: MS Outlook Express. MS Messenger.  Desktop publishing programs: Used to combine and control graphics and text in a single document. Example software: Adobe PageMaker. MS Publisher.  Web browser: Computer program that enables internet users to access, navigate, and search World Wide Web sites. It is also called browser. Ex: Mozilla Firefox, Internet explorer, Opera, Google chrome  Enterprise Software: It deals with the needs of organization processes and data flow. Customer relationship management or the financial processes in an organization are carried out with the help of enterprise software. Ex: Sage Saari  Multimedia Software: They allow users to create and play audio and video files. They are capable of playing media files. Audio converters, audio players, burners, video encoders and decoders are some forms of multimedia software. Examples of this type of software include Real Player and Windows Media Player. c) Bespoke software Although most organisations use general purpose software, some organisations will find that it just doesn’t do exactly what they want or it doesn’t work with their current systems. In this case, they might decide to have the software system they need designed and developed specifically for them. This is called ‘tailor-made’ or ‘bespoke’ software. Bespoke application software is tailor made for a specific user and purpose. For example a factory may require software to run a robot to make cars; however, it is the only factory making that car in the world, so the software required would have to be specially built for the task. The main advantages are:  the company will get the exact software/system that they need  the software will work exactly how they want it to work  the software will only have the features that they specifically need in their business. The main disadvantages of this approach are:  it takes a long time to develop such a system, between a few months to years  it costs a great deal of money to develop such a system.  the company may need to employ a team of people such as business analysts, programmers, testers etc  there will be little in the way of user support and online help Other examples might include software for the military, missile/UAV operations, software for hospitals and medical equipment, software being written inside banks and other financial institutions. GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA II.2 Classification of software based on source Based on code source, we distinguish two types of software: Open Source Software and Closed Source Software. II.2.1 Closed source software Also called proprietary software, it is software with restricting on using, copying and modifying the source code as enforced by the proprietor. In other words, computer users do not have any access to the source code of the proprietary software. Well known examples of proprietary software include: Windows, RealPlayer, Adobe Photoshop, Mac OS, ... II.2.2 Open source software It is the type of software that has no proprietary restriction attached to it, particularly the restriction about the access to the source code. In other words, open source software is designed in such a way that computer users can freely access and modify the source code to suit their individual need. It is also called non-proprietary software. E.g. Linux, Open Office II.3 Classification of software based on licence The term licence refers to a legal document or agreement giving someone permission to do and use something. A software licence comprises the permissions, rights and restriction imposed on a piece of software. Under a software licence, the Licensee is permitted to use the licence software in compliance with a specific term on the licence. Based on licence, computer software may be divided into the following: II.3.1 Public Domain Software.GPL The GNU General Public License (GNU GPL or simply GPL) is a free software license, originally written by Richard Stallman for the GNU project (a project to create a complete free software operating system). It has since become one of the most popular licenses for free software. The latest version of the license, version 2, was released in 1991. The GNU Lesser General Public License (LGPL), another commonly-used license, is a modified version of the GPL intended for software libraries. The GPL grants the recipients of a computer program the following rights, or "freedoms":  The freedom to run the program, for any purpose.  The freedom to study how the program works, and modify it. (Access to the source code is a precondition for this)  The freedom to redistribute copies.  The freedom to improve the program, and release the improvements to the public. (Access to the source code is a precondition for this) . II.3.2 Freeware This is a Copyrighted software given away for free by the author. Although it is available for free, the author retains the copyright, which means that you cannot do anything with it that is not expressly allowed by the author. Usually, the author allows people to use the software, but not sell it. You are also free to distribute it to anyone you want, provided the distribution is an unmodified version of what you downloaded from the provider’s web site. In fact they encourage you to distribute their Freeware. Freeware is provided on an "as is" basis and no technical support is usually available. II.3.3 Shareware GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA This may be copyrighted software, regularly in trial version, but generally the developer allows users to make copies without an initial charge. However, if the user intends to use it beyond a brief tryout, the developer requests that the program be paid for. A marketing method for software, whereby a trial version is distributed in advance and without payment. A user tries out the program, and thus shareware has also been known as 'try before you buy', demoware, trialware and by many other names. II.3.4 Crippleware The shareware version of a program whose most advanced and most desirable features have been disabled with the intention of increasing users apetite for the better version. If the fee is paid, a code is acquired, which uncripple the program. II.3.5 Nagware: Nagware (also known as annoyware) is a type of shareware, that reminds —or nags— the user to register it by paying a fee. It usually does this by popping up a message when the user starts the program or, worse, intermittently while the user is using the application. These messages can appear as windows obscuring part of the screen or message boxes that can quickly be closed. Some nagware keeps the message up for a certain time period, forcing the user to wait to continue to use the program II.3.6 Adware: Advertising-supported software is any software package which automatically plays, displays, or downloads advertising material to a computer after the software is installed on it or while the application is being used. II.3.7 Liteware This is the free version of a program, that does not contain those features that are attractive to frequent or heavy user. II.3.8 Vapoware Vaporware (or vapourware) is software or hardware which is announced by a developer well in advance of release, but which then fails to emerge, either with or without a protracted development cycle. II.4 Other type of software Custom Software: Software that is developed for a specific user or organization is custom software. Since it is built for a specific user, its specifications and features are in accordance with the user's needs. Off-the-Shelf Software: As opposed to custom software, off-the-shelf software is standard software bought off the shelf. It has predefined specifications that may or may not cater to any specific user's requirements. When you buy it, you agree to its license agreement. Tailor Made Software: Tailor made software is software that is made to the specifications of a client. In other words it is custom made, bespoke, or 'tailored' to address a specific need Retail Software: While shareware is provided as a trial version to users, retail software is sold to end users. Firmware: Firmware is a combination of software (generally, system software) permanently stored in the memory (hardware). As the name suggests, it is a program or data that has been written onto the read-only memory (ROM). For example, the BIOS (which is installed inside GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA a computer on a chip) checks different parts of the system before loading the operating system into the memory. Liveware: People who write programs, operate and maintain the computers are collectively known as liveware, humanware or peopleware; for example, programmers, system analysts and hardware engineers. EXERCISES ON SOFTWARE Exercise 1: State whether each of the following operations is carried out by the operating system or by an application software delete a file, format a disk, play a game, load from a disk, write a letter, enter a list of names, create a new folder, print a file, draw a picture, double click the mouse button, select from a menu, carry out a single field sort, get a directory listing, do a calculation, select QUIT. Exercise 2: State whether the following task is carried out by a word processor, a spreadsheet, a database or a graphic software 1) Typing articles for a club newsletter 2) Keeping track of income and expenditure in a shop 3) Storing information about members of a youth club 4) Analysing sales figures and trends in sales 5) Designing a business card for a small firm 6) Typing a letter to members of a youth club 7) Making changes to a photograph 8) Creating a 'No Smoking' sign 9) Preparing the year accounts for a small business 10) Storing details of 500 CDs in a music collection 11) Drawing a map for a treasure hunt 12) Preparing an essay for English class 13) Recording details of products in a supermarket 14) Drawing a picture of a house 15) Scanning a picture in a book Exercise 3: [Premock Oct 2013 PCHS Bda] A secondary school has been using several versions of office automation software packages which consist of a word-processing software and spreadsheet software. This years the school plans to upgrade the office automation software packages so as to increase the use of information technology in teaching, to improve daily communication among its staff, and students and to computerize students' attendance record system. 1. Name three additional types of software that should be included in this upgrade exercise. State one corresponding application for each type of software. 2. The teacher makes use of an upgraded word-processing software to prepare a computer test paper in school. However he cannot open the document at home with its old version of word-processing software. Explain why the teacher cannot open the document and suggest one method the teacher can use to avoid the problem without any additional cost. Vocabulary: To upgrade = to improve what was old or outdated. Upgrade a software GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA implies adding new functionalities. Exercise 4: 1. ‘Hardware is of no use without software and software cannot be used without hardware.’ Explain. 2. What is the difference between an Open source Software and a Freeware. Write one example of each. 3. What is an operating system? Names of any two popular operating systems. 4. Name and explain any two main functions of an operating system Exercise 5: 1. For each type of software, copy the correct description along with two examples: Application Software 1. Word processors 2. Spreadsheets 3. Databases 4. Desktop publishing programs 5. Presentation applications 6. Web design applications 7. Graphics programs 8. Multimedia display programs 9. Web browsing applications 10. Communications software Example Applications - Internet Explorer - Real Player - Adobe PageMaker - Firefox - Word Perfect - MySQL - CorelDraw - MS Publisher - MS Excel - Macromedia Director - MS Outlook Express - Windows Media Player - Lotus 123 - MS PowerPoint - MS Messenger - MS Word - MS FrontPage - DreamWeaver - MS Access - Paint Shop Pro Descriptions  Used to combine and control graphics and text in a single document  Used to perform calculations on rows and columns of data  Allow you to create pictures and edit photographs  Used to send messages and emails  Enable you to write, edit and print letters, articles and reports.  Used to design and edit pages of information for the internet  Allow you to view videos and animations with sound  Use to organise and search through collections of data  Used to view websites on the internet  Allow you to present information to an audience 2. Describe how bespoke software is different from the normal software packages purchased in shops. 3. Give a short description (or definition) of the following words or expressions (no more than 2 lines per word): Loader, Crippleware, Open source software GBHS-BAFOUSSAM CSC-AL NOTES KOUANGA INNOCENTA COMPUTER SYSTEM ARCHITECTURE Contents I. INTRODUCTION TO COMPUTER SYSTEM ...................................................................................... 33 II. WHAT IS COMPUTER ARCHITECTURE? ..................................................................................... 33 III. ABSTRACTION LAYERS OF A COMPUTER ARCHITECTURE ......................................................... 33 IV. THE VON NEUMANN ARCHITECTURE ....................................................................................... 34 V. THE INSTRUCTION SET ARCHITECTURE ..................................................................................... 42 VI. ADDRESSING MODES ................................................................................................................ 46 VII. INTERRUPT AND POOLING ........................................................................................................ 47 VIII. OTHER TYPES OF ARCHITECHTURE ....................................................................................... 48 IX. MODERN MICROPROCESSOR ARCHITECTURE .......................................................................... 49 I. INTRODUCTION TO COMPUTER SYSTEM A computer can be viewed as a system, which consists of a number of interrelated components that work together with the aim of converting data into information. The physical parts that make up a computer (the central processing unit, input, output and storage unit) are known as hardware. Any hardware device connected to the computer or any part of the computer outside the CPU and the working memory is known as a peripheral; for example, keyboard, mouse and monitor. There are four components required for the implementation of a computerized input-process output model: 1. The computer hardware, which provides the physical mechanisms to input and output data, to manipulate and process data, and to electronically control the various input, output, and storage components. 2. The software, both application and system, which provides instructions that tell the hardware exactly what tasks are to be performed and in what order. 3. The data that is being manipulated and processed. This data may be numeric, it may be alphanumeric, it may be graphic, ... 4. The communication component, which consists of hardware and software that transport programs and data between interconnected computer systems. II. WHAT IS COMPUTER ARCHITECTURE? Computer architecture is a specification detailing how a set of software and hardware technology standards interact to form a computer system or platform. In short, computer architecture refers to how a computer system is designed and what technologies it is compatible with. There are many categories of computer architecture:  System Design: This includes all hardware components in the system, including data processors aside from the CPU, such as the graphics processing unit and direct memory access. It also includes memory controllers, data paths and miscellaneous things like multiprocessing and virtualization  Instruction Set Architecture (ISA): This is the embedded programming language of the CPU. It defines the CPU's functions and capabilities based on what programming it can perform or process. This includes the word size, processor register types, memory addressing modes, data formats and the instruction set that programmers use.  Microarchitecture: Otherwise known as computer organization, this type of architecture defines the data paths, data processing and storage elements, as well as how they should be implemented in the ISA. Computer Architecture = Instruction Set Architecture + Computer Organization. Instruction Set Architecture (ISA) is what the computer does (logical view) and Computer Organization is how the ISA is implemented (physical view). III. ABSTRACTION LAYERS OF A COMPUTER ARCHITECTURE A hardware abstraction layer (HAL) is a logical division of code that serves as an abstraction layer between a computer's physical hardware and its software. It provides a device driver interface allowing a program to communicate with the hardware. The main purpose of a HAL is to conceal different hardware architectures from the OS by providing a uniform interface to the system peripherals. A PC may include the HAL in the OS kernel or in the form of device drivers that provide a consistent interface for applications to interact with the hardware peripherals. IV. THE VON NEUMANN ARCHITECTURE A very good example of computer architecture is Von Neumann architecture, which is still used by most types of computers today. This was proposed by the mathematician John Von Neumann in 1945. This architecture is comprised of an Arithmetic Logic Unit (ALU), Memory, Input/Output, and a control unit. Fig : Schematic diagram of von Neumann architecture In von Neumann’s model, a computer has 3 subsystems (i) a CPU, (ii) a main memory, and (iii) an I/O system. The main memory holds the program as well as data and the computer is allowed to manipulate its own program. In the von-Neumann model, instructions are executed sequentially (one at a time). In the von-Neumann model a single path exists between the control until and main memory, this leads to the so-called "von Neumann bottleneck" since memory fetches are the slowest part of an instruction they become the bottleneck in any computation.  HARVARD ARCHITECTURE The Harvard architecture is a computer architecture with separate storage and signal pathways for instructions and data. It contrasts with the von Neumann architecture, where program instructions and data share the same memory and pathways. IV.1 Central Processing Unit IV.1.1 Understanding what CPU is a) Definition The central processing unit, also known as processor, is the brain of the computer system that processes data (input) and converts it into meaningful information (output). It is referred to as the administrative section of the computer system that interprets the data and instructions, coordinates the operations and supervises the instructions. The CPU consists of three main subsystems: the arithmetic/logic unit (ALU), the control unit (CU) and the registers. These three subsystems work together to provide operational capabilities to the computer. Fig: The CPU architecture Central Processing Unit (CPU) General Registers R0 R1 R2 ALU Output Register R3 Input Register 1 Input Register 2 Instruction Decoder Program Counter Instruction Register Internal Bus Control Unit b) Characteristics of the CPU Memory Addr. $ Address Bus Data Bus Control Bus Read/Write 000 001 002 3FD 3FE $ 3FF The common characteristics of a CPU can affect it in many different ways to help your computer: A microprocessor can be characterized by:  Instruction Set: It is the set of instructions that the microprocessor executes  Number of cores: The core fetches and decodes instructions. So if you add more than one it will increase the speed of performance of the computer system.  Cache size: Therefore, having a larger cache size on the CPU can improve the performance of the computer.  The clock speed: The System Clock is an electronic circuit that generates pulses. The number of pulses generated by the clock per unit of time is its Clock speed., faster is the CPU. The speed of the CPU is measured in MEGAHERTZ (MHZ), which corresponds to the millions of cycles per second (1 MHz = 1 million of cycle per second = number of instructions per second). c) Examples of CPU The most commonly used CPU in PCs are made by Intel. Since IBM chose the Intel 8088 chip for the original IBM PC, most PC clones have used one of the Intel series of CPUs: → 8088 - used in IBM PC → 80286 - used in IBM PC AT → 80386 - used in first PC clone from Compaq → 80486 - you heard phrases like “I have a 486 PC” → Pentium I, Pentium II, Pentium III, Pentium IV - Most desktop PCs in 2004 used the P4 chip. → dual core, core i3, i5, i7… d) Types of Processor According To Flynn's Taxonomy  SISD: (single instruction stream, single data stream) Conventional computer architecture with 1 processor; instructions are done sequentially. Your PC or Macintosh is of this type.  SIMD: (single instruction stream, multiple data stream) A single instruction processing unit, called a controller, and several data processing unit. It means that all parallel units share the same instruction, but they carry it out on different data elements. The Thinking Machines CM-1 and MassPar MP-1 were examples of such architecture.  MISD: (multiple instruction streams, single data stream) This category in which various computing elements work on a single data has never lead to a successful computer.  MIMD: (multiple instruction streams, multiple data stream) This is the widest and most successful category of parallel computers. It means parallel units have separate instructions, so each of them can do something different at any given time; one may be adding, another multiplying, yet another evaluating a branch condition, and so on. Nowadays, DEll, IBM, and HP servers are of this type. e) Types of Processor According to instructions set Processors differ from one another by their instruction sets. If the same program can run on two different processors, they are said to be compatible. For example, programs written for IBM computers may not run on Apple computers because these two architectures (different processors) are not compatible. Based upon the instruction sets, there are two common types of architectures: complex instruction set computer (CISC) and reduced instruction set computer (RISC).  CISC Architecture To make compiler development easier, complex instruction set computer (CISC) was developed. The sole motive of manufacturers of CISC-based processor was to manufacture processors with more extensive and complex instruction set. It shifted most of the burden of generating machine instructions to the processor. For example, instead of making a compiler to write long machine instructions for calculating a square root, a CISC processor would incorporate a hardwired circuitry for performing the square root in a single step. Writing instructions for a CISC processor is comparatively easy because a single instruction is sufficient to utilize the built-in ability. Most of the PCs today include a CISC processor.  RISC Architecture Reduced instruction set computer (RISC) is a processor architecture that utilizes a small, highly optimized set of instructions. The concept behind RISC architecture is that a small number of instructions are faster in execution as compared to a single long instruction. To implement this, RISC architecture simplifies the instruction set of the processor, which helps in reducing the execution time. Optimization of each instruction in the processor is done through a technique known as pipelining.  Comparing CISC and RISC Architectures Basic CISC RISC Instruction Set Complex instructions Program Code Size Simple instructions Smaller Lengthier Processor Size Increased hardwired circuitry leads to increased processor size Reduced hardwired circuitry leads to reduced processor size Memory Usage Less memory intensive Power Consumption More memory intensive More power Less power Heating More heat Fixed length instructions Less heat Variable length instructions IV.1.2 Arithmetic Logic Unit (ALU): This unit performs the arithmetic (add and subtract) and logical operations (and, or) on the available data. The ALU comprises two units: an arithmetic unit and a logic unit.  Arithmetic Unit: The arithmetic unit contains the circuitry that is responsible for performing the actual computing and carrying out the arithmetic calculations such as addition, subtraction, multiplication and division. It can perform these operations at a very high speed.  Logic Unit: The logic unit enables the CPU to make logical operations based on the instructions provided. The logic unit can compare numbers, letters or special characters and can then take action based on the result of the comparison. IV.1.3 Control Unit: The control unit can be thought of as the heart of the CPU. It is made up of the following:  PC (Program Counter): stores the address of next instruction to fetch  IR (Instruction Register): stores the instruction fetched from memory  Instruction Decoder: Decodes instruction and activates necessary circuitry The figure below illustrates how  Control unit instructs the other parts of the CPU (i.e. ALU and registers) and the I/O devices on what to do and when to do. In addition,  It determines what data are needed, where they are stored and where to store the results of the operation as well as sends the control signals to the devices involved in the execution of the instructions. Figure : The control unit IV.1.3 Registers: These are the special-purpose, high-speed temporary memory units that hold the information that the CPU is currently working on. There are various types of registers present inside a CPU. The most basic and essential registers for any CPU are.  The Program Counter (PC) is a special register that holds the address of the next instruction to be fetched from Memory . The PC is incremented to ("point to") the next instruction while an instruction is being fetched from main memory.  The Instruction Register (IR) is a special register that holds each instruction after it is fetched from main memory.  The General Registers R0, R1, R2, R3 are available for the programmer to use in his/her programs. Typically the programmer tries to maximise the use of these registers in order to speed program execution.  Accumulator (ACC): An accumulator is a general-purpose register used for storing temporary results and results produced by arithmetic logic unit.  Memory Address Register (MAR): The MAR register is used to store the address of the location in memory that is to be accessed for reading or writing.  Memory Buffer Register (MBR): A memory buffer register is used for storing data either coming to the CPU or data being transferred by the CPU.  Memory Data Register (MDR): A data register is used for storing the operands and other data. The size or length of each register is determined by its function. For example, the memory address register, which holds the address of the next location in memory to be accessed, must have the same number of bits as the memory address. Instruction register holds the next instruction to be executed and, therefore, should be of the same number of bits as the instruction. (NB: The number and sizes of registers vary from processor to processor.) IV.2 Main Memory Unit Logically, main memory is an integral component of the CPU, but physically it is a separate part placed on the computer's motherboard. It stores program instructions or data for only as long as the program they pertain to is in operation. The primary memory is of two types: random access memory (RAM) and read only memory (ROM). Main memory can be considered to be organised as a matrix of bits. Each row represents a memory location, typically this is equal to the word size of the architecture, although it can be a word multiple (e.g. 2xWordsize) or a partial word (e.g. half the wordsize). Each row also has a natural number called its address which is used for selecting the row: • Memory width (W): How many bits is each memory cell • Address width (N): How many bits used to represent each address, determines the maximum memory size = address space. If address width is N-bits, then address space is 2N (0,1,...,2N-1) IV.2.1 Random Access Memory Random access memory (RAM) directly provides the required information to the processor. It is used to hold both program code (instructions) and data (numbers, strings etc) on which the computer is working. It is volatile in nature, which means the information stored in it remains only as long as the power is switched ON. Computer architectures also impose an architectural constraint on the maximum allowable RAM. This constraint is normally equal to 2Word Size memory locations. Although slower than register memory, the contents of any location in RAM can still be “read” or “written” very quickly. The time to read or write is referred to as the access time and is constant for all RAM locations. RAM can be further classified into two categories:  SRAM (Static RAM) is the fastest form of RAM but also the most expensive. Due to its cost it is not used as main memory but rather for cache memory. Each bit requires a 6-transistor circuit.  DRAM (Dynamic RAM) is not as fast as SRAM but is cheaper and is used for main memory. Each bit uses a single capacitor and single transistor circuit. Since capacitors lose their charge, DRAM needs to be refreshed every few milliseconds. The memory system does this transparently. There are many implementations of DRAM, two well-known ones are SDRAM and DDR SDRAM.  SDRAM (Synchronous DRAM) is a form of DRAM that is synchronised with the clock of the CPU’s system bus, sometimes called the front-side bus (FSB). As an example, if the system bus operates at 167Mhz over an 8-byte (64-bit) data bus , then an SDRAM module could transfer 167 x 8 ~ 1.3GB/sec.  DDR SDRAM (Double-Data Rate DRAM) is an optimisation of SDRAM that allows data to be transferred on both the rising edge and falling edge of a clock signal. Effectively doubling the amount of data that can be transferred in a period of time. For example a PC-3200 DDR-SDRAM module operating at 200Mhz can transfer 200 x 8 x 2 ~ 3.2GB/sec over an 8-byte (64-bit) data bus. IV.2.2 Read-only Memory ROM (Read Only Memory) is like RAM except that its contents cannot be overwritten and are not lost if power is turned off (ROM is non-volatile). The ROM stores the initial start-up instructions and routines in the BIOS (basic input/output system). The instructions in the ROM are built into the electronic circuits of the chip, which is called firmware. The ROM is also random access in nature. Various types of ROM, namely,  PROM (Programmable ROM) is like ROM but allows end-users to write their own programs and data. It requires a special PROM writing equipment. Note: users can only write-once to PROM.  EPROM (Erasable PROM). With EPROM we can erase (using strong ultra-violet light) the contents of the chip and rewrite it with new contents, typically several thousand times.  EEPROM (Electrically Erasable PROM). As the name implies the contents of EEPROMs are erased electrically.  FLASH memory is a cheaper form of EEPROM where updates (erase-writes) can only be performed on blocks of memory, not on individual bytes. The number of erase/write cycles to a block is typically several hundred thousand before the block can no longer be written. IV.3 Interconnection of Units Now, let us discuss the interconnection between the CPU (CU, ALU and registers), the memory unit, and the I/O devices, which constitute the entire computer system. IV.3.1 System Bus The Bus is the functional units are interconnected to enable data transport (e.g. write CPU register data content to a certain address in memory). It is a set of connections between two or more components/devices, which is designed to transfer several/all bits of a word from source to destination. A bus can be unidirectional (transmission of data can be only in one direction) or bidirectional (transmission of data can be in both directions). A bus that connects to all the three components (CPU, memory and I/O devices) is called a system bus. Fig: System bus a) Data bus: Data lines provide a path for moving data between the system modules. These are collectively known as data bus. Normally, a data bus consists of 8, 16 or 32 separate lines. The number of lines present in a data bus is called the width of data bus. Data bus width limits the maximum number of bits, which can be transferred simultaneously between two modules. Unlike the address bus, the data bus is bi-directional (it supports read and write operations). The data bus is not limited to transferring data; it is also used to transfer program instructions. b) Address bus: is used to specify a physical memory address. This can include primary memory (e.g. RAM and ROM) secondary memory (e.g. hard disk drives) and any other connected devices. Monitors, printers, scanners, and keyboards will all be mapped to memory. The width of the address bus determines the amount of memory that can be addressed. A 32 bit bus can address 4,294,967,296 (2 ^ 32) bytes of memory. This explains the 4 GB memory restriction on 32-bit operating systems. c) Control bus: Control bus carries commands from and returns status signals to the microprocessor. These lines are used for the transmission of commands and timing signals (which validate data and address) between the system modules. IV.3.2 Cache A cache is a piece of very fast memory, made from high-speed static RAM that reduces the time of accessing data. It is very expensive and generally incorporated in the processor, where valuable data and program segments are kept. Major reason for incorporating cache in the system is that the CPU is much faster than the DRAM and needs a place to store information that can be accessed rapidly. The cache facilitates the system to catch up with the processor's speed. The cache fetches the frequently used data from the DRAM and buffers (stores) it for further processor usage. Cache can be further categorized into three levels i. Level 1 Cache (L1): Level 1 cache, also known as primary cache, is built into the processor chip. It is a small fast memory area that works together with the Level 2 cache to provide the processor much faster access to important and often used data. ii. Level 2 Cache (L2): Level 2 cache, also known as secondary cache, is a collection of static RAM chips that are built onto the motherboard. It is little larger and slower than L1, but is faster than the main memory. L1 and L2 cache are used together for optimal use of the processor. iii. Level 3 Cache (L3): L3 cache memory is an enhanced form of memory present on the motherboard of the computer. It is an extra cache built into the motherboard between the processor and the main memory to speed up the processing operations Fig : L1, L2 and L3 caches V. THE INSTRUCTION SET ARCHITECTURE An instruction set or computer set architecture (ISA) is a collection of all possible machine language commands that are understood and can be executed by a processor. It is the part of the computer architecture related to programming, including the native data types, instructions, registers, addressing modes, memory architecture, interrupt and exception handling, and external I/O. V.1 Types if instruction a) Data Movement Instructions: These are used to transfer or copy data from one location to another either in the registers or in the external main memory. e.g. 8086 LOAD, STORE, MOVE b) Arithmetic Instructions: These instructions are used to perform operations on numerical data. (e.g ADD, SUB, SHIFT, ) c) Logical Instructions: These are used to perform Boolean operations on non-numerical data. (e.g. 8086 CMP, AND, OR, XOR instructions) d) Program Control Instructions: These are used to change the sequence of a program execution. E.g. CALL, RETURN, HALT Stop program execution e) Branch: JZ, JNZ, JUMP X f) Load next instruction from memory loc. X Input–output Instructions: These are used to transfer data from and to I/O devices. V.2 Instruction format Each machine language instruction is composed of two parts: the op-code and the operand. The figure below illustrates the format of an instruction used by many processor. The first three bits represent the op-code and the final six bits represent the operand. The middle bit represents whether the operand is a memory address or a number. When the bit is set to 1, the operand represents a number. Figure . An Instruction Format Architectures are differentiated from one another by the number of bits allowed per instruction (16, 32, and 64 are the most common), by the number of operands allowed per instruction, and by the types of instructions and data each can process. More specifically, instruction sets are differentiated by the following features:  Operand storage in the CPU (data can be stored in a stack structure or in registers)  Number of explicit operands per instruction (zero, one, two, and three being the most common)  Operand location (instructions can be classified as register-to-register, register-to memory or memory-to-memory, which simply refer to the combinations of operands allowed per instruction)  Operations (including not only types of operations but also which instructions can access memory and which cannot)  Type and size of operands (operands can be addresses, numbers, or even characters) There exist various types of instruction formats. The most common are: 0-address instruction, 1 address instruction, 2-address instruction and 3-address instruction 1) 0-address instruction (stack architecture) It is used in a stack architecture. A 0-address instruction uses a stack to hold both the operands and the result. Operations are performed on the operands stored on the top of the stack and the second value on the stack. The result is stored on the top of the stack. Just like the use of an accumulator register, the addresses of the stack registers need not be specified, their usage is implicit. Therefore, only one field is required in 0-address instruction; it specifies the op-code. Example: add tos ← tos + next 2) 1-address instruction (accumulator architecture) A 1-address instruction has a dedicated CPU register, called the accumulator, to hold one operand and to store the result. There is no need of encoding the address of the accumulator register to access the operand or to store the result, as its usage is implicit. Example: add A acc ← acc + mem[A] 3) 2-address instruction (Register (register-memory)) A 2-address instruction has three fields; one for the op-code, the second field specifies the address of one of the source operands as well as the destination operand, and the last field is used for holding the address of the second source operand. So one of the fields serves two purposes; specifying a source operand address and a destination operand address. It is a memory – memory instruction or a register – memory instruction. Example: add A, B add R1, A load R1, A mem[A] ← mem[A] + mem[B] R1 ← R1 + mem[A] R1 ← mem[A] 4) 3-address instruction (Register (load-store)) A 3-address instruction specifies the addresses of two operands and the address of the destination operand. It is a memory – memory instruction or register – register instruction Example: add A, B, C mem[A] ← mem[B] + mem[C] add R1, R2, R3 R1 ← R2 + R3 load R1, R2 R1 ← mem[R2] store R1, R2 Example1 : Code Sequence C = A + B mem[R1] ← R2 Stack Accumulator Register (register-memory) Register (load-store) Push A Push B Add Pop C Load A Add B Store C Load R1, A Add R1, B Store C, R1 Load R1,A Load R2, B Add R3, R1, R2 Store C, R3 Example 2: X=A * B + C * C Instruction Comments 0-address instruction PUSH A PUSH B MULTIPLY PUSH C PUSH C MULTIPLY ADD POP X Transfer A to top of stack Transfer B to top of stack Remove A, B from stack and replace by A x B Transfer C to top of stack Transfer second copy of C to top of stack Remove C, C from stack and replace by C x C Remove C x C, AxB from stack, replace by their sum Transfer result from top of stack to X 1-address instruction LOAD A MULTIPLY B STORE T LOAD C MULTIPLY C ADD T STORE X Transfer A to accumulator AC AC ← AC * B Transfer AC to memory location T Transfer C to accumulator AC AC ← AC * C AC ← AC + T Transfer result to memory location X 2-address instruction MOVE A, T MULTIPLY B, T MOVEC, X MULTIPLY C, X ADD T, X T ← A T ← T * B X ← C X ← X * C X ← X + T 3-address instruction MULTIPLY A, B, T MULTIPLY C, C, X ADDX, T, X T ← A x B X ← C x C X ← X + T V.1 The Instruction Cycle An instruction cycle (sometimes called fetch decode-execute cycle, or FDX) is the basic operation cycle of a computer. It is the process by which a computer retrieves a program instruction from its memory, determines what actions the instruction requires, and carries out those actions. A simple instruction cycle consists of the following steps: Fetch: obtaining a program instruction or data item from the memory. Decode: translating the instruction into commands the computer can execute. Execute : carrying out the commands How does this all work together? Program Execution: – PC is set to the address where the first program instruction is stored in memory. – Repeat Fetch instruction Decode instruction Execute instruction until HALT instruction or fatal error V.1.1 The Fetch Cycle During this cycle, the instruction, which is to be executed next, is fetched from the memory to the processor. The steps performed during the fetch cycle are as follows: 1. PC --> MAR: This address is transferred from PC to MAR. 2. Fetch signal: The instruction is read from the memory. 3. PC + 1 --> PC: Then, the PC is incremented by 1 (PC = PC + 1) and instruction so obtained is transferred to the IR. 4. In the IR, the unique bit patterns that make up machine language are extracted and sent to the decoder. V.1.2 The Decode Cycle The decode cycle is responsible for recognizing the operation that the bit pattern represents and activating the correct circuitry to perform that operation. The steps performed during the decode cycle are as follows: 1. The operation code (op-code) of the instruction is first read, and then interpreted in the machine language. 2. The data required by the instruction (operand) are then transferred to the data register (DR). V.1.3 The Execute Cycle Once the instruction has been decoded, the operation specified by the op-code is performed on user-provided data in ALU. The execution cycle involves following steps: 1. The data is fetched into ALU from the memory location pointed by memory address register. 2. The operation specified by the decoded op-code is performed on the data in ALU. V.2 Fixed and Variable length Instructions Instructions are translated to machine code. In some architecture all machine code instructions are the same length i.e. fixed length. In other architectures, different instructions may be translated into variable lengths in machine code. This is the situation with 8086 instructions which range from one byte to a maximum of 6 bytes in length. Such instructions are called variable length instructions and are commonly used on CISC machines. The advantage of using such instructions, is that each instruction can use exactly the amount of space it requires, so that variable length instructions reduce the amount of memory space required for a program. On the other hand, it is possible to have fixed length instructions, whereas the name suggests, each instruction has the same length. Fixed length instructions are commonly used with RISC processors such as the PowerPC and Alpha processors. Since each instruction occupies the same amount of space, every instruction must be long enough to specify a memory operand, even if the instruction does not use one. Hence, memory space is wasted by this form of instruction. VI. ADDRESSING MODES Addressing is simply how we give an instruction its operands. There are two types of addressing: non memory addressing and memory addressing.  Non memory addressing is the simplest form of addressing because it either takes predefined data or a register name. Non memory addressing is also guaranteed to be the fastest way to address operands. Memory addressing allows us to access data in memory.  Memory addressing modes can be as fast as non memory addressing modes, but only if the memory being accessed exists in a cache that is on the CPU chip. If the memory does not exist in any cache it will be directly read from or written to RAM which can take several cycles. The processor will stall the instruction in order to wait for a memory read or a memory write to be completed. There exist various addressing modes: Immediate, Direct, Indirect, Register, Register Indirect, Displacement (Indexed) VI.1 Immediate Addressing In this type of addressing, the data is part of the instruction. The operand's value is specified at compile time. This operand is usually a numeric value. e.g. ADD 5 Add 5 to contents of accumulator VI.2 Direct Addressing In direct memory addressing, the address of the data is given in the instruction. Address field contains address of operand. Effective address (EA) = address field (A) e.g. ADD A Add contents of cell A to accumulator VI.3 Indirect Addressing This addressing mode utilizes the computer's ability of Segment:Offset addressing. Indirect Addressing gives the address of the address of the data in the instruction. It is generally used for variables containing several elements like, arrays. Memory cell pointed to by address field contains the address of (pointer to) the operand EA = (A) Look in A, find address (A) and look there for operand e.g. ADD (A) Add contents of cell pointed to by contents of A to accumulator VI.4 Register Addressing The register addressing mode is used to move data to and from registers and to manipulate the data in a register. The data may be a numeric value, memory address, or general data. This addressing mode is one of the most common and is almost always used in conjunction with memory addressing modes. N.B. in C programming register int a; VI.5 Relative Addressing Relative addressing is a version of displacement addressing. Here, EA = A + (PC) i.e. get operand from A cells from current location pointed to by PC VI.6 Indexed Addressing Index addressing uses a register (implicitly or explicitly) as an offset or a displacement, which is added to the address in the operand to determine the effective address of the data. This mode is extremely useful when accessing elements of an array when the element size is 1, 2, 4, or 8 bytes big. However, if the element size is not one of the scale sizes than you have to manually adjust the index according to the element size. EA = (A) + (R) Example: These are the values loaded into the accumulator for each addressing mode. VII. INTERRUPT AND POOLING VII.1 What is an Interrupt? An interrupt is an event external to the currently executing process that causes a change in the normal flow of instruction execution; usually generated by hardware devices Hardware interrupts are used by devices to communicate that they require attention from the operating system. A software-generated interrupt caused either by an error, or by a specific request from a user program is called trap. In most computer systems, interrupts are handled as quickly as possible. When an interrupt is received, any current activity is stopped and an interrupt handler (interrupt controller) is executed. There exist two type of interrupt: maskable and non-maskable interrupts An interrupt is said to be masked when it has been disabled, or when the CPU has been instructed to ignore it. A non-maskable interrupt (NMI) cannot be ignored, and is generally used only for critical hardware errors. Fig: maskable and non maskable interupt VII.2 Polling Polling, or polled operation, refers to actively sampling the status of an external device by a client program as a synchronous activity. . Polling has the disadvantage that if there are too many devices to check, the time required to poll them can exceed the time available to service the I/O device. VIII. OTHER TYPES OF ARCHITECHTURE VIII.1 The system bus model. Bus-based computers are structured like that - processors and memory are connected to a backbone bus that acts as a "superhighway" for data or instructions to move between processors and memory. In practice, the bus architecture has the same components as the von Neumann architecture, but they are arranged along a bus, as shown in Figure 2. Fig. Schematic diagram of a system bus architecture In principle, the bus computer solves the von Neumann bottleneck problem by using a fast bus. In practice, the bus is rarely fast enough to support I/O for the common case (90 percent of practical applications), and bus throughput can be significantly reduced under large amounts of data. VIII.2 Multiprocessor or Parallel Architecture. Recall the old saying, "Many hands make less work." In computers, the use of many processors together reduces the amount of time required to perform the work of solving a given problem. Fig .Schematic diagram of multiprocessor architecture This is a simple architecture that is useful for solving selected types of compute-intensive problems. However, if you try to solve data-intensive problems on such an architecture, you encounter the von Neumann bottleneck trying to read and write the large amount of data from and to the shared memory. To help solve the problem of bus contention inherent in shared-memory multiprocessors, computer scientists developed the mixed model of parallel processing, in which the CPUs have small, very fast local memories that communicate with the CPU via a very fast, short bus. Local memory architectures are useful for problems that have data locality, where each CPU can solve part of a problem with part of the problem's data, and there is little need for data interchange between processors. Fig. Schematic diagram of multiprocessor architecture with shared memory, where each CPU also has its own fast, local memory IX. MODERN MICROPROCESSOR ARCHITECTURE IX.1 Pipelining & Instruction-Level Parallelism Consider how an instruction is executed – first it is fetched, then decoded, then executed by the appropriate functional unit, and finally the result is written into place. With this scheme, a simple processor might take 4 cycles per instruction (CPI = 4)... Figure 15 – The instruction flow of a sequential processor. Modern processors overlap these stages in a pipeline, like an assembly line. While one instruction is executing, the next instruction is being decoded, and the one after that is being fetched... Pipelining is an implementation technique where multiple instructions are overlapped in execution. Figure 16 – The instruction flow of a pipelined processor Now the processor is completing 1 instruction every cycle (CPI = 1). This is a four-fold speedup without changing the clock speed at all. The pipeline designer’s goal is to balance the length of each pipeline stage. If the stages are perfectly balanced, then the time per instruction on the pipelined machine is equal to � �𝒊𝒎𝒆 𝒑𝒆𝒓 𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏 𝒐𝒏 𝒖𝒏𝒑𝒊𝒑𝒆𝒍𝒊𝒏𝒆𝒅 𝒎𝒂𝒄𝒉𝒊𝒏𝒆 𝑵𝒖𝒎𝒃𝒆𝒓 𝒐𝒇 𝒑𝒊𝒑𝒆 𝒔𝒕𝒂𝒈𝒆𝒔 IX.1.3 Multiple Issue – Superscalar A superscalar CPU architecture implements a form of parallelism called instruction level parallelism within a single processor. It therefore allows faster CPU throughput than would otherwise be possible at a given clock rate. Figure 8 – The instruction flow of a superscalar processor. IX.3 Parallel vs. Distributed Processing With single-CPU computers, it is possible to perform parallel processing by connecting the computers in a network. However, this type of parallel processing requires very sophisticated software called distributed processing software. Note that parallel processing differs from multitasking, in which a single CPU executes several programs at once. Parallel processing is also called parallel computing. IX.4 Examples of modern processor Intel has been making class leading processors for computers for a long time now. They overcame a period where AMD reigned as king by releasing their line of Core 2 processors in 2006. Now Intel has a new line of processors called the Core I series. The i3, the i5 and the i7 are the new kids on the block. CORE i3 is a basic level processor type of the new generation launched by Intel All Core i3s are dual-core processors. They have a Clock speeds ranging from 2.93 to 3.06 GHz. They possess 3MB of cache. CORE i5-They have 2 categories. Dual core and Quad core. Let’s talk about both of them in a nutshell. – i5-Dual core has a 32 nm fabrication? 4 MB cache is present in i5. The range of their clock speeds is between 3.2 to 3.6 GHz for Dual cores. – i5–Quad Core. Quad cores clock speeds of 2.4 and 2.66 GHz. Turbo Boost technology Supported, don’t support Hyperthreading and don’t have a Integrated Graphics Processor. They have 6MB - 8MB of cache CORE i7-High end processor. They are also the fastest and the most expensive in the lot. Total 4 Cores are present as they are quad core. The range of clock speeds is 1.06 GHz to 3.20 GHz, 8MB of cache is given. The IGP [Integrated Graphics] on Core i7 processors can also reach a higher maximum clock speed of 1350 MHz NUMBER SYSTEM Contents I. DEFINITIONS .................................................................................................................................. 51 II. TYPES OF NUMBER SYSTEM .......................................................................................................... 51 III. CONVERSION BETWEEN NUMBER BASES ................................................................................. 52 IV. BINARY ARITHMETIC ................................................................................................................. 55 V. REPRESENTATION OF NEGATIVE BINARY NUMBER ...................................................................... 57 VI. BINARY CODING SCHEME ......................................................................................................... 59 EXERCISES .............................................................................................................................................. 62 I. DEFINITIONS A number system defines a set of values that is used to represent quantity. It is characterize by the base or radix. The base tells the number of symbols used in the system. Then the system of base n will use digits from 0 to n-1. E.g. Base 3 uses the digits 0, 1 and 2. Base 6 uses the digits 0, 1, 2, 3, 4 and 5. The base of a number system is indicated by a subscript (decimal number) and this will be followed by the value of the number. The following are few examples:  (7592)10 is of base 10 number system.  (214)8 is of base 8 number system.  (123)16 is of base 16 number system II. TYPES OF NUMBER SYSTEM Eventually, the number systems that are generally used by the computers are as follows: • Decimal number system • Binary number system • Octal number system • Hexadecimal number system Number System Radix Value Set of Digits Example Decimal r = 10 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 (25)10 Binary r = 2 0, 1 (11001)2 Octal r = 8 0, 1, 2, 3, 4, 5, 6, 7 (31)8 Hexadecimal r = 16 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F (19)16 Table 1. Types of Number Systems Factorisation. Let consider the number N of n digits in base b written as follow: (𝑫𝒏−1…𝑫2𝑫1𝑫0)𝒃. N can be also written 𝑵=𝑫𝒏−1𝒃𝒏−1+⋯+𝑫𝒊𝒃𝒊+⋯+𝑫2𝒃2+𝑫1𝒃1+𝑫0=∑ 𝑫𝒊𝒃𝒊 𝒏−1 0 Example. (7954)10 = 7×103+9×102+5×101 =7×1000+9×100+5×10+4 (11010)2 =1×24+1×23+0×22+1×21+0 (453)7=4×72+5×7+3 (5𝑨𝑫03)16=5×164+𝐴×163+𝐷×162+0×16+3 = 5×164+10×163+13×162+0×16+3 Decimal Binary Octal 1 0001 Hexadecimal 1 2 0010 1 2 3 0011 2 3 4 0100 3 4 5 0101 4 5 6 0110 5 6 7 0111 6 7 8 1000 7 10 9 1001 11 8 10 9 1010 12 11 A 1011 13 12 B 1100 14 13 C 1101 15 14 D 1110 16 15 E 1111 17 III. CONVERSION BETWEEN NUMBER BASES F We have discussed earlier that internally the computer uses binary numbers for data representation, whereas externally it uses decimal numbers. However, any number in one number system can be represented in any other number system. Conversion between number systems can be classified into three types: Coding, decoding and encoding. III.1. Coding Coding is the conversion from decimal base (base 10) to any non-decimal base b ( 𝑏 ≠ 10). IV.1.1 Coding of whole numbers III.1.2 Conversion of Decimal Fractions Examples: a) Determine the binary equivalent of (0.375)10. 0.375 x 2 = 0.750 0 0.75 x 2 = 1.50 1 0.5 x 2 = 1.0 1 Finally, (0.375)10 = (0.011)2 b) Determine hexadecimal conversion of (671.175)10 We have already noticed in the previous question that (671)10 = (29F)16. Now let convert (0.175)10 in base 16 0.175 x 16 = 2.8 2 0.8 x 16 = 12.8 C 0.8 x 16 = 12.8 C .... Finally, (671.175)10 = (29F.2CCC...)16 III. 2. Decoding To decode is convert from a non-decimal base b (𝑏 ≠ 10) to the decimal base (base 10). III.2.1 Conversion of whole numbers In this case, each digit of the binary number is multiplied by its weighted position, and each of the weighted values is added together to get the decimal number. Examples: a) Convert 2358 into base 10. The Process: Above each of the digits in your number, list the power of the base that the digit represents. See the example on the left. It is now a simple process of multiplication and addition to determine your base 10 number. In this example you have 5 x 80 = 5 3 x 81 = 24 2 x 82 = 128 Now simply add these values together. 5 + 24 + 128 = 157 Answer: 2358 = 15710 **Remember: any number to the zero power equals one. b) Convert 10112 to base 10. 1 x 20 = 1 1 x 21 = 2 0 x 22 = 0 1 x 23 = 8 c) Convert 1C416 to base 10. 1 + 2 + 0 + 8 = 11 Answer: 10112 = 1110 4 x 160 = 4 C x 161 = 12 x 161 = 192 1 x 162 = 256 4 + 192 + 256 = 452 Answer: 1C416 = 45210 III.2.2 Conversion of non-decimal fractions to decimal fraction Examples: a) Determine the decimal equivalent of (0.01101)2. Thus, the decimal equivalent of (0.01101)2 is (0.40625)10. b) Determine the decimal equivalent of (237.04)8. Sum of weight of all bits = 128 + 24 + 7 + 0 + 0.0625 = 159.0625 Thus, the decimal equivalent of (237.04)8 is (159.0625)10. c) Determine the decimal equivalent of (45C.8BE3)16. Sum of weight of all bits = 1024 + 80 + 12 +0.5 + .0429687 + .0034179 + .0000457= 1116.5464323 Thus, the decimal equivalent of (45C.8BE3)16 is (1116.5464323)10. III.3. Encoding Encoding is the conversion from a non-decimal base to a non-decimal base. Some special cases would be distinguished. III.3.1 Conversion of Binary to Hexadecimal Examples: a) Determine the hexadecimal equivalent of (101011110011011001)2 The hexadecimal equivalent of (101011110011011001)2 is (2BCD9)16. b) Determine the hexadecimal equivalent of (1100001.101011110011)2. The hexadecimal equivalent of (1100001.101011110011)2 is (61.AF3)16. III.3.2 Conversion of Hexadecimal to Binary Examples: a) Determine the binary equivalent of (5AF)16. Combining the four bits of the binary-coded values, we have 010110101111. Thus, the binary equivalent of (5AF)16 is (010110101111)2. b) Determine the binary equivalent of (2B.6C)16. Combining the four bits of the binary-coded values, we have 00101011.01101100. Thus, the binary equivalent of (2B.6C)16 is (00101011.01101100)2. III.3.3 Conversion of Octal to Hexadecimal Examples: a) Determine the hexadecimal equivalent of (2327)8. Combining the three-bit binary blocks, we have 010011010111. Dividing the group of binary numbers into the four-bit binary blocks and by converting these blocks into their respective hexadecimal symbols, we have: Thus, the hexadecimal equivalent of (2327)8 is (4D7)16. b) Determine the hexadecimal equivalent of (31.57)8. Combining the three-bit binary blocks, we have 011001.101111. Dividing the group of binary numbers into the four-bit binary blocks and by converting these blocks into their respective hexadecimal symbols, we have: Thus, the hexadecimal equivalent of (31.57)8 is (19.BC)16. III.3.4 Conversion of Hexadecimal to Octal Examples: a) Determine the octal equivalent of (5DE247)16. Combining all the four-bit binary blocks, we have 010111011110001001000111. Dividing the group of binary numbers into the three-bit binary blocks and by converting these blocks into their respective octal symbols, we have: Thus, the octal equivalent of (5DE247)16 is (27361107)8. b) Determine the octal equivalent of (7B.64D)16. Combining all the four-bit binary blocks, we have 01111011.011001001101. Dividing the group of binary numbers into the three-bit binary blocks and by converting these blocks into their respective octal symbols, we have: Thus, the hexadecimal equivalent of (7B.64D)16 is (173.3115)8 IV. BINARY ARITHMETIC The arithmetic operations - addition, subtraction, multiplication and division, performed on the binary numbers is called binary arithmetic IV.1 Binary addition  0 + 0 = 0  0 + 1 = 1  1 + 0 = 1  1 + 1 = 0, and carry 1 to the next more significant bit Examples, a) 00011010 + 00001100 = 00100110 1 1 carries 0 0 0 1 1 0 1 0 = (26)10 +0 0 0 0 1 1 0 0 = (12)10 0 0 1 0 0 1 1 0 = (38)10 b) 00010011 + 00111110 = 01010001 1 1 1 1 1 carries IV.2 Binary Subtraction 0 0 0 1 0 0 1 1 = (19)10 +0 0 1 1 1 1 1 0 = (62)10 0 1 0 1 0 0 0 1 = (81)10 Rules of Binary Subtraction 0 ‐ 0 = 0 0 ‐ 1 = 1, and borrow 1 from the next more significant bit 1 ‐ 0 = 1 1 ‐ 1 = 0 Examples, a) 00100101 ‐ 00010001 = 00010100 1 borrows 00100101 = (37)10 ‐ 00010001 = (17)10 00010100 = (20)10 b) 00110011 ‐ 00010110 = 00011101 11 borrows 00110011 = (51)10 ‐ 00010110 = (22)10 00011101 = (29)10 IV.3 Binary Multiplication The multiplication process for binary numbers is similar to that for decimal numbers. Partial products are formed, with each product shifted one place to the left. This is illustrated below. Rules of Binary Multiplication Example, a) 111 x 101 b) 101001 × 110 = 11110110 101001 = (41)10 × 110 = (6)10 000000 101001 101001 11110110 = (246)10 IV.4 Binary division Binary division follows a similar process to that of decimal division. Example: Divide (a) (15)10by (5)10 in binary form, and (b) (15)10 by (6)10 in binary form. V. REPRESENTATION OF NEGATIVE BINARY NUMBER Usually a given computer uses a fixed number of bits for storing integers. So we use terms such as 8 bits integer, 16-bits integers, ... Whatever the principle remains the same, the only difference is that with more bits, we can store wider range of number. In general, with n bits, one can store 2n numbers. V.1 Signed magnitude representation In the sign magnitude representation, the sign of a binary number has to be represented using 0 and 1, in the computer. An n-bit signed binary number consists of two parts – sign bit and magnitude. The left most bit, also called the Most Significant Bit (MSB) is the sign bit. The remaining n-1 bits denote the magnitude of the number. For example, 01100011 is a positive number since its sign bit is 0, and, 11001011 is a negative number since its sign bit is 1. An 8-bit signed number can represent data in the range -128 to +127 (-27 to +27-1). In general, using n bits, the range of integer we can store using two’s complement is -2n-1 to 2n-1 V.2 Complements The complement of a number is the number, which when added to the original will make it equal to a multiple of the base number system. For every base r system, there are two types of complements: rs complement and (r – 1)s complement.  For decimal r = 10, we have 9s and 10s complement.  For binary r = 2, we have 1s and 2s complement.  For octal r = 8, we have 7s and 8s complement.  For hexadecimal r = 16, we have 15s and 16s complement. There are two types of complements for the binary number system – 1’scomplement and 2’scomplement. V.2.1 The 1s Complement To form the negative of any number, first complement all the bits of that number. This result is known as the 1s complement of the original number. This requires changing every logic 1 bit in a number to logic 0, and every logic 0 bit to logic 1. For instance • 1’s complement of 110 is 001 • 1’s complement of 1011 is 0100 • 1’s complement of 1101111 is 0010000 V.2.2 The 2s Complement The 2’s complement is the convention used in most of the computers to represent negative numbers. To obtain the 2s complement of a number, there is a two-step process: 1. Take the 1s complement of the number by changing every logic 1 bit in the number to logic 0 bit, and change every logic 0 bit to logic 1 bit. 2. Add 1 to the 1s complement of the binary number. Now, we have the 2s complement of the original number. Here, we can notice that the MSB has become 1. Taking the 2s complement of the number will cause the MSB to become 1. Using n bits, the range of integer we can store using two’s complement is -2n-1 to 2n-1-1 For instance, • 2’s complement of 110 is 001 + 1 = 010 • 2’s complement of 1011 is 0100 + 1 = 0101 • 2’s complement of 1101111 is 0010000 + 1 = 0010001 V.2.3 Subtraction using 1’s and 2’s complements Here we do subtraction using addition! We use the signed 1’s complement or 2’s complement representation to represent the negative numbers. The subtraction here is just supposed to be an addition of a positive number and a negative number. Then:  (-A) – (+B) = (-A) + (-B) (+B in subtraction is changed to –B in addition)  (+A) – (+B) = (+A) + (-B) (+B in subtraction is changed to –B in addition)  (-A) – (-B) = (-A) + (+B) (-B in subtraction is changed to +B in addition)  (+A) – (-B) = (+A) + (+B) (-B in subtraction is changed to +B in addition) To carry out subtraction using complement method, follow these steps:  take the "complement" of the number we are subtracting (we will see how soon)  add it to to the number we are subtracting from  discard the extra "1" on the left If a carry out occurs, - Add it to the result in case of 1’s complement - Discard the carry out bit in case of 2’s complement Examples With 2’s complement 1. Add −8 to +3 (+3) 0000 0011 +(−8) 1111 1000 ----------------- (−5) 1111 1011 2. Add −5 to −2 (−2) 1111 1110 +(−5) 1111 1011 ----------------- (−7) 1 1111 1001 : discard carry-out With 1’s complement 3. Add −8 to +3 (+3) 0000 0011 +(−8) 1111 0111 -------------------------- (−5) 1111 1010 4. Add −5 to −2 (−2) 1111 1101 +(−5) 1111 1010 -------------------------- 1 1111 0111 +(1) V.2.4 Notion of Overflow 1: Add carry-out ---------------------------- (−7) 1111 1000 If the result of an arithmetic operation is to too large (positive or negative) to fit into the resultant bit-group, then arithmetic overflow occurs. In general, overflow occurs when adding two positive numbers produces a negative result, or when adding two negative numbers produces a positive result. Adding operands of unlike signs never produces an overflow Notice that discarding the carry out of the most significant bit during Two's Complement addition is a normal occurrence, and does not by itself indicate overflow As an example of overflow, consider adding (80 + 80 = 160)10, which produces a result of −9610 in 8 bit two's complement: 01010000 = 80 + 01010000 = 80 -------------- 10100000 = −96 (not 160 because the sign bit is 1.) (largest +ve number in 8 bits is 127) VI. BINARY CODING SCHEME The alphabetic data, numeric data, alphanumeric data, symbols, sound data and video data, all are represented as combination of bits in the computer. A code is made by combining bits of definite size. Binary Coding schemes represent the data such as alphabets, digits 0-9, and symbols in a standard code. A combination of bits represents a unique symbol in the data. The standard code enables any programmer to use the same combination of bits to represent a symbol in the data. The binary coding schemes that are most commonly used are  Binary Coded Decimal (BCD)  American Standard Code for Information Interchange (ASCII)  Extended Binary-coded Decimal Interchange Code (EBCDIC)  Unicode VI.1 Binary Coded Decimal (BCD) Binary Coded Decimal (BCD) is a method of using binary digits to represent the decimal digits 0–9. A decimal digit is represented by four binary digits. The BCD coding is the binary equivalent of the decimal digit. BCD system was developed by the IBM (International Business Machines) corporation. In this system, each digit of a number is converted into its binary equivalent rather than converting the entire decimal number to its binary form. Similarly, letters and special characters can be coded in the binary form. Let us determine the BCD value for the decimal number 5319. Since there are four digits in the decimal number, there are four bytes in the BCD number. They are: Binary code decimal digits (0–9) are represented by using four bits. The valid combinations of bits and their respective values are shown in the table below. Table. Binary-coded Decimal To represent the signs + and -, any of the remaining 4 bits patterns can be used. One convention uses 1010 for + and 1011 for -. You can see that in one byte we can have either 2 digits or a sign and one digit. Here we must use the full 4-bits representation of any digit (including the leading 0s). Thus the BCD representation of 5319 is 0101001100011001 and not 101001100011001 VI.2 Extended Binary-coded Decimal Interchange Code (EBCDIC) Once upon a time IBM invented EBCDIC. EBCDIC is an acronym for Extended Binary Coded Decimal Interchange Code. It is a single byte (8 bit) character encoding standard that is used in the IBM mainframe environment. IBM didn't invent just one version of EBCDIC either but several different incompatible versions. The computing friendly and user friendly thing would have been to use the already in existence ASCII standard.  The Extended Binary Coded Decimal Interchange Code(EBCDIC) uses 8 bits (4 bits for zone, 4 bits for digit) to represent a symbol in the data.  EBCDIC allows 28= 256 combinations of bits.  256 unique symbols are represented using EBCDIC code. It represents decimal numbers (0 9), lower case letters (a-z), uppercase letters (A-Z), Special characters, and Control characters (printable and non-printable e.g. for cursor movement, printer vertical spacing etc.).  EBCDIC codes are used, mainly, in the mainframe computers. VI.3 American Standard Code for Information Interchange (ASCII) The name ASCII is an acronym for: American Standard Code for Information Interchange. It is a character encoding standard developed several decades ago to provide a standard way for digital machines to encode characters. ASCII codes are of two types: ASCII-7 & ASCII-8.  ASCII-7is a 7-bit standard ASCII code. In ASCII-7, the first 3 bits are the zone bits and the next 4 bits are for the digits. ASCII-7 allows 27= 128 combinations. 128 unique symbols are represented using ASCII-7.  ASCII-8is an extended version of ASCII-7. It is an 8-bit code having 4 bits for zone and 4 bits for the digit. ASCII-8 allows 28= 256 combinations. ASCII-8 represents 256 unique symbols. ASCII is used widely to represent data in computers.  The ASCII-8 code represents 256 symbols. o Codes 0 to 31 represent control characters (non-printable), because they are used for actions like, Carriage return (CR), Bell (BEL) etc. o Codes 48 to 57 stand for numeric 0-9. o Codes 65 to 90 stand for uppercase letters A-Z. o Codes 97 to 122 stand for lowercase letters a-z. o Codes 128-255 are the extended ASCII codes. VI.4 Unicode Unicode is a universal character encoding standard for the representation of text which includes letters, numbers and symbols in multi-lingual environments. It uses 32 bits (232= 4164895296 combinations) to represent a symbol in the data. Unicode codes can uniquely represent any character or symbol present in any language like Chinese, Japanese, included mathematical and scientific symbols are also represented in Unicode codes. An advantage of Unicode is that it is compatible with the ASCII-8 codes. The first 256 codes in Unicode are identical to the ASCII-8 codes. VI.5 IEEE notation IEEE Floating Point Format Floating point notation is essentially the same as scientific notation, only translated to binary. There are three fields: the sign (which is the sign of the number), the exponent (some representations have used a separate exponent sign and exponent magnitude; IEEE format does not), and a significand (mantissa). 1. The Sign of Mantissa This is as simple as the name. 0 represents a positive number while 1 represents a negative number. 2. The Biased exponent The exponent field needs to represent both positive and negative exponents. A bias is added to the actual exponent in order to get the stored exponent. 3. The Normalised Mantissa The mantissa is part of a number in scientific notation or a floating-point number, consisting of its significant digits. Here we have only 2 digits, i.e. O and 1. So a normalised mantissa is one with only one 1 to the left of the decimal. Example: 85.125 85 = 1010101 0.125 = 001 85.125 = 1010101.001 =1.010101001 x 2^6 sign = 0 1. Single precision: biased exponent 127+6=133 133 = 10000101 Normalised mantisa = 010101001 we will add 0's to complete the 23 bits The IEEE 754 Single precision is: = 0 10000101 01010100100000000000000 This can be written in hexadecimal form 42AA4000 2. Double precision: biased exponent 1023+6=1029 1029 = 10000000101 Normalised mantisa = 010101001 we will add 0's to complete the 52 bits The IEEE 754 Double precision is: = 0 10000000101 0101010010000000000000000000000000000000000000000000 This can be written in hexadecimal form 4055480000000000 EXERCISES MCQ 1. Choose the correct answer from below for the result of the binary multiplication 1101 × 110. (a) 1001111, (b) 1010110, (c) 1001110, (d) 1011111. 2. Choose the correct answer from below for the result of the binary division 11011 ÷ 1001. (a) 10, (b) 101, (c) 11, 3. Which of the following is the binary product 1001 × 111? (a) 110111 (b) 111111, (c) 111011, (d) 110. (d) 111110. 4. Which of the following is the binary product 1101 × 1011? (a) 10101111, (b) 10001111, (c) 10101011, 5. Which of the following is the binary division 10101 ÷ 11? (a) 100, (b) 110, (c) 101, 6. Which of the following is the binary division 100011 ÷ 1010? (a) 10.1, (b) 11.11, Exercise 1. (c) 11.01, (d) 10111011. (d) 111. (d) 11.1. (a) Convert the binary number 1011 into decimal form. (b) Convert the binary number 1.011 into decimal form. (c) Convert the numbers 15 and 12 into binary form, add the two binary numbers together and convert the answer to decimal form to check that the sum is correct. (d) Convert the numbers 9 and 6 into binary form. Use this to find 9 − 6 in binary form. Check that the answer is correct by converting the binary answer into decimal form. Exercise 2. In each of the questions below, a product is written in decimal form. In each case, convert both numbers to binary form, multiply them in binary form and check that the solution is correct by converting the answer to decimal form. (a) 3 × 2, (b) 4 × 4, Exercise 3. (c) 5 × 10, (d) 6 × 7, (e) 9 × 6, (f) 11 × 7 In each of the questions below, a division is written in decimal form. In each case, convert both numbers to binary form, perform the division in binary form and check that the solution is correct by converting the answer to decimal form. (Click on the green letters for solutions.) (a) 6 ÷ 2, (b) 8 ÷ 2, Exercise 4. (c) 9 ÷ 3, (d) 10 ÷ 4, (e) 21 ÷ 7, (f) 18 ÷ 8. 1) Using Sign and magnitude, what range of integer can be stored using 6 bits, 8 bits, 16 bits. 2) Using 6 bits, give the sign and magnitude representation of 14, -15, 31, -17 3) Using 6 bits, give the two complement representation of: 15, -28, 31, -1 Exercise 5. 1) What is the BCD representation of (a) 215 (b) -215 (c) 2001 2) What numbers are represented by the following bit strings assume that when there is a sign, it is represented by the first 4 bits with the convention 1010 for + and 1011 for -. (a) 10101100100110111 (b) 10110011011110010100 Exercise 6. (c) 1001100000000010 (d) 1010010101011011 (a) What is the lowest possible value for an 8-bit signed magnitude binary number? (b) What is the highest possible value for a 10-bit 2's complement binary number? Exercise 7. 1) Convert each of the following decimal values to 8-bit 2's complement binary. a) 5410 b) –4910 c) –12810 d) –6610 e) –9810 2) Convert each of the following 8-bit 2's complement binary numbers to decimal. a) 100111012 b) 000101012 Exercise 8. c) 111001102 d) 011010012 1) Convert each of the following decimal values to 8-bit signed magnitude binary. a) 5410 b) –4910 c) –12710 d) –6610 e) –9810 2) Convert each of the following 8-bit signed magnitude binary numbers to decimal. a) 100111012 b) 000101012 Exercise 9. c) 111001102 Using 1’s and 2’s complements perform the following subtractions a. 100110 – 11011 c. 1101010 – 110100 b. 10011.1101 – 101.11 Exercise 10. d. 1010 - 11011 d) 011010012 Find the following differences using 2’s complement arithmetic. First convert decimal values to corresponding binary values. Next, find the two’s complement representation of the subtrahend. Add the minuend and 2’s complemented subtrahend. Check your answers. a) 12 – 6 b) 4 – 6 c) 3.125 – 6.5 d) 67.25 – 83.125 LOGIC GATES Table of Contents I. BOOLEAN ALGEBRA ................................................................................................................ 66 II. LOGIC GATES ............................................................................................................................ 68 III. COMBINATION OF LOGIC GATES ..................................................................................... 69 IV. LOGIC CIRCUITS AND BOOLEAN FUNCTIONS .............................................................. 70 V. SIMPLIFICATION OF LOGIC FUNCTIONS ............................................................................ 72 VI. EXAMPLE OF BASIC DIGITAL CIRCUIT ........................................................................................ 73 EXERCISES .............................................................................................................................................. 74 X. BOOLEAN ALGEBRA Boolean algebra is a mathematical system, developed by the English mathematician, George Boole. It is the mathematics of digital systems. Boolean algebra deals with the binary number system, the variables used in the Boolean equations have only two possible values (0 or 1). Thus, for performing the logical algebraic operations, that is, 'addition' and 'multiplication', Boolean algebra follows certain rules. II.1 Rules of Boolean algebra These rules are shown in the table below. A, B and C represent a single variable or a combination variables. Addition Rules (a) Multiplication Rules (b) 1 0 + 0 = 0 0 · 0 = 0 2 0 + 1 = 1 0 · 1 = 0 3 1 + 0 = 1 1 · 0 = 0 4 1 + 1 = 1 1 · 1 = 1 5 A + 0 = A A · 0 = 0 6 A + 1 = 1 A · 1 = A 7 A + A = A A · A = A 8 A + Ā = 1 A · Ā = 0 9 A + AB = A 10 A(A+B)=A A + Ā B = A + B 11 12 (A+B)(A+C) = A + BC AC+AC = A(B+C) These rules can be checked by the use of truth table. Some of these rules can be derived from simpler identities derived in this package. II.2 Laws of Boolean algebra The following are different laws of Boolean algebra: Law 13 Addition (a) Commutative 14 A + B = B + A Multiplication (b) AB = BA Associative 15 A + (B + C) = Distributive 16 (A + B) + C (a) A (BC) = (AB) C (b) A (B + C) = AB + AC A + (BC) = (A + B) (A + C) De Morgan's Law 17 (a) (b) ̅̅̅̅̅̅̅̅ = 𝐴.𝐵̅ � �+𝐵 𝐴𝐵 ̅̅̅̅ = 𝐴+𝐵̅ Some proofs Rule 9. A + AB = A A + AB = A( 1 + B) = A . 1 = A Page 66 Page 67 Rule 10. 𝐴 + 𝐴𝐵 = 𝐴 ̅+ 𝐵 � � + 𝐴𝐵 = (𝐴 + 𝐴𝐵) + 𝐴𝐵 = (𝐴𝐴 + 𝐴𝐵) + 𝐴𝐵 = 𝐴𝐴 +𝐴𝐵 +𝐴𝐴 +𝐴𝐵 = (𝐴 + 𝐴)(𝐴 + 𝐵) = 1.(𝐴 + 𝐵) = 𝐴 + 𝐵 Rule 11. (A + B)(A + C) = A + BC (A + B)(A + C) = AA + AC + AB + BC = A( 1 + C) + AB + BC = A. 1 + AB + BC = A(1 + B) + BC = A. 1 + BC = A + BC DEMORGAN'S THEOREMS: 𝑋𝑌 ̅̅̅̅ = 𝑋̅ + 𝑌̅ & 𝑋 + 𝑌 ̅̅̅̅̅̅̅̅̅ = 𝑋̅ 𝑌̅ XI. LOGIC GATES The term gate is used to describe the set of the basic electronic components, which when combined with each other are able to perform complex logical and arithmetic operations. As discussed earlier, everything in the digital world is based on the binary number system. Numerically, this involves only two symbols: 0 and 1. Thus, when dealing with digital logic, we can specify that: 0 = False = No. 1 = True = Yes I.1 Logic Operations and basic logic gates There exist basically three logical operations: AND, OR and NOT. Each operator I.1.1 AND Operation and AND Gate The AND gate is composed of two or more inputs and a single output, and performs logical multiplication. In the AND operation, a result of 1 occurs when all the input variables are 1. The standard symbol for the AND gate and its truth are shown below. The expression X = A.B reads as 'X equals A AND B'. A B X=A.B 0 0 0 0 1 0 1 0 0 1 1 1 I.1.2 OR Operation and OR Gate According to the OR operation, a result of 1 is obtained when any of the input variable is 1. In addition, the OR operation produces a result of 0 only when all the input variables are 0. Page 68 The OR gate is composed of two or more inputs and a single output, and performs logical addition. The + sign stands for the OR operation, and not for ordinary addition. A B X=A+B 0 0 0 1 0 1 1 0 1 I.1.3 1 1 1 NOT Operation and NOT Gate Unlike the “OR” and “AND” operations the NOT operation can be performed on a single input variable. The NOT gate performs a basic logic function called inversion or complementation. In terms of bits, the NOT operation changes '1' to '0' and vice versa. A 𝑋=𝐴 0 1 1 0 x = A′ or Ā where the prime (′) represents the NOT operation. This expression is read as: x equals the inverse of A. x equals the complement of A. XII. COMBINATION OF LOGIC GATES Using combinations of logic gates, complex operations can be performed, since in practice, there is a limit to the number of gates that can be packed into a given physical space. Some basic combination gates are: NAND gate, NOR gate, Exclusive-OR (XOR) and Exclusive NOR (XNOR) gate IV.1. NAND Gate The term 'NAND' is formed by the combination of NOT-AND and implies an AND function with an inverted output. 0 A B 𝑋=𝐴↑𝐵 (NAND) 0 0 1 1 1 I V. 2. NOR Gate 1 0 1 1 1 0 The term 'NOR' is formed by the combination of NOT-OR and implies an OR function with an inverted output. IV.3. Exclusive-OR (XOR) and Exclusive-NOR (XNOR) Gate A B 𝑋=𝐴↓𝐵 (NOR) 0 0 1 0 1 0 1 0 0 1 1 0 Page 69 These gates are usually formed from the combination of the other logic gates already discussed. However, because of their functional importance, these gates are treated as basic gates with their own unique symbols. The truth tables and the standard symbols for the XOR and XNOR gates, are listed below respectively. A B � � =𝐴⨁𝐵 (XOR) 𝑋=𝐴⨀𝐵 (XNOR) 0 0 0 0 1 1 1 1 0 0 1 1 1 0 0 1 The exclusive-OR gate and exclusive-NOR gate are denoted by the ⨁ and ⨀, respectively. In addition, these gates perform the following Boolean functions: � �⨁𝐵 =𝐴𝐵̅+𝐴𝐵 � �⨀𝐵 =𝐴𝐵+𝐴𝐵̅ IV.4. Minimisation with NAND or NOR gates When designing combinatorial circuits, efficiency is sought by minimising the number of gates in a circuit. It has been proved that all the basic logical operators can be represented using only NAND operator or NOR operator. They are then called universal gates Example (a) 𝐴= 𝐴+𝐴= 𝐴𝐴 ̅̅̅̅ = 𝐴 ↑ 𝐴 c) 𝐴 + 𝐵 = 𝐴+𝐵 d) 𝐴 + 𝐵 = 𝐴+𝐵 ̿̿̿̿̿̿̿̿ = 𝐴𝐵̅ (b) 𝐴= 𝐴+𝐴 ̅̅̅̅ + 𝐴↑ 𝐵̅ +(𝐴 ↑ 𝐴) ↑ (𝐵 ↑ 𝐵) ̿̿̿̿̿̿̿̿ = 𝐴 + 𝐵 ̅̅̅̅̅̅̅̅ + 𝐴 + 𝐵 ̅̅̅̅̅̅̅̅ = 𝐴 ↓ 𝐴 ̅̅̅̅̅̅̅̅ ̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅ = (𝐴 ↓ 𝐵) + (𝐴 ↓ 𝐵) ̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅̅ = (𝐴 ↓ 𝐵) ↓ (𝐴 ↓ 𝐵) XIII. LOGIC CIRCUITS AND BOOLEAN FUNCTIONS IV.1 Definition A Logic circuit to a number of gates joined together to produce a specific output from given inputs. For example, let’s consider the following circuit: It contains three inputs A, B and C A Boolean function is an expression formed with binary variables and logical operators (OR, AND, NOT and equal sign). For example, the Boolean function of the above logic circuit can be expressed X = f(A, B, C) = A · B + A · C. The function can be represented by a truth table as follow Inputs A B C Output A.B 0 0 0 A.C F 0 0 0 0 1 0 0 0 0 Page 70 0 0 1 0 1 1 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 1 1 0 1 1 1 1 1 1 0 1 1 1 1 IV.2 Algebraic expression of a Boolean expression In general, the unique algebraic expression for any Boolean function can be obtained from its truth table by using an: - - OR operator to combined all minterms for which the function is equal to 1. AND operator to combined all maxterms for which the function is equal to 0 A minterm, denoted as mi, where 0 ≤ i < 2n, is a product (AND) of the n variables in which each variable is complemented if the value assigned to it is 0, and uncomplemented if it is 1.  1-minterms= minterms for which the function F = 1.  0-minterms= minterms for which the function F= 0. A maxterm, denoted as Mi, where 0 ≤ i < 2n, is a sum (OR) of the n variables in which each variable is complemented if the value assigned to it is 1, and uncomplemented if it is 0. Note that each maxterm is the complement of its corresponding minterm and vice versa. Any Boolean function can be expressed as a sum (OR) of its 1-minterms (sum of products SOP) or product of 0-maxterms (product of sums POS). Example: Let us consider the function F = A·B + A·C whose truth table is given as shown below Inputs Output A B C F Minterms Maxterm 0 0 0 0 0 0 1 � �𝐵̅𝐶 � �+𝐵+𝐶 0 0 1 0 � �𝐵̅𝐶 0 0 1 1 � �𝐵𝐶 � �+𝐵+𝐶 � �+𝐵̅+𝐶 0 1 0 0 0 � �𝐵𝐶 � �𝐵̅𝐶 � �+𝐵̅+𝐶 � �+𝐵+𝐶 1 0 1 1 1 1 0 � �𝐵̅𝐶 1 � �𝐵𝐶 � �+𝐵+𝐶 � �+𝐵̅+𝐶 Page 71 1 1 1 1 ABC � �+𝐵̅+𝐶 The function F can then be expressed as the sum of minterms corresponding to the value 1 of F or as the product of maxterms corresponding to the value 0 of F. � � =∑𝑚(5,6,7) = m5 + m6+ m7 = 𝐴𝐵̅𝐶 + 𝐴𝐵𝐶+ABC � � =∏𝑀(0,1,2,3,4) = M0 + M1 + M2 + M3 + M4 = (𝐴 +𝐵 +𝐶)(𝐴+𝐵+𝐶)(𝐴+𝐵̅+𝐶)(𝐴+𝐵̅+𝐶)(𝐴+𝐵+𝐶) XIV. SIMPLIFICATION OF LOGIC FUNCTIONS A simplified Boolean expression uses the fewest gates possible to implement a given expression. V.1 Simplification using Boolean algebra Using the theorems of Boolean Algebra, the algebraic forms of functions can often be simplified, which leads to simpler (and cheaper) implementations. Example: Using Boolean algebra techniques, simplify this expression: AB + A(B + C) + B(B + C) Solution Step 1: Apply the distributive law to the second and third terms in the expression, as follows: AB + AB + AC + BB + BC Step 2: Apply rule 7b (BB = B) to the fourth term. AB + AB + AC + B + BC Step 3: Apply rule 7a (AB + AB = AB) to the first two terms. AB + AC + B + BC Step 4: Apply rule 10 (B + BC = B) to the last two terms. AB + AC + B Step 5: Apply rule 10 (AB + B = B) to the first and third terms. B+AC At this point the expression is simplified as much as possible. V.2 Simplification using Karnaugh Map A Karnaugh map provides a systematic method for simplifying Boolean expressions and, if properly used, will produce the simplest SOP or POS expression possible, known as the minimum expression. A Karnaugh map is similar to a truth table because it presents all of the possible values of input variables and the resulting output for each value. Instead of being organized into columns and rows like a truth table, the Karnaugh map is an array of cells in which each cell represents a binary value of the input variables. The number of cells in a Karnaugh map is equal to the total number of possible input variable combinations as is the number of rows in a truth table. For three variables, the number of cells is 23= 8. For four variables, the number of cells is 24= 16. Example: Page 72 (Practical example and explanation to be given) XV. EXAMPLE OF BASIC DIGITAL CIRCUIT VI.1 A half adder The half adder adds two single binary digits A and B. It has two outputs, sum (S) and carry (C). The carry signal represents an overflow into the next digit of a multi-digit addition. The The simplest half-adder design, pictured on the right, incorporates an XOR gate for S and an AND gate for C. One of the main uses for the Binary Adder is in arithmetic and counting circuits. 1-bit Adder with Carry-Out Symbol Truth Table A B SUM CARRY 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 Boolean Expression: Sum = A ⊕ B Carry = A . B 1 VI.2 Full Adder Page 73 Two half adders can be combined to make a full adder. The main difference between the Full Adder and the previous seen Half Adder is that the full-adder accepts an input carry.. Full Adder with Carry-In Symbol Truth Table< A B C-in Sum C-out 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 0 0 1 0 0 1 1 0 0 1 1 0 1 1 0 1 0 1 1 1 1 1 1 Boolean Expression: Sum = A ⊕ B ⊕ C-in VI.3 Flip-Flops "Flip-flop" is the common name given to two-state devices which offer basic memory for sequential logic operations. Flip-flops are heavily used for digital data storage and transfer and are commonly used in banks called "registers" for the storage of binary numerical data. EXERCISES Exercise 1 MCQ 1. Select the Boolean expression that is not equivalent to x · x + x · x (a) x · (x + x) (b) (x + x) · x (c) 𝑥 (d) x 2. Select the expression which is equivalent to x · y + x · y · z (a) x · y (b) x · z (c) y · z (d) x · y · z 3. Select the expression which is equivalent to (x + y) · (x + y) (a) y (b) 𝑦̅ (c) x (d) 𝑥 4. Select the expression that is not equivalent to x · (x+ y) + y (a) x · x+ y · (1 + x) (b) 0 + x · y + y (c) x · y (d) y Page 74 Page 75 Exercise 2 : Use logic gates to represent these expressions and draw up the corresponding truth tables. 1. x(𝑦̅+x) 2. a+(𝑏 ̅c) 3. b(a+(b+c)) 4. 𝐴𝐵+𝐶 ̅̅̅̅̅̅̅̅̅̅ 5. 𝐴𝐵+𝐶 6. 𝐶(𝐴𝐵+𝐴𝐵 ̅̅̅̅) Exercise 3: Write down the Boolean expression for each of the circuits below. Exercise 4: Show if these combinatorial circuits are equivalent by working out the Boolean expression and the truth table for each circuit. Exercise 5: Draw the truth table for the Boolean function defined as 𝒇(𝒂,𝒃,𝒄)=𝒂(𝒃 ̅+𝒄) Exercise 6: For the given truth table, form a Boolean function A B C f(A,B,C) 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 0 1 1 0 0 0 1 1 1 1 0 0 1 1 1 1 1 Exercise 7: A burglar alarm for a house is controlled by a switch. When the switch is on, the alarm sounds if either the front or back doors or both doors are opened. The alarm will not work if the switch is off. Design a circuit of logic gates for the alarm and draw up the corresponding truth table. Exercise 8: Find the disjunctive normal form of the Boolean function for these truth tables: Exercise 9: Design circuits for each of the following using only NAND gates and then NOR gates. 1) AB 2) A𝐵̅ 3)𝐴𝐵̅ + 𝐵̅ 4) 𝐴+B Exercise 10: Simplify the following expressions and check your answer by drawing up truth tables. (a) 𝑎𝑏𝑐 +𝑎̅𝑏𝑐 (b) 𝑎 +𝑎̅𝑏𝑐 +𝑎̅𝑏𝑐 (c) 𝑝𝑞 +(𝑝+𝑞̅)(𝑟 +𝑠) Exercise 11 (a) Establish a truth table for the Boolean function 𝑓(𝑎, 𝑏, 𝑐) = (𝑎̅ + 𝑏)(𝑐+ 𝑏) (b) Design a circuit using as few AND, OR and NOT gates as possible to model the function in (a). Page 76 Page 77 OPERATING SYSTEM Table des matières I. INTRODUCTION TO OPERATING SYSTEM .......................................................................... 78 II. SERVICES OF AN OS ............................................................................................................. 78 III. EVOLUTION OF OS ............................................................................................................... 79 IV. OPERATNG SYSTEM INTERFACES ................................................................................... 80 V. OPERATING SYSTEM CONCEPTS ...................................................................................... 80 VI. TYPES OF OPERATING SYSTEMS ...................................................................................... 82 VII. PROCESS MANAGEMENT ................................................................................................... 83 VIII. DEADLOCK ......................................................................................................................... 87 IX. MEMORY MANAGEMENT ................................................................................................... 88 X. FILE MANAGEMENT ............................................................................................................ 91 XI. DEVICE MANAGEMENT ...................................................................................................... 92 XII. SECURITY MANAGEMENT ................................................................................................. 92 XIII. EXAMPLES OF OS ............................................................................................................. 93 III. INTRODUCTION TO OPERATING SYSTEM An Operating system is a collection of programs that controls the execution of application programs and acts as an interface between the user of a computer and the computer hardware. Operating system along with hardware, application and other system software, and users constitute a computer system. It is the most important part of any computer system. At the simplest level, an operating system does two things: 1. It manages the hardware and software resources of the system. These resources include such things as the processor, memory, disk space and more 2. It acts as an interface between the user and the physical machine that is it provides a stable, consistent way for applications to deal with the hardware without having to know all the details of the hardware. IV. SERVICES OF AN OS An operating system provides services to programs and to the users of those programs. - - It provides programs an environment for the execution of programs. It provides users, services to execute the programs in a convenient manner. The common service provided by the operating system is listed below. 1. Program execution: Operating system loads a program into memory and executes the program. The program must be able to end its execution, either normally or abnormally. 2. I/O operation: I/O means any file or any specific I/O device. Program may require any I/O device while running. So operating system must provide the required I/O. 3. File system manipulation: Program needs to read a file or write a file. The operating system gives the permission to the program for operation on file. 4. Communications: Data transfer between two processes is required for some time. The both processes are on the one computer or on different computer but connected through computer network. Communication may be implemented by two methods: Shared memory and Message passing. 5. Error detection: The operating system constantly needs to be aware of possible errors in CPU, in I/O devices or in memory hardware. It should take the appropriate action to ensure correct and consistent computing. 6. Resource allocation: Operating system manages different types of resources require special allocation code, i.e. main memory, CPU cycles and file storage. 7. Protection: Protection involves ensuring that all access to system resources is controlled. Security starts with each user having to authenticate to the system, usually by means of a password. External I/O devices must be also protected from invalid access attempts. Page 78 V. EVOLUTION OF OS Historically operating systems have been tightly related to the computer architecture. Operating systems have evolved through a number of distinct phases or generations which corresponds roughly to the decades. III.1 The 1940's - First Generations: Serial Processing The earliest electronic digital computers had no operating systems. Machines of the time were so primitive that programs were often entered one bit at time on rows of mechanical switches (plug boards). Programming languages were unknown (not even assembly languages). III.2 The 1950's - Second Generation: By the early 1950's, The General Motors Research Laboratories implemented the first operating systems in early 1950's for their IBM 701. The system of the 50's generally ran one job at a time. These were called single-stream batch processing systems because programs and data were submitted in groups or batches. III.3 The 1960's - Third Generation The systems of the 1960's were also batch processing systems, but they were able to take better advantage of the computer's resources by running several jobs at once. So operating systems designers developed the concept of multiprogramming in which several jobs are in main memory at once; a processor is switched from job to job as needed to keep several jobs advancing while keeping the peripheral devices in use. Another feature present in this generation was time-sharing technique, a variant of multiprogramming technique, in which each user has an on-line (i.e., directly connected) terminal. III.4 Fourth Generation Microprocessor technology evolved to the point that it become possible to build desktop computers as powerful as the mainframes of the 1970s. Two operating systems have dominated the personal computer scene: MS-DOS, written by Microsoft, Inc. for the IBM PC and other machines using the Intel 8088 CPU and its successors, and UNIX, which is dominant on the large personal computers using the Motorola 6899 CPU family. Page 79 VI. OPERATNG SYSTEM INTERFACES Almost all operating systems have a user interface (UI). This interface can take several forms. IV.1 command-line interface(CLI) With a command line interface the user interacts with the computer by typing commands. An interaction with a computer using a command line interface usually follows these two steps : - - The user types a command e.g. "dir". The computer carries out the command and displays its results. Examples of systems which use a command line interface are: MS-DOS, BBC Micro IV.2 Menu-Driven Interface With a menu driven interface the user interacts with the computer by selecting options from a menu. A typical program will have many menus which the user can access. Menus can be either full screen or pull-down. Pull down menus are accessed by selecting the menu from a menu bar. Pop-up menus are activated by pressing a button on the mouse. IV.3 Graphical User Interface (GUI) With a Graphical User Interface (GUI) the user interacts with the computer by using a pointing device such as a mouse or trackball. The most popular form of GUI is a Windows, Icon, Menu and Pointer (WIMP) system. The important features of a WIMP system are : 1. Window : An area of the screen which is used to display a particular program or piece of work. Many windows can be displayed on the screen at the same time. 2. Icon : An informative picture / symbol displayed on the screen which the user chooses to select an action. 3. Menu : A list of options which the user can pick from. Menus can be pull-down (selected from a menu bar at the top of the screen) or pop-up (selected by pressing a mouse button). e.g. 4. Pointer : A symbol such as an arrow which is moved by a pointing device and can be used to select objects. When you use a program such as a word processor that has a WIMP interface it is often the case that the document you are creating looks exactly the same on the screen as it will when it is printed out. If this is the case then the program is described as being WYSIWYG. This stands for “What You See Is What You Get”. VII. OPERATING SYSTEM CONCEPTS V.1 OS Kernel Page 80 The lowest level of any operating system is its kernel. This is the first layer of software loaded into memory when a system boots or starts up. The kernel provides access to various common core services to all other system and application programs. These services include, but are not limited to: disk access, memory management, task scheduling, and access to other hardware devices. V.2 Operating system modes Many CPU modes can be implemented by an Operating System: But en general a CPU can be either in kernel mode or User mode.  In kernel mode, also called master mode, supervisor mode, privileged mode, supervisor state, etc, the CPU has instructions to manage memory and how it can be accessed, plus the ability to access peripheral devices like disks and network cards. The CPU can also switch itself from one running program to another. It is an unrestricted mode  In user mode, access to memory is limited to only some memory locations, and access to peripheral devices is denied. The ability to keep or relinquish the CPU is removed, and the CPU can be taken away from a program at any time. Now, all programs will be run in user mode, and this prevents them from accessing the data in other programs, as well as preventing the disk etc. V.3 System call In computing, a system call is how a program requests a service from an operating system's kernel that it does not normally have permission to run. System calls provide the interface between a process and the operating system. Application developers often do not have direct access to the system calls, but can access them through an application programming interface (API). The functions that are included in the API invoke the actual system calls. V.4 Interrupt An interrupt in an interruption in the normal execution of the program. When the CPU is interrupt, then it stops its current activities like execution of the program. And transfer the control to interrupting device to check the interrupt. The three types of interrupts are  software interrupts or trap (syscall) - invoked by software  external interrupts - invoked by external devices  exceptions - invoked by the processor when errors occur Interrupt Handling The code that is installed at the target address for interrupts is called an interrupt handler. The first thing that it has to do is save the state of the currently executing process. Then it calls a subprogram Page 81 to deal with the specific type of interrupt. When that subprogram returns, the interrupt handler restores the state of the process that was executing when the interrupt occurred. VIII. TYPES OF OPERATING SYSTEMS Following are few of the important types of operating system which are most commonly used. VI.1 Real-time operating system (RTOS) Abbreviated as RTOS, a real-time operating system or embedded operating system is a computer operating system designed to handle events as they occur. Real Time System is used at those Places in which we Requires higher and Timely Response. These Types of Systems are used in Reservation. They are also found and used in robotics, communications, and has various military and government uses. VI.2 Single-user, single task As the name implies, this operating system is designed to manage the computer so that one user can effectively do one thing at a time. The Palm OS for Palm handheld computers is a good example of a modern single-user, single-task operating system. VI.3 Single-user, multi-tasking This is the type of operating system most people use on their desktop and laptop computers today. Microsoft's Windows and Apple's MacOS platforms are both examples of operating systems that will let a single user have several programs in operation at the same time. VI.4 Multi-user A multi-user operating system allows many different users to take advantage of the computer's resources simultaneously. Unix, VMS and mainframe operating systems, such as MVS, are examples of multi-user operating systems. VI.5 Multiprocessing OS Multiprogramming OS have two or more processors for a single running process. Processing takes place in parallel and is also called parallel processing. Each processor works on different parts of the same task, or, on two or more different tasks. Linux, UNIX and Windows 7 are examples of multiprocessing OS. VI.6 Time sharing Operating System: Page 82 Multitasking or time sharing refers to term where multiple jobs are executed by the CPU simultaneously by switching between them. Switches occur so frequently that the users may interact with each program while it is running. VI.7 Distributed operating System Distributed means “data is stored and processed on multiples locations”. Distributed Operating Systems manages a collection of independent computers and make them appear to the users of the system as a single computer. Users are not aware of multiplicity of machines. Access to remote resources is similar to access to local resources. VI.8 Network operating System Network Operating System (NOS) runs on a server and and provides server the capability to manage data, users, groups, security, applications, and other networking functions. The primary purpose of the network operating system is to allow shared file and printer access among multiple computers in a network, typically a LAN, a private network or to other networks. Examples of network operating systems are Microsoft Windows Server 2003, Microsoft Windows Server 2008, UNIX, Linux, Mac OS X, Novell NetWare, and BSD. VI.9 Embedded Operating System: An embedded operating system refers to the operating system that is self-contained in the device and resident in the read-only memory (ROM). IX. PROCESS MANAGEMENT VII. 1 What is a process? A process is a name given to a program instance that has been loaded into memory and managed by the operating system. Shortly, a process is a program in execution. (Program = static file (image). Process = executing program = program + execution state) VII.2 Process States A Process in execution will have to pass through different stages : → New: The process is being created.. → Ready: The process is ready to be assigned to the processor. → Running: The Process is currently using CPU to execute its instruction is in this stage. → Waiting: The process is waiting for signal from some other process. → Terminated: The Process that finishes its execution will be terminated. Steps followed in the Process execution:  A Process when first created will be in New stage, then when it is waiting for CPU time in order to get executed will in ready stage. In Ready stage Process will be waiting for CPU time in Ready Queue (A queue where Process waits for the CPU).  Once the CPU become free and process acquires it, Process will enter into Running stage where it will execute its instructions. If during this stage any interrupt occurs then it will move back to ready stage and wait for the scheduler dispatcher. If it has I/O operation then it will move to Waiting stage where it will perform I/O operation and then move back to ready stage and waits for the scheduler dispatcher.  After the process get executed it will terminate. Page 83 The change of the state of the process from one form to another is called context change and this course of action is known as context switching. Fig: Process states VII.3 Process Scheduling In a multiprogrammed system, at any given time, several processes will be competing for the CPU time. Thus, a choice has to be made which process to allocate the CPU next. This procedure of determining the next process to be executed on the CPU is called process scheduling and the module of operating system that makes this decision is called a scheduler. VII.3.1 Preemptive and Non-preemptive Scheduling Preemptive scheduling allows a process to be interrupted in the midst of its execution, taking the CPU away and allocating it to another process. Nonpreemptive scheduling ensures that a process relinquishes control of the CPU only when it finishes with its current CPU burst. CPU-scheduling decisions may take place under the following four circumstances: 1. When a process switches from the running state to the waiting state (for example, as the result of an I/O request,…). 2. When a process switches from the running state to the ready state (for example, when an interrupt occurs). 3. When a process switches from the waiting state to the ready state (for example, at completion of I/O, on a semaphore, or for some other reason). 4. When a process terminates. For situations 1 and 4, there is no choice in terms of scheduling. A new process (if one exists in the ready queue) must be selected for execution. There is a choice, however, for situations 2 and 3. When scheduling takes place only under circumstances 1 and 4, we say that the scheduling scheme is nonpreemptive or cooperative; otherwise, it is pre-emptive. VII.3.2 Algorithm to select process to execute The scheduler uses some scheduling procedure to carry out the selection of a process for execution. The efficiency of each algorithm is judged according to the average waiting time and the average turnaround time.  Burst time: It is the amount of time a process uses the CPU for a single time.  Waiting time - amount of time a process has been waiting in the ready queue (waitingTime = startTime – arrivalTime)  Turnaround time - It’s the total time taken by the process between starting and the completion. (turnaroundTime = burstTime + waitingTime = finishTime- arrivalTime) Page 84 Page 85 1) First-Come-First-Served: As the name suggests, in FCFS scheduling, the processes are executed in the order of their arrival in the ready queue. To implement FCFS scheduling procedure, the ready queue is managed as a first-in first-out (FIFO) queue. It is a nonpreemptive scheduling. Example: Process Arrival time Burst time Service Time Wait Time : Service Time - Arrival Time P0 0 5 0 0 - 0 = 0 P1 1 3 5 5 - 1 = 4 P2 2 8 8 8 - 2 = 6 P3 3 6 16 16 - 3 = 13 Average Wait Time: (0+4+6+13) / 4 = 5.55 2) Round Robin: Here each process is provided a fix time to execute called quantum or slice time. After this time has elapsed, the process is preempted and added to the end of the ready queue and other process executes for given time period. Context switching is used to save states of preempted processes. Example: Quantum = 3 Process Arrival time Bust Time Wait Time : Service Time - Arrival Time P0 0 5 (0-0) + (12-3) = 9 P1 1 3 (3-1) = 2 P2 2 8 (6-2) + (14-9) + (19-17) = 11 P3 3 6 (9-3) + (17-12) = 11 Average Wait Time: (9+2+11+11) / 4 = 8.25 3) Shortest-Job-First Scheduling, SJF The idea behind the SJF algorithm is to pick the quickest fastest little job that needs to be done, get it out of the way first, and then pick the next smallest fastest job to do next. (Technically this algorithm picks a process based on the next shortest CPU burst, not the overall process time.). For example, the Gantt chart below is based upon the following CPU burst times, (and the assumption that all jobs arrive at the same time.) Process Arrival time Burst time Service Time Wait Time : Service Time - Arrival Time P0 0 5 0 0 - 0 = 0 P1 1 3 5 5 - 1 = 4 P2 2 8 14 14 - 2 = 12 P3 3 6 8 8 - 3 = 5 14 17 19 21 P3 Average Wait Time: (0+4+12+5) / 4 = 5.250 4) Priority Scheduling P2 Each process is assigned a priority. Process with highest priority is to be executed first and so on. Processes with same priority are executed on first come first serve basis. Priority can be decided based on memory requirements, time requirements or any other resource requirement. P0 P3 5 Wait time of each process is following P1 11 14 Process Wait Time : Service Time - Arrival Time 0 - 0 = 0 P0 11 - 1 = 10 P1 14 - 2 = 12 P2 5 - 3 = 2 P3 Average Wait Time: (0+10+12+2) / 4 = 6 5) Shortest-Remaining-Time (SRT) Scheduling Shortest remaining time, also known as shortest remaining time first (SRTF), is the preemtive counterpart of SJF and useful in time-sharing environment. The process with the smallest estimated run-time to completion is run next, including new arrivals. It picks a process and lets it run for a maximum of some fixed time. V.5 Critical Section The key to preventing trouble involving shared storage is find some way to prohibit more than one process from reading and writing the shared data simultaneously. The part of the program where the shared memory is accessed is called the Critical Section or critical regions. The most common way to avoid race conditions is to mark the critical sections of code that are accessing shared data Page 86 and ensure that only one process is ever executing code in the critical section at a given time. This property is called mutual exclusion. X. DEADLOCK VIII.1 Definition and examples of deadlock Let’s consider the situation where there are two utility programs A and B that each want to copy a file from tape to disk and print the file to printer - A holds tape and disk, then requests for a printer - - - B holds printer, then requests for tape and disk A tries to get ownership of the printer, but is told to wait for B to release it. B tries to get ownership of the tape, but is told to wait for A to release it. None of the process will be able to print and the two processes will remain in deadlock. A deadlock occurs when an every member of a set of processes is waiting for an event that can only be caused by a member of the set. Other examples of deadlocks 1) Bridge traffic can only be in one direction.  Each entrance of the bridge can be viewed as a resource.  Starvation is possible (Processes wait indefinitely). 2) In the automotive world deadlocks are called gridlocks.  The processes are the cars.  The resources are the spaces occupied by the cars VIII.2 Necessary Conditions The following four conditions (Coffman; Havender) are necessary but not sufficient for deadlock. Repeat: They are not sufficient. 1. Mutual exclusion: A resource can be assigned to at most one process at a time (no sharing). 2. Hold and wait: A processing holding a resource is permitted to request another. 3. No preemption: A process must release its resources; they cannot be taken away. 4. Circular wait: There must be a chain of processes such that each member of the chain is waiting for a resource held by the next member of the chain. VIII.3 Resource allocation graph The deadlock conditions can be modelled using a directed graph called a resource allocation graph (RAG). Below is the Resource Allocation Graph,  The processes are circles.  The resources are squares.  An arc (directed line) from a process P to a resource R signifies that process P has requested (but not yet been allocated) resource R.  An arc from a resource R to a process P indicates that process P has been allocated resource R. Page 87 If the graph does not contain a cycle, then no deadlock exists. If the graph does contain a cycle, then a deadlock might exist an example of a no deadlock situation. an example of a deadlock situation NB: The presence of a cycle in a RAG is a necessary and not a sufficient condition for the deadlock to occur. It becomes sufficient when there is only one instance of each resource. VIII.4 Methods for Handling Deadlocks Generally speaking there are three ways of handling deadlocks: 1. Deadlock prevention or avoidance - Do not allow the system to get into a deadlocked state. 2. Deadlock detection and recovery - Abort a process or preempt some resources when deadlocks are detected. 3. The Ostrich Approach: sticks your head in the sand and ignores the problem. This approach can be quite useful if you believe that they are rarest chances of deadlock occurrence. XI. MEMORY MANAGEMENT In addition to managing processes, the operating system also manages the primary memory of the computer. The part of the operating system that handles this job is called the memory manager. The major tasks accomplished by the memory manager so that all the processes function in harmony are as follows: • Allocation and Relocation: Each process must have enough memory to execute. • Protection and Sharing: A process should not run into the memory space of another process. IX.1 Relocation Page 88 When a process is to be executed, it has to be loaded from the secondary storage (like hard disk) to the main memory (RAM). This is called process loading. Since, main memory is limited and other processes also need it for their execution, an operating system swaps the two processes, which is called swapping. Once the process is 'swapped out', it is uncertain to predict when it will be 'swapped in' because of the number of processes running concurrently IX.2 Protection and Sharing In multiprogrammed systems, as a number of processes may reside in the main memory at the same time, there is a possibility that a user program during execution may access the memory location allocated either to other user processes or to the operating system. It is the responsibility of the memory manager to protect the operating system from being accessed by other processes and the processes from one another. IX.3 Memory Allocation The main challenge of efficiently managing memory comes when a system has multiple processes running at the same time. In such a case, the memory manager can allocate a portion of primary memory to each process for its own use. Different strategies are used to allocate space to processes competing for memory. Three of the most popular are: best fit, first fit and worst fit. • Best Fit: In this case, the memory manager places a process in the smallest block of unallocated memory in which it will fit. For example, a process requests 12 KB of memory and the memory manager currently has a list of unallocated blocks of 6 KB, 14 KB, 19 KB, 11 KB and 13 KB blocks. The best fit strategy will allocate 12 KB of the 13 KB block to the process. • First Fit: The memory manager places the process in the first unallocated block that is large enough to accommodate the process. Using the same example to fulfil 12 KB request, first fit will allocate 12 KB of the 14 KB block to the process. • Worst Fit: The memory manager places the process in the largest block of unallocated memory available. To furnish the 12 KB request again, worst fit will allocate 12 KB of the 19 KB block to the process, leaving a 7 KB block for future use. Fig: Strategies for Memory Allocation IX.4 Paging and segmentation 1) Paging Page 89 Paging is a memory management scheme that allows the processes to be stored non-contiguously in the memory. The memory is divided into fixed size chunks called page frames. The operating system breaks the address space of the program (the collection of addresses used by the program) into fixed size chunks called pages, which are of same size as that of page frames. Generally, page size is of 4 KB. However, some systems support even larger page sizes such as 8 KB and 4 MB. When a process is to be executed, its pages are loaded into unallocated page frames (not necessarily contiguous). The main advantage of paging is that it minimizes the problem of fragmentation since memory allocated is always in fixed units and any free frame can be allocated to a process. 2) Segmentation Segmentation is a Memory Management technique in which memory is divided into variable sized chunks which can be allocated to processes. Each chunk is called a segment. A table stores the information about all such segments and is called Global Descriptor Table (GDT). A GDT entry is called Global Descriptor. 3) Difference between paging and segmentation:- Paging and segmentation are closed relative to each other but they have following difference. → Paging divides the virtual memory in physical memory areas while the segmentation divides it logically. → Paging divides the memory in fixed length memory areas while segmentation divides into variable length memory areas. → In segmentation a full logical portion of the process in loaded, but in paging information about page is loaded. → The segments are large length as compare to page. → In segmentation memory is divided into segments through software and in paging the memory in divided through hardware. IX.5 Concept of Virtual Memory IX.5.1 What is virtual memory Virtual memory is the capability of the operating system that enables programs to address more memory locations than are actually provided in main memory. It is a method of using the computer hard drive to provide extra memory for the computer. Segments of memory are stored on the hard drive known as pages. When a segment of memory is requested that is not in memory it is moved from the virtual memory to an actual memory address. The operating system manages virtual address spaces and the assignment of real memory to virtual memory. Address translation hardware in the CPU, often referred to as a memory management unit or MMU, automatically translates virtual addresses to physical addresses. Virtual memory allows for very effective multiprogramming and relieves the user from the unnecessarily tight constraints of main memory Fig: illustration of the concept of virtual memory Page 90 IX.5.2 Page Faults A page fault is an interrupt that occurs when a software program attempts to access an invalid page in memory. A page fault occurs when a program cannot find a page that it’s looking for in the physical memory, which means that the program would have to access the paging file (which resides on the hard disk) to retrieve the desired page. XII. FILE MANAGEMENT X.1 Notion of file and file management system File can be defined as a collection of related information recorded on secondary storage (e.g., disks). Almost all information stored in a computer must be in a file. a location for storing files on your computer is called a folder or a directory. A file management system is that set of system software that provides services to users and applications in the use of files. Following objectives for a file management system:  To meet the data management needs and requirements of the user which include storage of data and the ability to perform the aforementioned operations.  To guarantee, to the extent possible, that the data in the file are valid.  To optimize performance, both from the system point of view in terms of overall throughput.  To provide I/O support for a variety of storage device types.  To minimize or eliminate the potential for lost or destroyed data.  To provide a standardized set of I/O interface routines to use processes. X.2 What is a File system? 1) Definition File system is a system for organizing directories and files, generally in terms of how it is implemented in the disk operating system. While the memory manager is responsible for the maintenance of primary memory, the file manager is responsible for the maintenance of the file system. 2) Example of file systems a) Windows file systems → FAT (File Allocation Table): FAT file system is one of the most simple types of file systems. There exist different types of FAT: FAT12, FAT16, FAT32. The number in FAT12, FAT16, FAT32 stands for the number if bits used to enumerate file system block. This means that FAT12 may use up to 4096 different block references, FAT16 - 65536 and FAT32 - 4294967296. → NTFS (New Technology File System): This is a default file system for disk partitions and the only file system that is supported for disk partitions over 32GB. → ReFS (Resilient File System):: ReFS is the latest development of Microsoft presently available for Windows 8 Servers. b) MacOS file systems Apple Mac OS operating system applies HFS+ file system, an extension to their own HFS file system that was used on old Macintosh computers. HFS+ file system is applied to Apple desktop products, including Mac computers, iPhone, iPod, as well as Apple X Server products. Advanced server Page 91 products also use Apple Xsan file system, clustered file system derived from StorNext or CentraVision file systems. c) Linux file systems Among huge amount of various file system types the most popular Linux file systems nowadays are: → Ext2, Ext3, Ext4 - 'native' Linux file system. This file system falls under active developments and improvements. Ext4 file system is frequently used as 'root' file system for most Linux installations. → ReiserFS - alternative Linux file system designed to store huge amount of small files. → XFS - file system derived from SGI company that initially used it for their IRIX servers. Now XFS specifications are implemented in Linux. → JFS - file system developed by IBM for their powerful computing systems. Currently this file system is open-source and is implemented in most modern Linux distributions. d) BSD, Solaris, Unix file systems → UFS (Unix File System) also often referred to FFS (Fast File System – fast compared to a previous file system used for Unix). → ZFS for Solaris, XIII. DEVICE MANAGEMENT Device management in an operating system refers to the process of managing various devices connected to the computer. The device manager manages the hardware resources and provides an interface to the hardware for application programs. A device communicates with the computer system by sending signals over a cable. The device communicates with the machine through a connection point called port. Broadly, managing input and output is a matter of managing queues and buffers. A buffer is a temporary storage area that takes a stream of bits from a device like keyboard to a serial communication port. Buffers hold the bits and then release them to the CPU at a convenient rate so that the CPU can act on it. Spooling: SPOOL stands for simultaneous peripheral operation on-line. Spooling refers to storing jobs in a buffer so that CPU can be efficiently utilized. Spooling is useful because devices access data at different rates. The buffer provides a waiting station where data can rest while the slower device catches up. The most common spooling application is print spooling. In print spooling, documents are loaded into a buffer, and then the printer pulls them off from the buffer at its own rate. XIV. SECURITY MANAGEMENT Security in terms of a computer system covers every aspect of its protection in case of a catastrophic event, corruption of data, loss of confidentiality and so on. Security requires ample protection not only within the system, but also from the external environment, in which the system operates. Various security techniques employed by the operating system to secure the information are user authentication and backup of data. 1) User Authentication The process of authenticating users can be based on a user's possession like a key or card, user information like the username and password or user attributes like fingerprints and signature. Among these techniques, user information is often the first and most significant line of defence in a Page 92 multiuser system. Unfortunately, passwords can often be guessed, illegally transferred or exposed. To avoid such situations, a user should keep the following points in mind: 1) Password should be at least six characters in length. 2) The system should keep track of any event about any attempt to break the password. 3) The system should allow limited number of attempts for submitting a password on a particular system. 4) Password based on dictionary words should be discouraged by the system. Alphanumeric passwords, such as PASS011, should be used. 2) Backup of Data To backup is to copy files to a second medium (a disk or tape) as a precaution in case the first medium fails. One of the cardinal rules in using computers is back up your files regularly. Operating system should provide a feature of backing up of data, for example, from a disk to another storage device such as a floppy disk or an optical disk. The purpose of keeping backups is to be able to restore individual files or complete file system in case of data loss. 3) Data encryption Encryption is the conversion of data (called plaintext) into a form (called a cyphertext) that cannot be easily understood by unauthorised user. Before being able to understand the content of the data, the receiver must be in possession of an encryption key used to decrypt the cyphertext. XV. EXAMPLES OF OS XIII.1 Commonly used OS Some of the commonly used operating systems are discussed below: 1. DOS (Disk Operating System): MS- DOS was the widely used operating system before the introduction of the Windows operating system. Even now the MS- DOS commands are used for carrying out many jobs like copying the files, deleting the files etc. The main functions of DOS are to manage files, allocate system resources according to the requirement. It provides essential features to control hardware devices such a keyboard, screen, disk drives, printers, modems etc. 2. Windows: Microsoft launched Windows 1.0 operating system in 1985 and since then Windows has ruled the world’s software market. Various versions of Windows have been launched like Windows 95, 98, Win NT, XP, 7 and the latest being Windows 8. 3. Linux: Linux is a free and open software which means it is freely available for use and its source code is also available so anybody can use it, modify it and redistribute it. It is a very popular operating system used and supported by many companies. 4. MAC OS (Macintosh operating system): It is the operating system developed by Apple for Mac computers 5. BOSS (Bharat Operating System Solutions): This is an Indian distribution of GNU/Linux. It consists of Linux operating system kernel, office application suite, Bharateeya OO, Internet browser (Firefox), multimedia applications and file sharing. 6. UNIX: It is a multitasking, multiuser operating system originally developed in 1969 at Bell Labs. It was one of the first operating systems developed in a high level language, namely C. Due to its portability, flexibility and power, UNIX is widely being used in a networked environment. Page 93 7. Solaris: It is a free Unix based operating system introduced by Sun Microsystems in 1992. It is now also known as Oracle Solaris. XIII.2 Mobile Operating Systems (Mobile OS) It is the operating system that operates on digital mobile devices like smart phones and tablets. It extends the features of a normal operating system for personal computers so as to include touch screen, Bluetooth, Wi-Fi, GPS mobile navigation, camera, music player and many more. The most commonly used mobile operating systems are Android and Symbian Android: It is a Linux derived Mobile OS released on 5th November 2007 and by 2011 it had more than 50% of the global Smartphone market share. It is Google’s open and free software that includes an operating system, middleware and some key applications for use on mobile devices. Various versions of Android OS have been released like 1.0, 1.5, 1.6, 2.x, 3.0 etc. Symbian: This Mobile OS by Nokia designed for smartphones. It offers high level of functional integration between communication and personal information management. It has an integrated mail box and it completely facilitates the usage of all Google applications in your smartphone easily. Various versions like S60 series, S80 series, S90 series, Symbian Anna etc have been released. DATABASE The term database refers to a collection of related data from which the users can efficiently retrieve the desired information. In addition to the storage and retrieval of data, certain other operations can also be performed on a database. These operations include adding, updating and deleting data. All these operations on a database are performed using a database management system (DBMS). Essentially, a DBMS is a computerized record-keeping system. In this topic we will be introduced to the basic terminology used in a database management system (such as normalisation, entities, attributes, keys, relational database management systems, structured query language). Table of Contents I. INTRODUCTION TO DATABASES ............................................................................. 96 II. DATABASE MANAGEMENT SYSTEM (DBMS).................................................... 97 III. DATABASE MODELS ................................................................................................ 98 IV. DATA BASE ABSTRACTION LEVELS ................................................................. 100 V. DATABASE USERS .................................................................................................. 101 VI. CENTRLIZED DATABASE vs DISTRIBUTED DATABASE ............................... 101 VII. ENTITY-RELATION MODEL.................................................................................. 102 VIII. RELATIONAL DATABASE ......................................................... 104_Toc406415570 IX. DATA INTEGRITY ................................................................................................... 109 Page 94 Page 95 X. DATABASE NORMALIZATION ............................................................................. 109 XI. INTRODUCTION TO QUERIES .............................................................................. 112 XVI. INTRODUCTION TO DATABASES I.1 Definition and examples A database can be summarily described as a repository for data. It is a collection of non redundant data which can be shared by different application systems. Although databases are generally computerized, instances of non-computerized (paper-based) databases from everyday life can be cited in abundance. A dictionary, a phone book, a collection of recipes and a TV guide are all common examples of non-computerized databases. The examples of computerized databases include customer files, search engines, books catalogue, equipment inventories and sales transactions. I.2 Computerized database vs non-computerized database Computerized database Can hold vast amount of data Paper-based database Very fast to find a specific record Limited by the physical space available Can take a while to manually search through all of the record Can easily search for a specific criteria e.g. “All the student who live in Ntarikon” Difficult to search for a specific criteria; every record wold have to be manually look at Data can be sorted into ascending or descending order on multiple criteria Difficult to sort data on more than one criteria The database can be kept secure by the use of password The only security will be locking up the record Can easily update or amend a record Changes have to be done manually. Record can look messy if scribbled out Easy to make a back-up in case of data lost Difficult to make a back-up because every page would have to be rewritten or photocopied I.3 Database terminologies I.3.1 Data and Information Data can be anything such as a number, a person's name, images, sounds and so on. Hence, data can be defined as a set of isolated and unrelated raw facts (represented by values), which have little or no meaning because they lack a context for evaluation (e.g. ‘Monica’, ‘36’, ‘chief’ …). When the data are processed and converted into a meaningful and useful form, it is known as information. Hence, information can be defined as a set of organized and validated collection of data. For example, 'Monica is 35 years old and she is a chef'. Strictly speaking, data refer to the values physically recorded in the database, whereas information refers to the conclusion or meaning drawn out of it. With respect to database, these terms are synonymous. I.3.2 Data validation Data validation is the process of ensuring that a program operates on clean, correct and useful data. It uses routines, often called "validation rules" "validation constraints" or "check routines", that check for correctness, meaningfulness, and security of data that are input to the system. I.3.3 Metadata Page 96 of 227 Metadata is literally "data about data." This term refers to information about data itself -- perhaps the origin, size, formatting or other characteristics of a data item. In the database field, metadata is essential to understanding and interpreting the contents of a data warehouse (central repositories of integrated data from one or more disparate sources). I.3.4 Data Dictionary A data dictionary is a collection of descriptions of the data objects or items in a data model for the benefit of programmers and others who need to refer to them. When developing programs that use the data model, a data dictionary can be consulted to understand where a data item fits in the structure, what values it may contain, and basically what the data item means in real-world terms. I.3.5 Field, record, file In the structure of a database, the smallest component under which data is entered is the field. All fields in the same database have unique names, several data fields make up a record, several records make up a file, and several files make up a database. A File is a named collection of logically related multiple records. Depending on the database software, a table can also be referred to as a table. Example: in a database maintaining information about employee, - the fields can be Code, Deptt, Name, Address, City and Phone (see Figure 1). - - fields Code, Deptt, Name, Address, City and Phone for a particular employee form a record. Figure 1 contains five records (0101–0109) and each record has six fields. a collection of all the employee records of a company form employee table. Figure 1. Fields and Records in a Table XVII. DATABASE MANAGEMENT SYSTEM (DBMS) A DBMS is a collection of programs that manages the database structure and controls access to the data stored in the database. The DBMS serves as the intermediary between the end user and the database by translating user requests into the complex computer code. The end user interacts with the DBMS through an application program. Page 97 of 227 Data Model: A data model is a representation of a real world situation about which data is to be collected and stored in a database. A data model depicts the dataflow and logical interrelationships among different data elements. Database system: Database system is a general term that refers to the combination of a database, a DBMS and a data model. A database system consists of Data (the database), Software, Hardware and Users. It allows users to Store, Update, Retrieve, Organise and Protect their data. Figure 2: a database system Some DBMS examples include MySQL, PostgreSQL, Microsoft Access, SQL Server, FileMaker, Oracle, RDBMS, dBASE, Clipper, and FoxPro. XVIII. DATABASE MODELS A data model is a collection of concepts and rules for the description of the structure of the database. Structure of the database means the data types, the constraints and the relationships for the description or storage of data respectively. Database models may be grouped into two categories: • conceptual model focuses on the logical nature of the data representation and is concerned with what is represented in the database; conceptual model include Entity-Relationship (ER) Model and Object-Oriented (OO) Model • Implementation model emphases on how information is represented in the database or on how the data structures are implemented to represent what is modelled. Implementation models include the hierarchical database model, the network database model, and the relational database model. III.1 Hierarchical Database Model The hierarchical data model organizes the data in a tree-like structure. Each child node (also known as dependents) can have only one parent node. The main advantage of the hierarchical data model is that the data access is quite Page 98 of 227 Figure 3 : The hierachical database model predictable in structure, and therefore, both retrieval and updates can be highly optimized by a DBMS. However, the main drawback of this model is that the links are 'hard coded' into the data structure, that is, the links are permanently established and cannot be modified. III.2 Network Database Model Using records and sets, this model uses a one-to many relationship approach for the data records. Multiple branches are allocated for lower-level structures and branches that are then connected by multiple nodes, which represent higher-level structures within the information. This database modelling method provides an efficient way to retrieve information and organize the data so that it can be looked at multiple ways, providing a means of increasing business performance and reaction time. This is a viable model for planning road, train, or utility networks, but it is difficult to alter the database because information entered can alter the entire database. Figure 4 : The Network database model III.3 Relational Database The relational data model represents the database as a collection of simple two-dimensional tables called relations. The rows of a relation are referred to as tupples and the columns are referred to as attributes. Fig 5: a relational database III.4 Object-oriented Database Model The object-oriented model is a relatively new data model and provides an outlook for the future database models. An object-oriented database stores and maintains objects. An object is an item that can contain both the data and the procedures that manipulate the data. For example, a student object might contain not only data about a student's name, roll number and address, but also procedures on some tasks such as printing the student record or calculating the student's tuition fees. Like the other models, the object model assumes that objects can conceptually be collected together into meaningful groups known as classes. Page 99 of 227 III.5: Object Relational Model: These models have created an entirely new type of database, which combines database design with application program to solve specific technical problems while leveraging the best of both worlds. To date, object databases still need to be refined to achieve greater standardization. Real world applications of this model often include technical or scientific fields, such as engineering and molecular biology. XIX. DATA BASE ABSTRACTION LEVELS Three – level architecture for database system is proposed to archive the characteristics of the database approach. The goal of this architecture is separate the applications and the physical database so the actual details of how data is organized are hided from the users. Fig ure 6: Th ree- lev el dat aba se Arc hit ect ure 1) E xte rna l level or view: View level part may be considered the "who" part of the picture. In this highest level, there exists a number of views which of is defined a part of the actual database. Each view is provided for a user or a group of users so that it helps in simplified the interaction between the user and system. 2) Conceptual (logical) level: At conceptual level, the emphasis lies on the "what" part of the picture. It describes the logical structure of the whole database. The entire database is described using simple logical concepts such as objects, their properties or relationships. Thus the complexity of the implementation detail of the data with be hided from the users (abstraction). Page 100 of 227 3) Internal (physical) level: Physical level emphasizes the "how" and "where" parts of the data storage. It describes where the data is actually stored, how is it stored and how to access it. XX. DATABASE USERS A database user is a principal at the database level. Every database user is a member of the public role. End user: People whose jobs require access to database for querying, updating and generating report. Application developer: Write software to allow end users to interface with the database system. This kind of user need to familiar with the DBMSs to accomplish their task. Database systems programmer: Writes the database software itself Database Administrator (DBA): A person or a group of people who is responsible for designing & managing the database system. i.e. authorizing the access to the database, monitoring its use and managing all the resource to support the use of the whole database system XXI. CENTRLIZED DATABASE vs DISTRIBUTED DATABASE VI.1 Centralized database: In a centralized database, all the data of an organization is stored in a single place such as a mainframe computer or a server. Users in remote locations access the data through the Wide Area Network (WAN) using the application programs provided to access the data. The centralized database (the mainframe or the server) should be able to satisfy all the requests coming to the system, therefore could easily become a bottleneck. But since all the data reside in a single place it easier to maintain and back up data. Furthermore, it is easier to maintain data integrity, because once data is stored in a centralized database, outdated data is no longer available in other places Figure 7 : A centralized database VI.2 Distributed database A distributed database is a database that consists of two or more files located at different sites on a computer network. Because the database is distributed, different users can access it without interfering with one another in a transparent manner. Users Page 101 of 227 Figure 8 : A distributed database access the data in a distributed database by accessing the WAN, but the user has the impression that the access of data is done on his local machine. To keep a distributed database up to date, it uses the replication and duplication processes. XXII. ENTITY-RELATION MODEL The conceptual model can be represented using Entity-Relationship model (E-R model). The E-R model views the real world as a set of basic objects (known as entities), their characteristics (known as attributes) and associations among these objects (known as relationships). VII.1 Entity, Attributes and relationship 1) An entity is any object in the system that we want to model and store information about. Entities are usually recognizable concepts, either concrete or abstract, such as person, places, things, or events which have relevance to the database. 2) An attribute is an item of information which is stored about an entity. There exist different types of entity (a) Simple and composite attributes. A simple attribute is the smallest semantic unit of data, which are atomic (no internal structure). A composite attribute can be subdivided into parts, e.g., address (street, city, state, zip). (b) Single and multivalued attributes. Single attributes have a single value for a particular entity. Multivalued attributes have multiple values of an attribute for a particular entity; e.g., degrees or courses that a student can have or take. 3) Relationship is an association, dependency or link between two or more. Example. In a business enterprise, entity may be Product, Representative and Customer. The attributes of product can be Name and Price. The attribute of representative is Name, Region and Phone. The attributes of Customer are Name, City and Age. The relationship between customer and product is represented by “Buys”, and the relationship between Representative and product is represented by “Sells” Figure 9: Entity, attribute and relationship Page 102 of 227 VII.2 Entity-Relationship diagram (ERD) An entity-relationship diagram (ERD) is a graphical representation of entities and their relationships. Region Name Representative • Rectangles represent entity types • Ellipses represent attributes • Diamonds represent relationship types Price Phone Name Sels Product Figure 10. Entities, Attributes and Relationship • Lines link attributes to entity types and entity types to relationship types • Primary key attributes are underlined VII.3 Types of Relationship Name Buys Date Customer City Age Even though a relationship may involve more than two entities, the most commonly encountered relationships are binary, involving exactly two entities. Generally, such binary relationships are of three types and called cardinality: one-to-one, one-to-many and many-to-many. a) One-to-one Relationship (1:1) One-to-one relationships occur when each entry in the first table has one, and only one, counterpart in the second table. One-to-one relationships are rarely used because it is often more efficient to simply put all of the information in a single table. eg if a man only marries one woman and a woman only marries one man, it is a one-to-one (1:1) relationship. Fig 5 : One-to-One b) One-to-many Relationship (1:M) One-to-many relationships are the most common type of database relationship. They occur when each record in the first table corresponds to one or more records in the second table but each record in the second table corresponds to only one record in the first table. For example, the relationship between a Teachers table and a Students table in an elementary school Page 103 of 227 database would likely be a one-to-many relationship, because each student has only one teacher, but each teacher may have multiple students. Fig 6: One-to-Many The crowbar represents the Many occurrence. c) Many-to-many Relationship (M:M) Many-to-many relationships occur when each record in the first table corresponds to one or more records in the second table and each record in the second table corresponds to one or more records in the first table. For example, One teacher teaches many students and a student is taught by many teachers. Fig 7 Many-to-Many relationship XXIII. RELATIONAL DATABASE The relational database model is used in most of today's commercial databases. It is used since the early 80ies and was developed 1970 by E. F. Codd. The relational database model is based on a mathematical concept where relations are interpreted as tables. VIII.1 Concept of the relational model In contrast to the entity-relationship-model (ERM) which is a conceptual data model, the relational model is a logical data model. The relational model is not about abstract objects but defines how data should be represented in a specific database management system. The goal of a logical data model is to arrange the data in such a form that it is consistent, non-redundant and supports operations for data manipulation. The main organization unit in a relational data model is the relation. A relation can be represented as a table but the definition of the relation is not necessarily equal to the definition of the table and vice versa. VIII.2 Relational model terminologies The terminologies used in relational model are quite different from the one used in ERM. The table below shows some terms used in relational model ER Model Relational Model Database Entity Relation Traditional Programmer Table File Page 104 of 227 Entity Instance Tuple Row Attribute Attribute Record Column Identifier Key Key Field VIII.3 Database Keys Key (or link) Keys are, as their name suggests, a key part of a relational database and a vital part of the structure of a table. They ensure each record within a table can be uniquely identified by one or a combination of fields within the table. They help enforce integrity and help identify the relationship between tables. There are three main types of keys, candidate keys, primary keys and foreign keys. There is also an alternative key or secondary key that can be used, as the name suggests, as a secondary or alternative key to the primary key d) Super Key A Super key is any combination of fields within a table that uniquely identifies each record within that table. e) Candidate key In a table, there can be more than one field that can uniquely identify each record. All such fields are known as candidate keys. One of these candidate keys is chosen as a primary key; the other keys that are not chosen as primary key are known as alternate keys or secondary keys. f) Primary Key: A field or a set of fields that uniquely identify each record in a table is known as a primary key. This implies that no two records in the relation can have same value for the primary key. For example, an employee number uniquely identifies a member of staff within a company. An IP address uniquely addresses a PC on the internet. A primary key is mandatory. That is, each entity occurrence must have a value for its primary key. g) Foreign Key: A field of a table that references the primary key of another table is referred to as foreign key. Figure 13.3 illustrates how a foreign key constraint is related to a primary key constraint. Here, the field Item_Code in the PURCHASE table references the field Item_Code in the ITEM relation. Thus, the attribute Item_Code in the PURCHASE relation is the foreign key. Page 105 of 227 Figure 8. Foreign Key h) Simple Key Any of the keys described before (ie: primary, secondary or foreign) may have one or more attributes. A simple key consists of a single attribute to uniquely identify an entity occurrence. i) Compound Key A compound key consists of more than one attribute to uniquely identify an entity occurrence. Each attribute, which makes up the key, is also a simple key in its own right. For example, we have an entity named enrolment, which holds the courses on which a student is enrolled. In this scenario a student is allowed to enrol on more than one course. This has a compound key of both student number and course number, which is required to uniquely identify a student on a particular course. Fig 9: a compound key Student number and course number combined is a compound primary key for the enrolment entity. j) Composite Key A composite key consists of more than one attribute to uniquely identify an entity occurrence. This differs from a compound key in that one or more of the attributes, which make up the key, are not simple keys in their own right. For example, you have a database holding your CD collection. One of the entities is called tracks, which holds details of the tracks on a CD. This has a composite key of CD name, track number. Page 106 of 227 Fig 10: a composite key CD name in the track entity is a simple key, linking to the CD entity, but track number is not a simple key in its own right. Application exercise For each of the following entities, list possible primary keys. Then, suggest secondary keys, if any: Student, Course, Unit, Result, Classroom, Lecturer, Department, and Attendance VIII.3 Transforming an ERM to a relational model scheme VIII.3.1 Entity to Relation Conversion  General steps: - Entities – In general, each entity will be converted directly to a relation. - - - The attributes of the entity become the attributes of the Relation. The Identifier of the Entity becomes a Key of the Relation. Relationships will be mapped as “Foreign Keys”. There are a number of variations to this step that will be described in more details below. – One to Many (1:M) To represent a 1:M relationship, take the primary key of the parent table (on the “1” side) and insert it as a foreign key into the child table (on the “M” side). It may make sense to rename the foreign key to reflect its relationship to the table you are inserting it into. V III.3. 2 Repr esent ing Rela tions hips Page 107 of 227 VIII.3.3 Representing Relationships – Many to Many There is no direct representation of a M:N relationship in the relational model. You will need to turn each M:N relationship between two entities into a separate relation (table) of its own. This relation will usually have as its own primary key the combination of two foreign keys – each of these will be the primary key of one of the relations involved in this relationship. VIII.3.4 Representing Relationships – One to One The key or one relation is stored in the second relation. NB: If a relatio nship has attribu tes then they need to go into a table. Where to put them depends on the type of the relationship. In a 1:1 or 1:M Page 108 of 227 relationship, put them the same place the foreign key goes (on the M side in 1:M). In a M:N relationship, put them in the new table you create for the relationship. XXIV. DATA INTEGRITY Data integrity refers to the accuracy and consistency of stored data, indicated by an absence of any alteration in data between two updates of a data record. The concept of data integrity ensures that all data in a database can be traced and connected to other data. This ensures that everything is recoverable and searchable. Having a single, well-defined and well-controlled data integrity system increases stability, performance, reusability and maintainability. The following three integrity constraints are used in a relational database structure to achieve data integrity:  Entity Integrity: The rule states that every table must have its own primary key and that each has to be unique and not null.  Referential Integrity: This is the concept of foreign keys. The rule states that the foreign key value can be in two states. The first state is that the foreign key value would refer to a primary key value of another table, or it can be null.  Domain Integrity: This states that all columns in a relational database are in a defined domain. XXV. DATABASE NORMALIZATION Normalization is a process in which data attributes within a data model are organized to increase the cohesion of entity types. In other words, the goal of data normalization is to reduce and even eliminate data redundancy, an important consideration for application developers. There are two goals of the normalization process: • eliminating redundant data (for example, storing the same data in more than one table ) and • ensuring data dependencies make sense (only storing related data in a table). Both of these are worthy goals as they reduce the amount of space a database consumes and ensure that data is logically stored. X.1 Dependencies In order to be able to normalise a relation, we must first understand the concept of dependency between attributes within a relation. There exist various types of dependencies: 1) Functional dependency: If A and B are attributes of relation R, B is functionally dependent on A (denoted A --> B), if each value of A in R is associated with exactly one value of B in R. 2) Full functional dependency: We talk about full functional dependency if attribute B is functional dependent on A, if A is a composite primary key and B is not already functional dependent on parts of A. 3) Transitive dependency: If A determines B and B determines C then C is determined by (dependent on) A. We write A --> B and B --> C then A --> C. Page 109 of 227 Examples. Let’s consider the following relation X.2 The Normal Forms The database community has developed a series of guidelines for ensuring that databases are normalized. These are referred to as normal forms and are numbered from one (the lowest form of normalization, referred to as first normal form or 1NF) through five (fifth normal form or 5NF). In practical applications, you'll often see 1NF , 2NF , and 3NF along with the occasional 4NF. Fifth normal form is very rarely seen and won't be discussed in this article. X.2.1 First normal form (1NF) A table is in first normal form (1NF) if a relation cannot have repeating fields or groups (no field must have more than one value): To do it, we have to: a) Eliminate duplicative columns from the same table. b) Create separate tables for each group of related data and identify each row with a unique column or set of columns (the primary key). Example Let’s consider the following relation: Students(Surname, LastName, Knowledge) The attribute Knowledge can contain multiple values and therefore the relation is not in the first normal form. To get to the first normal form (1NF) we must create a separate tuple for each value of the multivalued attribute X.2.2 Second normal form (2NF) A table is 2NF when it is in 1NF and when all of its non-key attributes are fully dependent on its primary key (no partial dependency). That is, if X → A holds, then there should not be any proper subset Y of X, for that Y → A also holds. To do it, we should: a) Remove subsets of data that apply to multiple rows of a table and place them in separate tables. Page 110 of 227 b) Create relationships between these new tables and their predecessors through the use of foreign keys. Example : Let’s consider the following relation: We see here in Student_Project relation that the primiry key attributes are Stu_ID and Proj_ID. According to the rule, non-key attributes, i.e. Stu_Name and Proj_Name must be dependent upon both and not on any of the prime key attribute individually. But we find that Stu_Name can be identified by Stu_ID and Proj_Name can be identified by Proj_ID independently. This is called partial dependency, which is not allowed in Second Normal Form. So to put the table into 2NF, We broke the relation in two as depicted in the above picture. So there exists no partial dependency. X.2.3 Third normal form (3NF) A table is in third normal form (3NF) if it is in 2NF and there is no transitive dependency, that is, an attribute depends on one or more other non-key attributes. Third normal form (3NF) goes one large step further:  Meet all the requirements of the second normal form.  Remove columns that are not dependent upon the primary key. Example: Let’s consider the following student_detail relation We find that in above depicted Student_detail relation, Stu_ID is key and the only primary key attribute. We find that City can be identified by Stu_ID as well as Zip itself. Additionally, Stu_ID → Zip → City, so there exists transitive dependency. We broke the relation as above depicted two relations to bring it into 3NF X.2.4 Boyce-Codd Normal Form BCNF is an extension of Third Normal Form in strict way. it referred to as the "third and half (3.5) normal form", since it adds one more requirement:  Meet all the requirements of the third normal form.  Every determinant must be a candidate key. X.2.5 Fourth normal form (4NF) Finally, fourth normal form (4NF) has one additional requirement:  Meet all the requirements of the third normal form. Page 111 of 227  A relation is in 4NF if it has no multi-valued dependencies. Multivalued dependencies occur when the presence of one or more rows in a table implies the presence of one or more other rows in that same table. In practice we rarely need to apply the 4NF to a database. XXVI. INTRODUCTION TO QUERIES A database query is used to extract data from the database in a readable format according to the user's request. For instance, if you have an employee table, you might issue a SQL statement that returns the employee who is paid the most. This request to the database for usable employee information is a typical query that can be performed in a relational database. The most known and most used query language is SQL (Structured Query Language). XI.1 Introduction to SQL SQL (Structured Query Language) is a database query language developed by IBM in the 1970s as a way of getting information into and out of relational DBMSs. A fundamental difference between SQL and standard programming languages is that SQL is declarative, that is, the user has to specify what kind of data are required from the database and the RDBMS is responsible for figuring out the way to retrieve it. XI.2 Basic operations in a RDB In a relational database, three basic operations are used to develop useful sets of data: selection, projection and join.  The selection (𝝈) operation retrieves certain records from a relation based on the user specified criteria.  The projection (𝚷) operation extracts fields from a relation, permitting the user to create new relations that contain only the required information.  The join operation combines the data from the two relations based on a common column, providing the user with more information than is available in individual relations. Together, these three operations are part of relational algebra. XI.3 SQL Data Types When the table is defined every field in it is assigned a data type. The type of a data value both defines and constrains the kinds of operations, which may be performed on it. Some of the most commonly used SQL data types are as follows: • CHAR(size): It defines a fixed size-length character string (can contain letters, numbers and special characters), where size can be a maximum of 255. • VARCHAR(size): It defines a variable length character string (can contain letters, numbers and special characters) of up to size characters. • NUMBER(size): It defines an integer-type data with maximum number of digits up to size specified in parenthesis. • DATE: It is used to store date. By default, the format is YYYY-MM-DD. Page 112 of 227 • NUMBER(size, decimal): It holds numbers with fractions. The maximum numbers of digits are specified in size. The maximum number of digits to the right of the decimal is specified in decimal. XI.4 SQL Basic Commands SQL commands can be divided into two main sublanguages: DDL and DML • Data Definition Language: DDL is used to create and delete database and its objects. These commands are primarily used by the DBA during the building and removal phases of a database project. The most important DDL statements in SQL are as follows: - CREATE TABLE: To create a new table. - - ALTER TABLE: To modify the structure of a table. DROP TABLE: To delete a table. • Data Manipulation Language: DML is used to retrieve, insert, modify and delete database information. These commands will be used by all database users during the routine operation of the database. The most important DML statements in SQL are the following: - INSERT: To insert data into a table. - - - UPDATE: To update data in a table. DELETE: To delete data from a table. SELECT: To retrieve data from a table. NOTE: All SQL queries must be terminated by a semicolon (;) even if the statement extends over many lines. XI.4.1 CREATE TABLE Command The CREATE TABLE command is used to define the structure of the table. Syntax: Example: CREATE TABLE ( , < field2> , ... ... ... ... ... < fieldN> ); CREATE TABLE EMPLOYEE( Code NUMBER(5), Deptt CHAR(10), Name CHAR(20), Address CHAR(100), Telephone CHAR(8) Salary NUMBER(8,2)); • The table and column names must start with a letter followed by letters, numbers or underscores. • Avoid using SQL keywords as names for tables or columns (such as SELECT, CREATE, and INSERT). • For each column, a name and a data type must be specified and the column name must be unique within the table definition. • Each column definition should be separated with a comma. XI.4.2 ALTER TABLE Command The ALTER TABLE command allows a user to change the structure of an existing table. Page 113 of 227 • New columns can be added with the ADD clause. • Existing columns can be modified with the MODIFY clause. • Columns can be removed from a table by using the DROP clause. Syntax: ALTER TABLE ; Examples: Explanation 1 ALTER TABLE EMPLOYEE ADD Email CHAR(25); command will add a new column, named Email, having a maximum width of 25 characters in the EMPLOYEE table. 2 ALTER TABLE EMPLOYEE MODIFY Name CHAR(25); command will change the maximum width of the Name column to 25 characters in the EMPLOYEE table. 3 ALTER TABLE EMPLOYEE DROP Deptt; command will delete the Deptt column from the EMPLOYEE table. XI.4.3 DROP TABLE Command The DROP TABLE command removes the table definition (with all records). • Columns can be removed from a table by using the DROP clause. Syntax: DROP TABLE ; Examples: DROP TABLE EMPLOYEE; The above SQL command will delete the EMPLOYEE table. XI.4.4 INSERT Command The INSERT command is used to insert or add rows (records) into the specified table. Syntax: INSERT INTO ( column1, column2, ..., columnN) VALUES (value1, value2, ..., valueN); Examples Explanation 1 INSERT INTO EMPLOYEE ( Code, Deptt, Name, Address, Salary) VALUES (101, 'RD01', 'Prince', 'Park Way', 15000); example 1 will add a new record at the bottom of the EMPLOYEE table consisting of the values in parenthesis. 2 INSERT INTO EMPLOYEE VALUES (102, 'RD01', 'Pankaj', 'Pitampura', 26062700, 8000); Note that for each of the listed columns, a matching value must be specified. In case no column list is specified, then a value must be given for each column and in the same order as specified in the CREATE TABLE command. XI.4.5 UPDATE Command The UPDATE command is used for modifying attribute values of records in a table. Syntax: Page 114 of 227 UPDATE SET column1 = value1 [, column2 = value2] ... ... ... ... ... [, columnN = valueN] [WHERE ]; Note that components specified inside the square brackets [] are optional. Examples Explanation 1 UPDATE EMPLOYEE SET Salary = Salary + 1000; example 1 command will update (in our case, increments) the Salary field with 1000 for all the records. 2 UPDATE EMPLOYEE SET Salary = Salary + 1000 WHERE Deptt = 'RD01'; Example 2 command will increment the Salary column with 1000 for only those rows that comply with condition specified in WHERE clause (Deptt = 'RD01'). XI.4.6 DELETE Command The DELETE command is used to delete all or selected records from the specified table. Syntax: Example: DELETE FROM [WHERE ]; DELETE FROM EMPLOYEE WHERE Salary > 8000; NOTE: If WHERE condition is not used in the DELETE command, then all the records from the specified table will be deleted. XI.4.7 SELECT command The SELECT statement is used to query the database and retrieve selected data. Syntax: SELECT FROM [WHERE ] [GROUP BY ] [HAVING ] [ORDER BY ]; To select all the columns of a table, use * instead of column list with SELECT. Examples Explanation 1 SELECT Code, Name, Salary FROM EMPLOYEE; The SELECT statement selects the values of the three specified columns from the EMPLOYEE table. This operation is called projection. 2 SELECT * FROM EMPLOYEE WHERE Salary > 7500; The SELECT statement selects all those columns from EMPLOYEE table in which the Salary column contains a value greater than 7500. This operation is called selection. SELECT * FROM EMPLOYEE WHERE Salary > 7500 the SELECT statement displays the result in a descending order by the attribute Name. Page 115 of 227 ORDER BY Name DESC; The ORDER BY clause specifies a sorting order in which the result tuples of a query are to be displayed; DESC specifies a descending order. By default, ORDER BY arranges the result set in ascending order (whether one uses ASC or not). XI.5 SQL Joins The SQL Joins clause is used to combine records from two or more tables in a database. A JOIN is a means for combining fields from two tables by using values common to each. Consider the following two tables, (a) CUSTOMERS table is as follows: (a) CUSTOMERS (b) ORDERS ID Name Age Address Salary 1 Ramesh 32 Ahmedabad 2000 2 Khilan 25 Dehli 1500 Oid Date Cust_id Amount 102 2009-10-08 3 3000 100 2009-10-08 3 3 kaushik 23 Chaitali 2000 1500 101 2009-11-20 2 4 Chaitali 25 Mumbai 6500 1560 103 2008-05-20 4 5 Hardik 27 Bhopal 6 Komal 22 MP 8500 4500 7 Muffy 24 Indore 10000 Now, let us join these two tables in our SELECT statement as follows: Query 2060 This would produce the following result: ID Name SELECT ID, Name, Age, Amount FROM CUSTOMERS, ORDERS WHERE Age 3 kaushik Amount 23 CUSTOMERS.ID = 3 kaushik 3000 23 ORDERS.CUST_ID; 1500 2 Khilan 25 4 Chaitali 1560 25 2060 Here, it is noticeable that the join is performed in the WHERE clause. Several operators can be used to join tables, such as =, <, >, <>, <=, >=, !=, BETWEEN, LIKE, and NOT; they can all be used to join tables. However, the most common operator is the equal symbol. QUERRY APPLICATION 1) The table E (for EMPLOYEE) Query Solution nr name salary 1 John 100 5 Sarah 300 7 Tom 100 Query Solution select salary from E salary 100 select nr, salary from E nr salary 1 100 Page 116 of 227 Page 117 of 227 300 5 300 7 100 select * from E where salary < 200 nr name salary 1 John 100 7 Tom 100 select * from E where salary < 200 and nr >= 7 nr name salary 7 Tom 100 select name, salary from E where salary < 200 name salary John 100 Tom 100 2) Cartesian product: The table E (for EMPLOYEE) The table D (for DEPARTMENT) enr ename dept 1 Bill A 2 Sarah C 3 John A dnr dname A Marketing B Sales C Legal Query Solution Query Solution select * from E, D enr ename dept dnr dname 1 Bill A A Marketing 1 Bill A B Sales 1 Bill A C Legal 2 Sarah C A Marketing 2 Sarah C B Sales 2 Sarah C C Legal 3 John A A Marketing 3 John A B Sales 3 John A C Legal select * from E, D where dept = dnr enr ename dept dnr dname 1 Bill A A Marketing 2 Sarah C C Legal 3 John A A Marketing 3) Natural join The table E (for EMPLOYEE) The table D (for DEPARTMENT) nr name dept 1 Bill A 2 Sarah C 3 John A nr name A Marketing B Sales C Legal Query Solution select * from E as E(enr, ename, dept), D as D(dnr, dname) enr ename dept dnr dname 1 Bill A A Marketing where dept = dnr 2 Sarah C C Legal 3 John A A Marketing select * from E, D where dept = D.nr nr name dept nr name 1 Bill A A Marketing 2 Sarah C C Legal 3 John A A Marketing Page 118 of 227 DATA COMMUNICATION AND COMPUTER NETWORK Contents I. BASIC NETWORKING CONCEPTS ................................................................................................. 1 II. CLASSIFICATION OF COMPUTER NETWORK ............................................................................ 2 III. NETWORK TOPOLOGIES ............................................................................................................. 4 IV. COMMUNICATION OVER NETWORK ....................................................................................... 8 V. TRANSMISSION MEDIA ................................................................................................................. 10 VI. COMMUNICATION PROTOCOLS ............................................................................................. 13 VII. LAN TECHNOLOGIES ................................................................................................................. 15 VIII. NETWORK ADRESSING ............................................................................................................. 17 IX. NETWORK SECURITY ................................................................................................................ 18 Page 119 of 227 I. BASIC NETWORKING CONCEPTS I.1- Definition and Network Basics Networking is the concept of sharing resources and services. A network is a set of interconnected objects (roads, computers, …) with something to share. A computer network is therefore a group of interconnected computer systems sharing resources and interacting using a shared communications link. All networks must have the following: - - - A resource to share (resource) A pathway to transfer data (transmission medium) A set of rules governing how to communicate (protocols) I.2- BENEFITS OF COMPUTER NETWORK Specifically, networks are about sharing three things: information, resources, and applications.  Sharing information: networks allow users to communicate with each other in various ways: email, chat, forums, etc.  Sharing resources: Certain computer resources, such as printers or hard drives, can be set up so that network users can share them. Sharing hard drives involves also sharing of files and folders. A network can be used to share an Internet connection.  Sharing applications: several users can work together on a single business application. Apart from sharing, other benefits of a computer network are:  Flexible Access: Networks allow their users to access files from computers throughout the network.  Reducing of cost: Instead of buying a printer for each computer of a big network, a single printer can be shared, and then cost is considerably reduced I.3- DOWNSIDES (SHORTCOMMINGS) OF NETWORKING Although networks are one of the best things that ever happened to computers, not everything about networks is rosy. The following sections describe some disadvantages of using a network:  Viruses: If a virus is introduced to the network, either intentionally or unintentionally, it will rapidly spread around all of the workstations and could start to cause havoc to peoples' files or to the efficient working of the network.  Network failure: If the file server fails then no-one on the network can access any files or folders. This means that nobody can do any work. For an organization, this would be extremely costly and disruptive.  Slow service: As more users log onto the network and request files, send things to be printed and open more software applications, the network can start to slow down.  Cost: Building a network isn't cheap. I.4- Networking hardware Networking hardware includes all computers, peripherals, interface cards and other equipment needed to perform data-processing and communications within the network. Some examples of networking hardware are: File Servers, Workstations, Network Interface Cards, Hubs, Switches, Repeaters, Bridges, and Routers: 1  Workstations: Each user computers connected to a network is called workstations. A typical workstation is a computer that is configured with a network interface card, networking software, and the appropriate cables.  Network Interface Cards(NIC): It is an internal device that provides the physical connection between the network and the computer workstation.  Hub: In general, a hub refers to a hardware device that enables multiple devices or connections to be connected to a computer. It is the most basic networking device that connects multiple computers or other network devices together.  Switch: It is a hardware device that filters and forwards packets through the network, but often not capable of much more. Switches (or concentrators) work the same way as hubs, but they can identify the intended destination of the information that they receive, so they send that information to only the computers that are supposed to receive it.  Repeaters: Since a signal loses strength as it passes along a cable, it is often necessary to boost the signal with a device called a repeater. The repeater electrically amplifies the signal it receives and rebroadcasts it.  Bridges: A bridge is a device that allows you to segment a large network into two smaller, more efficient networks. The bridge manages the traffic to maintain optimum performance on both sides of the network. Bridges must be used between networks with the same protocol.  Routers: A router is a device that forwards data packets between computer networks, creating an overlay internetwork. A router has a lot more capabilities than other network devices such as a hub or a switch that are only able to perform basic network functions.  Gateway: A gateway is a network point that acts as an entrance to another network. When a computer server serves as a Gateway node, the gateway node also operates as a firewall and a proxy server.  Firewall: A software utility or hardware device that limits outside network access to a computer or local network by blocking or restricting ports. Firewalls are a great step for helping prevent un authorized access to a company or home network.  Modem: The Modem is a hardware device that enables a computer to send and receive information over telephone lines by converting the digital data used by your computer into an analog signal used on phone lines (modulation) and then converting it back once received on the other end (demodulation).  Proxy: A proxy is a computer server or software program that is part of the gateway server or another computer that separates a local network from outside networks. A proxy server will cache all pages accessed through the network allowing users who may wish to visit that same page to load it faster and reduce the networks bandwidth. II. CLASSIFICATION OF COMPUTER NETWORK Computer networks can be classify in different ways: according to the geographical area covered, the strategy used or type of connection II.1 ACCORDING TO THE TYPE OF CONNECTION According to the type of connection, there exist two types of connections. Wired connection and wireless connection II.1.1 Wired connection 2 A wired network is when you physically connect your computer or other compatible device to your Super Hub with an Ethernet cable. The best thing about a wired connection is the reliability and speed it gives you (wired is faster than wireless). This makes it ideal for things that use a lot of bandwidth, like playing online games on your Xbox. II.1.2 Wireless connection A wireless network, as its name would suggest, is a network of computers and computer peripherals that are connected to each other without wires. Advantages  It is easier to add or move workstations.  It is easier to provide connectivity in areas where it is difficult to lay cable.  Installation is fast and easy, and it can eliminate the need to pull cable through walls and ceilings.  Access to the network can be from anywhere within range of an access point. Disadvantages  As the number of computers using the network increases, the data transfer rate to each computer will decrease accordingly.  As standards change, it may be necessary to replace wireless cards and/or access points.  Security is more difficult to guarantee and requires configuration.  Devices will only operate at a limited distance from an access point. II.2 ACCORDING TO THE GEOGRAPHICAL AREA COVERED According to the geographical area covered, there exist three main types of network: LAN, MAN and WAN II.2.1 Local Area Network (LAN) A LAN is a computer network that spans only a small geographical area such as an office, home building or closed buildings. A LAN is useful to share resources like files, printers, games and other application. The infrastructure in a LAN is private. The distance between computers in a LAN cannot be more than 15 Km. Ex: A school network II.2.2 Metropolitan Area Network (MAN) A MAN is a network of computers spread over a city or closed cities. It may be a single network such as a cable television network, or it may be many LANS connected together. A MAN may be operated by one organization (with several offices in one city) or be shared and used by several organizations in the same city. It can be either a private network or a public network. Ex: A network of all the agencies of CAMCCUL in Bamenda II.2.3 Wide Area Network (WAN) A WAN is a system of interconnecting many computer over a large geographical area such as states, countries or even the whole world. These kind of networks use telephone lines, satellite link and other long-range communication technologies to connect. Such networks are design to serve an area of hundreds kilometres such as national telephone network. For instance a company like Express Union with agencies at Fundong, Bamenda, Douala, Bafoussam, Yaoundé use a WAN to connect all its agencies. Although a WAN may be owned or rented by private business, it is usually a public network, designed to connect LANs or MANs together. The most known and the largest WAN is Internet. II.3 ACCORDING TO THE STRATEGY USED 3 According to the strategy used there exist two main types of network: Client/Server network and Peer to Peer (P2P) network: II.3.1 Client/server networks Computers that perform a service on behalf of other network devices are called servers. There are several types of servers. For example, a computer that provides other network nodes with access to network storage devices is called a file server. Print servers provide other network nodes with access to network printers. Computers that use the services of a server are called clients. Networks in which servers control access to network storage and other network resources are called client/server networks. In a Client/server network, the role of the server is to provide services demanded by client computers II.3.2 Peer-to-peer networks Computers that perform similar functions on a network are called peers. Networks in which no single, centralized computer controls network functions are called peer-to-peer networks. The idea of peer-to peer networking is that each computer on the network can be both a server and a client. Since any computer on the network can share a resource for other to use. Users can configure their computers so that they can share directories or printers with other users on the network. All computers are considered to have equal, or peer, status. II.3.3 Comparison between Peer to Peer network and Client/Server network Strategy Advantages Disadvantages Client/Server · Heavy processing power can be localized when needed. · Overall installation costs are less than a hierarchical network. · Servers provide clients with access to shared printers, network storage (including sharedapplications), network security features, and other network resources. · Administrative tasks not entirely centralized. · Expensive to add nodes. P2P · Relatively inexpensive to implement, can often be implemented on existing equipment. · Potentially, all resources can be made available over a network. · Processing power can be localized to the point of need. · Decentralized administration. · Security can be difficult to control III. NETWORK TOPOLOGIES Network topology is the layout pattern of interconnections of the various elements (links, nodes, etc.) of a computer network. Network topologies may be physical or logical. Physical topology means the physical design of a network including the devices, location and cable installation. Logical topology refers to how data is actually transferred in a network as opposed to its physical design. Topology can be considered as a virtual shape or structure of a network, for it not correspond to the actual physical design of the devices on the computer network. The computers on a home network can be arranged in a circle but it does not necessarily mean that it represents a ring topology. III.1 Physical Topology It is the physical configuration of a network that determines how the network's computers are connected. Common configurations include the bus 4 topology, mesh topology, ring topology, star topology, tree topology and hybrid topology. III.1.1- Bus Topology Bus Topology is the simplest of network topologies. In this type of topology, all the nodes (computers as well as servers) are connected to the single cable, by the help of interface connectors. This central cable is the backbone of the network and is known as Bus. Every workstation communicates with the other device through this Bus. A signal from the source is broadcasted and it travels to all workstations connected to bus cable. Although the message is broadcasted but only the intended recipient, whose MAC address or IP address matches, accepts it. A terminator is added at ends of the central cable, to prevent bouncing of signals. A barrel connector can be used to extend it. Advantages (benefits) of Linear Bus Topology 1) It is easy to set-up and extend bus network. 2) Cable length required for this topology is the least compared to other networks. 3) Bus topology costs very less. 4) Linear Bus network is mostly used in small networks. Good for LAN. Disadvantages (Drawbacks) of Linear Bus Topology 1) There is a limit on central cable length and number of nodes that can be connected. 2) Dependency on central cable in this topology has its disadvantages. If the main cable (i.e. bus) encounters some problem, whole network breaks down. 3) It is difficult to detect and troubleshoot fault at individual station. 4) Maintenance costs can get higher with time. 5) Efficiency of Bus network reduces, as the number of devices connected to it increases. 6) It is not suitable for networks with heavy traffic. 7) Security is very low because all the computers receive the sent signal from the source. III.2- Ring Topology In Ring Topology, all the nodes are connected to each-other in such a way that they make a closed loop. Each workstation is connected to two other components on either side, and it communicates with these two adjacent neighbors. Data travels around the network, in one direction. Sending and receiving of data takes place by the help of TOKEN. Token contains a piece of information which along with data is sent by the source computer. Advantages of Ring Topology 1) This type of network topology is very organized. Each node gets to send the data when it receives an empty token. This helps to reduces chances of collision. 2) Even when the load on the network increases, its performance is better than that of Bus topology. 3) There is no need for network server to control the connectivity between workstations. 4) Additional components do not affect the performance of network. 5) Each computer has equal access to resources. Disadvantages of Ring Topology 1) Each packet of data must pass through all the computers between source and destination. This makes it slower than Star topology. 5 2) If one workstation or port goes down, the entire network gets affected. 3) Network is highly dependent on the wire which connects different components. III.3- Star Topology In Star topology, all the components of network are connected to a central device which may be a hub, a router or a switch. All the data on the star topology passes through the central device before reaching the intended destination. This later acts as a junction to connect different nodes present in Star Network, and at the same time it manages and controls whole of the network. Advantages of Star Topology 1) As compared to Bus topology it gives far much better performance, signals don’t necessarily get transmitted to all the workstations. 2) Easy to connect new nodes or devices. In star topology nodes can be added or removed easily without affecting rest of the network. 3) Centralized management. It helps in monitoring the network. 4) Failure of one node or link doesn’t affect the rest of network. At the same time it’s easy to detect the failure and troubleshoot it. Disadvantages of Star Topology 1) If the central device fails whole network goes down. 2) The use of an extra central device increases the overall cost of the network. 3) Performance and as well number of nodes which can be added in such topology is depended on capacity of central device. III.4- Tree Topology Tree Topology integrates the characteristics of Star and Bus Topology. In Tree Topology, the number of Star networks are connected using Bus. This main cable seems like a main stem of a tree, and other star networks as the branches. It is also called Expanded Star Topology. Ethernet protocol is commonly used in this type of topology. Advantages of Tree Topology 1. Expansion of Network is possible and easy. 2. Here, we divide the whole network into segments (star networks), which can be easily managed and maintained. 3. Error detection and correction is easy. 4. If one segment is damaged, other segments are not affected. Disadvantages of Tree Topology 1. Because of its basic structure, tree topology, relies heavily on the main bus cable, if it breaks whole network is crippled. 2. As more and more nodes and segments are added, the maintenance becomes difficult. 3. Scalability of the network depends on the type of cable used. III.5- Mesh topology 6 In a mesh network topology, each of the network node, computer and other devices, are interconnected with one another. Every node not only sends its own signals but also relays data from other nodes. In fact a true mesh topology is the one where every node is connected to every other node in the network. Advantages of Mesh topology 1) Data can be transmitted from different devices simultaneously. This topology can withstand high traffic. 2) Even if one of the components fails there is always an alternative present. So data transfer doesn’t get affected. 3) Expansion and modification in topology can be done without disrupting other nodes. Disadvantages of Mesh topology 1) There are high chances of redundancy in many of the network connections. 2) Overall cost of this network is way too high as compared to other network topologies. 3) Set-up and maintenance of this topology is very difficult. Even administration of the network is tough. III.6 Hybrid topology Similarly in this type of topology we integrate two or more different topologies to form a resultant topology which has good points (as well as weaknesses) of all the constituent basic topologies rather characteristics of one specific topology. than having Advantages of Hybrid Network Topology 1) Reliable : Unlike other networks, fault detection and troubleshooting is easy in this type of topology. 2) Scalable: It’s easy to increase the size of network by adding new components, without disturbing existing architecture. 3) Flexible: Hybrid Network can be designed according to the requirements of the organization and by optimizing the available resources. Disadvantages of Hybrid Topology 1) Complexity of Design: It’s not easy to design this type of architecture and it’s a tough job for designers. Configuration and installation process needs to be very efficient. 2) Costly Hub: The hubs used to connect two distinct networks, are very expensive. These hubs are different from usual hubs as they need to be intelligent enough to work with different architectures and should be function even if a part of network is down. 3) Costly Infrastructure: As hybrid architectures are usually larger in scale, they require a lot of cables; cooling systems, sophisticate network devices, etc. III.2 Logical topology The logical topology defines how the systems communicate across the physical topologies. Logical topologies are bound to network protocols and describe how data is moved across the network. Different network access existing are: CSMA/CD, CSMA/CA and Token Passing a) CSMA/CD (Carrier Sense Multiple Access/Collision Detection) 7 Ethernet uses CSMA/CD to manage media access, as defined in the IEEE 802.3 specification. Devices that have data to transmit listen for an opening on the line before transmitting (Carrier Sense) and when a device detects an opening, it transmits its data. However, several devices may simultaneously sense that the line is clear and they may all transmit at the same time. If this happens, the data packets collide and the data is lost. This is called a collision. Using the CSMA/CD protocol, the devices will each detect that a collision has occurred (collision detection) and each of them will wait a random amount of time before retransmitting. The likelihood of two or more devices randomly selecting the same delay is almost zero, so retransmission is likely to be successful. b) CSMA/CA (Carrier Sense Multiple Access/Collision Avoidance) With CSMA/CA, a device listens for an opportunity to transmit its data in a similar fashion to CSMA/CD. However, when a device senses an opening, it first transmits a signal notifying other devices that it is transmitting before actually sending the data. This means data packets will never collide, although warning packets might. Unfortunately, CSMA/CA creates a significant overhead as it adds unnecessary traffic to the network, slowing everything down. CSMA/CA was commonly used by older AppleTalk networks, but nowadays most Apple systems can use Ethernet hardware and use of CSMA/CA has declined. One area where CSMA/CA continues to be used is in wireless networks. c) Token Passing In CSMA/CD and CSMA/CA the chances of collisions are there. As the number of hosts in the network increases, the chances of collisions also will become more. In token passing, when a host want to transmit data, it should hold the token, which is an empty packet. The token is circling the network in a very high speed. If any workstation wants to send data, it should wait for the token. When the token has reached the workstation, the workstation can take the token from the network, fill it with data, mark the token as being used and place the token back to the network. IV. COMMUNICATION OVER NETWORK IV.1 What is data communication? A communication system can be defined as the collection of hardware and software that facilitates intersystem exchange of information between different devices. Data communication is the exchange of data between two devices using some form of wired or wireless transmission medium. It includes the transfer of data, the method of transfer and the preservation of data during the transfer process. IV.2 Characteristics of data communication For data communication to be effective, the following three fundamental characteristics should be considered:  Delivery: The system must deliver data to the correct or the intended destination.  Accuracy: The system must deliver data accurately (error-free).  Timeliness: The system must deliver data in a timely manner without enough time lags. IV.2- Data Communication Components There are five basic components in a data communication system  Message: The message is the information that is to be communicated.  Sender: The sender is the device that sends the message.  Receiver: The receiver is the device that receives the message. 8  Medium: The transmission medium is the physical path that communicates the message from the sender to the receiver.  Protocol: Protocol refers to a set of rules that coordinates the exchange of information. Both the sender and the receiver should follow the same protocol to communicate data. IV.3- Data Transmission Mode Data transmission mode refers to the direction of signal flow between two linked devices. There are three types of transmission modes—simplex, half-duplex and full-duplex 1) Simplex: The information flows in one direction across the circuit, with no capability to support response in the other direction. 2) Half-duplex: In half-duplex mode, each communicating device can receive and transmit information, but not at the same time. 3) Full-duplex: allows both communicating devices to transmit and receive data simultaneously. A full-duplex mode can be compared to a two-way road with traffic flowing in both directions. IV.4- Data Communication Measurement The measurement of the quantity of data that can be passed over a communication link in a given time is done in terms of bandwidth. On digital circuits, bandwidth is measured in bits per second (bps). In the digital context, the level of bandwidth falls into three categories.  Narrowband: In narrowband, there is a single transmission channel of 64 Kbps or less. There can be a number of 64 Kbps channels (N × 64 Kbps), but total capacity is not more than 1.544 Mbps.  Wideband: In wideband, the bandwidth lies between 1.544 Mbps (also called T1 line) and 45 Mbps (T3 line).  Broadband: The bandwidth capacity is equal to 45 Mbps. Broadcast television, cable television, microwave and satellite are examples of broadband technologies. IV.5 Analog and Digital Data Transmission The major role of the physical medium is to move the data from one communicating device to another. Depending on the form of signal used, data transmission can be analog data transmission or digital data transmission. 9  Analog Signals: Values on analog devices are (normally) infinitely variable. A speedometer that shows a car's speed by means of a dial is an analog device. The hand on that dial moves smoothly around the dial and can take any value that the car's engine can create.  Digital Signals: Digital signals and objects deal in the realm of the discrete or finite, meaning there is a limited set of values they can be. That could mean just two total possible values, 255, 4,294,967,296, or anything as long as it’s not ∞ (infinity). IV.6 Serial and Parallel Communication The transmission of binary data across a link can be accomplished in either parallel or serial mode. In parallel mode, multiple bits are sent with each clock tick. In serial mode, 1 bit is sent with each clock tick. IV.7 Data Transmission Method While there is only one way to send parallel data, there are two subclasses of serial transmission: asynchronous, synchronous.  With asynchronous transmission signal timing is not required; signals are sent in an agreed pattern of bits and if both ends are agreed on the pattern then communication can take place.  With synchronous transmission is data transfer method in which a continuous stream of data signals is accompanied by timing signals (generated by an electronic clock) to ensure that the transmitter and the receiver are in step (synchronized) with one another. The data is sent in blocks (called frames or packets) spaced by fixed time intervals. V. TRANSMISSION MEDIA A transmission medium (plural transmission media) refers to the physical media through which communication signals (data and information) can be transmitted from one point to another media. There are two categories of transmission media used in computer communications: - Guided Media (or Bounded Media, or Wired Media) - Unguided Media (or unbounded Media, or Wireless Media) V.1- Guided Media Guided media are the physical links through which signals are confined to narrow path. These are also called Bounded media. Bounded media are great for LABS because they offer high speed, good security and low cost. However, some time they cannot be used due distance communication. Three common types of bounded media are used of the data transmission. These are: coaxial cable, twisted pair cable and Fiber optic cables a) Twisted-Pair Wiring Twisted-pair wiring refers to a type of cable composed of four (or more) copper wires twisted around each other within a plastic sheath. The wires are twisted to reduce outside electrical interference. The RJ-45 connectors on twisted-pair cables resemble large telephone connectors. Twisted-pair cables come in two varieties: Shielded Twisted Pair (STP) and unshielded Twisted Pair (UTP). 10 → Unshielded twisted pair (UTP) UTP cable is the most common type of telecommunication medium in use today and is generally the best option for school networks. It is most suited for both data and voice transmission and hence is commonly used in telephone systems. The cable has four pairs of wire inside the jacket. An UTP cost less than STP easily available. There are five levels of data cabling - - - - - Cat 1: These are used in telephone lines and low speed data cable. Cat 2: These cables can support up to 4 mps implementation. Cat 3: These cable supports up to 16 mps and are mostly used in 10 mps. Cat 4: These are used for large distance and high speed. It can support 20mps. Cat 5: This is the highest rating for UTP cable and can support up to 100mps. → A disadvantage of UTP is that it may be susceptible to radio and electrical frequency interference. Shielded twisted pair (STP) is suitable for environments with electrical interference; however, the extra shielding can make the cables quite bulky. Shielded twisted pair is often used on networks using Token Ring topology. b) Coaxial Cable Coaxial cables have a single central conductor, which is made up of solid wire (usually copper). This conductor is surrounded by an insulator over which a sleeve of metal mesh is woven to block any outside interference. This metal mesh is again shielded by an outer covering of a thick material (usually PVC) known as jacket. Coaxial cable is very robust and is commonly used in Cable TV network. As compared to twisted pairs, it also offers higher bandwidth. A coaxial cable is capable of transmitting data at a rate of 10 Mbps. c) Fiber-Optic Cable Fiber optic (or optical fiber) refers to the technology associated with the transmission of information as light impulses along a glass wire or fiber. Optical fiber cable can transmit data over long distances with little loss in data integrity. In addition, because data are transferred as a pulse of light, optical fiber is not subject to interference. Fiber optic cable has the ability to transmit signals over much longer distances than coaxial and twisted pair. It also has the capability to carry information at vastly greater speeds. This capacity broadens communication possibilities to include services such as video conferencing and interactive services. however, it is more difficult to install and modify. 10BaseF refers to the specifications for fiber optic cable carrying Ethernet signals. Fig 4: bounded media 11 V.2- Unbounded Transmission Media Unguided media facilitate data transmission through the Earth's atmosphere (air, water or vacuum) at a much faster rate and provide wide area coverage. The data signals are not guided or bound to a fixed channel to follow. Some commonly used unguided media of transmission include radio frequency (RF) propagation, microwave transmission, satellite transmission, infrared wave transmission, Bluetooth and Wi-Fi. a) Radio Frequency Propagation In radio frequency propagation, the signal is carried over carrier waves (waves, which carry signals over them), which have frequencies in the range of radio frequency spectrum. There are three types of radio frequency propagation—ground wave, ionospheric and line of sight. b) Microwave Transmission Microwave transmission use microwave signals that travel at a higher frequency and are popularly used for transmitting data over long distances. Microwave communication uses parabolic antennas (satellite TV dish antennas) that are mounted on the tower, which could be tens of kilometers away, but in line of sight. Due to long distances, repeaters are used at regular intervals in between the transmitter and the receiver to boost the signals c) Infrared Wave Transmission Infrared frequencies are just below the visible light spectrum. These are the high frequency waves used for short-range communication. The waves are cheap, directional and can be easily built; however, the waves do not pass through solid objects. Infrared waves are used in TV remotes, garage doors and wireless speakers. Computer machines in an office can easily be connected to a wireless LAN using infrared waves d) Satellite Transmission Satellite transmission is similar to microwave transmission except instead of transmission involving another nearby microwave dish antenna, it involves a satellite many miles up in space. The communication is carried through uplinks and downlinks. The uplink transmits the data to the satellite and downlink receives the data from the satellite. Uplinks and downlinks are also called earth stations because they are located on the Earth. e) Bluetooth transmission The Bluetooth technology is used to create a personal area network (PAN) or piconet that lets electronic devices such as computers, cell phones, PDAs and wireless keyboards to communicate with each other within the range of 10 m. It uses radio signals that are omnidirectional, that is, signals travel in all directions from the 12 source. Hence, the communicating devices need not be aligned with each other. f) Wi-Fi transmission The term Wi-Fi, which stands for Wireless Fidelity is widely used for creating wireless LANs and also for providing wireless Internet access. To create wireless LAN, the devices in the network such as computer, laptop and PDA should be equipped with wireless network interface card (NIC) to send and receive Wi-Fi signals. A WI-Fi-enabled device should be within a specific range (i.e. up to 50 m) from the network to connect. Media Type Twisted-pair (LAN) 1MHz Bandwidth Performance: Typical Error Rate Transfer rate Poor to fair (10–5) Coaxial cable (LAN) 10 Mbps – 100 Mbps 1GHz Good (10–7 to 10–9) Microwave (WAN) 10 Mbps – 1 Gbps 100GHz Good (10–9) Satellite (WAN) 6 Mbps – 54 Mbps 100GHz Good (10–9) Fiber (WAN) 50 Kbps – 100 Mbps 75THz Great (10–11 to 10–13) Table 2: Traditional Transmission Media Characteristics 50 Kbps – 100 Mbps VI. COMMUNICATION PROTOCOLS A communication protocol is a set of rules that coordinates the exchange of information. If one computer is sending information to another and they both follow the same protocol, the message gets through; regardless of what types of machines they are and on what operating systems they are running. As long as the machines have software that can manage the protocol, communication is possible. VI.1 Network protocol A protocol defines what is communicated, how it is communicated, and when it is communicated. The key elements of a protocol are syntax, semantics, and timing.  Syntax: Syntax refers to the structure or format of the data, meaning the order in which they are presented.  Semantics: Semantics refers to the meaning of each section of bits. How is a particular pattern to be interpreted, and what action is to be taken based on that interpretation.  Timing: Timing refers to two characteristics: when data should be sent and how fast they can be sent. Some important protocols are: Protocol Full meaning Its job File Transfer Protocol FTP Allows file transfer between two computers HTTP Hyper Text Transfer Protocol Protocol used in the web service TCP Transmission Control Protocol A reliable connection oriented protocol used to control the management of application level services between computers. IP Internet Protocol identifier of each computer or communication devices on the network and internet. ARP Address resolution protocol enables the packaging of IP data into ethernet package ICMP Internet control message protocol provides management and error reporting to help manage the process of sending data between computers. SMTP Simple Mail Transfer Protocol An Internet protocol for transferring e-mail. POP post office protocol Telephone Network Transfert of e-mail, used to synchronize messages Telnet A method of opening a user session on a remote host. 13 14 PPP Point-to-Point Protocol Data transfer using modem UDP User Datagram Protocol An unreliable connection less protocol used to control the management of application level services between computers. DHCP Dynamic host configuration protocol is a method of assigning and controlling the IP addresses of computers on a given network VI.2 The OSI Model Open Systems Interconnection (OSI) is a standard reference model for communication between two end users in a network. In 1983, the International Organisation for Standardisation (ISO) published a document called 'The Basic Reference Model for Open Systems Interconnection', which visualizes network protocols as a seven separate but related layers: physical, data link, network, transport, session, presentation and application layers. The seven layers of the OSI reference model can be divided into two categories:  Upper Layers: The upper layers of the OSI model consist of the application, presentation and session layers. Primarily, these layers deal with application issues and are implemented only in the software.  Lower Layers: The lower layers of the OSI model comprise the transport, network, data link, and physical layers. These layers handle the data transport issues. The physical layer and data link layer are implemented in both hardware and software. The network and transport are generally implemented only in software. Physical (Layer 1) This layer conveys the bit stream - electrical impulse, light or radio signal -- through the network at the electrical and mechanical level. It provides the hardware means of sending and receiving data on a carrier, including defining cables, cards and physical aspects Protocols: Fast Ethernet, ATM Data Unit: Bit Device: Hubs, Repeaters, Cables and Connectors Data Link (Layer 2) Physical addressing, Provides low-level error detection and correction. For example if a packet is corrupted this layer is responsible for retransmitting the packet. Protocols: PPP, FDDI, Token ring, Ethernet, SLIP Device: NIC, Token Ring switches, Bridges Data Unit: Frame Network (Layer 3) This layer provides switching and routing technologies, creating logical paths, known as virtual circuits, for transmitting data from node to node. Routing and forwarding are functions of this layer, as well as addressing, internetworking, error handling, congestion control and packet sequencing. 15 Protocols: IPv4, IPV6, IPX, OSPF, NWlink, NetBEUI, ICMP, ARP, RARP Data Unit: Packet, Datagram Transport (Layer 4) This layer provides transparent transfer of data between end systems, or hosts, and is responsible for end-to-end error recovery and flow control. It ensures complete data transfer. Protocols: TCP, SPX and UDP Device: Router, gateway Data Unit: Segments Session (Layer 5) This layer establishes, manages and terminates connections between applications. The session layer sets up, coordinates, and terminates conversations, exchanges, and dialogues between the applications at each end. It deals with session and connection coordination. Protocols: NetBIOS Device: gateway Data Unit: data Presentation (Layer 6) This layer works to transform data into the form that the application layer can accept. This layer formats and encrypts data to be sent across a network, providing freedom from compatibility problems. It is also called the syntax layer. Protocol: SSL, WEP, WPA, Kerberos Device: Gateway Application (Layer 7) This layer supports application and end-user processes. Communication partners are identified, quality of service is identified, user authentication and privacy are considered, and any constraints on data syntax are identified. Everything at this layer is application specific. This layer provides application services for file transfers, e-mail, and other network software services. Protocol: DHCP, DNS, FTP, HTTP, IMAP4, NNTP, POP3, SMTP, SNMP, SSH, TELNET and NTP Device: PC Data Unit: Data VII. LAN TECHNOLOGIES Each computer in a LAN can effectively send and receive any information addressed to it. This information is in the form of data 'packets'. The standards followed to regularize the transmission of packets, are called LAN standards. There are many LAN standards as Ethernet, Token Ring , FDDI etc. Usually LAN standards differ due to their media access technology and the physical transmission medium. VII.1- Ethernet Media Standards The IEEE (Institute of Electrical and Electronic Engineer) 802 Standards comprises a family of networking standards that cover the physical layer specifications of technologies. Ethernet, Fast Ethernet and Gigabit Ethernet are the LAN technologies most commonly used today. They are identified by three-part names, which is also known as Media Standard. An example of Media Standard is 10BASE-T.  The first part of the Media Standard specifies the transmission speed (10, in this case specifies 10 Mbps)  The second part of the name "BASE" specifies that the Ethernet signal is a Baseband signal.  The final part of the Ethernet Media Standard specifies the kind of cable used. Here T specifies twisted-pair cable. The following table shows the common Ethernet Media Standards. Name Cable Type Connector 10Base-T Maximum Length Speed Category 3 or better UTP cable RJ-45 100 meters(328 ft) 10Base-FL Fiber optic cable ST, SC, LC, MT-RJ 2000 meters 10 mbps 100Base-TX 10 mbps Cat 5 twisted pair RJ-45 100Base-FX 100 meters(328 ft) Fiber Optic ST, SC, LC, MT-RJ 2000 meters 100 mbps 1000Base-T 100 mbps CAT5e or higher RJ-45 100 meters(328 ft) Note: X represents a higher grade of connection, and 100BaseTX is twisted-pair cabling that can use either UTP or STP at 100 Mbps. With fibre-optic cable such as 100BaseFX, the speed is quicker than standard 10BaseF. The “L” stands for “Long” in long wave length lasers and "S" stands for Short Wave Length. 1 gbps VII.3- LAN protocols a) Ethernet / fast Ethernet The Ethernet protocol is by far the most widely used. Ethernet uses called CSMA/CD method. The Ethernet protocol allows for linear bus, star, or tree topologies. Data can be transmitted over wireless access points, twisted pair, coaxial, or fiber optic cable at a speed of 10 Mbps up to 1000 Mbps. To allow for an increased speed of transmission, the Ethernet protocol has developed a new standard that supports 100 Mbps. This is commonly called Fast Ethernet. Advantages of Ethernet are: Low cost components, Easy to install, Easy to troubleshoot b) Local Talk Local Talk is a network protocol that was developed by Apple Computer, Inc. for Macintosh computers. The method used by Local Talk is CSMA/CA. The Local Talk protocol allows for linear bus, star, or tree topologies using twisted pair cable. A primary disadvantage of Local Talk is speed. Its speed of transmission is only 230 Kbps. c) Token Ring The Token Ring protocol was developed by IBM in the mid-1980s. The access method used involves token-passing. The Token Ring protocol requires a star-wired ring using twisted pair or fiber optic cable. It can operate at transmission speeds of 4 Mbps or 16 Mbps. Due to the increasing popularity of Ethernet, the use of Token Ring in school environments has decreased. d) FDDI Fiber Distributed Data Interface (FDDI) uses a dual ring physical topology. The access method used by FDDI involves token-passing. Transmission normally occurs on one of the rings; however, if a break occurs, the system keeps information moving by automatically using portions of the second ring to create a new complete ring. A major advantage of FDDI is speed. It operates over fiber optic cable at 100 Mbps. e) ATM 16 17 Asynchronous Transfer Mode (ATM) is a network protocol that transmits data at a speed of 155 Mbps and higher. ATM works by transmitting all data in small packets of a fixed size; whereas, other protocols transfer variable length packets. ATM supports a variety of media such as video, CD-quality audio, and imaging. ATM employs a star topology, which can work with fiber optic as well as twisted pair cable. Protocol Cable Speed Topology Method Ethernet Twisted Pair, Coaxial, Fiber 10 Mbps Linear Bus, Star, Tree CSMA/CD Fast Ethernet Twisted Pair, Fiber 100 Mbps Star CSMA/CD LocalTalk Twisted Pair .23 Mbps Linear Bus or Star CSMA/CA Token Ring Twisted Pair 4 Mbps - 16 Mbps Star-Wired Ring Token passing FDDI Fiber 100 Mbps Dual ring Token passing ATM Twisted Pair, Fiber 155-2488 Mbps Bus, Star, Tree Table Compare the Network Protocols VIII. NETWORK ADRESSING XI.1- What is an IP address? An IP (Internet Protocol) address is a unique identifier for a node or host connection on an IP network. An IP address version 4 (IPv4) is a 32 bit binary number usually represented as 4 decimal values, each representing 8 bits, in the range 0 to 255 (known as octets) separated by decimal points. This is known as "dotted decimal" notation. Example: 140.179.220.200 It is sometimes useful to view the values in their binary form. 140.179.220.200 becomes 10001100.10110011.11011100.11001000 Every IP address consists of two parts, one identifying the network and one identifying the node. The Class of the address and the subnet mask determine which part belongs to the network address and which part belongs to the node address. XI.2- Address Classes The Internet community originally defined five address classes to accommodate networks of varying sizes. Microsoft TCP/IP supports class A, B, and C addresses assigned to hosts. The class of address defines which bits are used for the network ID and which bits are used for the host ID. It also defines the possible number of networks and the number of hosts per network. Class 1st Octet Decimal Range 1st Octet High Order Bits Network/Host ID (N=Network, H=Host) Default Subnet Mask Number of Networks Hosts per Network (Usable Addresses) A 1 – 126* 0 N.H.H.H 255.0.0.0 126 (27 – 2) 16,777,214 (224 – 2) B 128 – 191 10 N.N.H.H 255.255.0.0 16,382 (214 – 2) 65,534 (216 – 2) C 192 – 223 110 N.N.N.H 255.255.255.0 2,097,150 (221 – 2) 254 (28 – 2) D 224 – 239 1110 Reserved for Multicasting E 240 – 254 1111 Experimental; used for research Note: → Class A addresses 127.0.0.0 to 127.255.255.255 cannot be used and is reserved for loopback and diagnostic functions. → Class D addresses are reserved for IP multicast addresses. The four high-order bits in a class D address are always set to binary 1110. The remaining bits are for the address that interested hosts recognize. → Class E is an experimental address that is reserved for future use. The high-order bits in a class E address are set to 1111. → All bits within the network ID cannot be set to 1. All 1's in the network ID are reserved for use as an IP broadcast address. → All bits within the network ID cannot be set to 0. All 0's in the network ID are used to denote a specific host on the local network and are not routed. Private IP Addresses: There are addresses used in the private networks Class Private Networks Subnet Mask Address Range A 10.0.0.0 255.0.0.0 B 172.16.0.0 - 172.31.0.0 255.240.0.0 172.16.0.0 - 172.31.255.255 10.0.0.0 - 10.255.255.255 C 192.168.0.0 255.255.0.0 192.168.0.0 - 192.168.255.255 IX. NETWORK SECURITY Network security consists of the provisions and policies adopted by a network administrator to prevent and monitor unauthorized access, misuse, modification, or denial of a computer network and network accessible resources. IX.1 Network Security Problems Network security problems can be divided roughly into four intertwined areas: secrecy, authentication, nonrepudiation and integrity control. 1. Secrecy: This is also called confidentiality, and has to do with keeping information out of the hands of unauthorized users. 2. Authentication: this deal with determining whom you are talking to before revealing sensitive information or entering into a business deal. 3. Nonrepudiation: This deals with signatures: How does amazon.ca prove that Kartik indeed placed an order for a book, which Kartik claims he never placed? 4. Integrity of service: How does one ensure that the message received was really the one sent, and not something that a malicious adversary modified in transit or concocted? IX.2 Types of attacks over a network We classify the attacks that compromise network security as passive attacks and active attacks. a) Passive Attacks: These attacks are in the nature of eavesdropping on, or monitoring of, transmissions. The goal of the opponent is to obtain information that is being transmitted. Passive attacks are very difficult to detect since they do not involve the alteration of the data. Two types of passive attacks are:  release of message contents where an eavesdropper tries to learn the contents of what is being transmitted. This can be prevented by encryption  traffic analysis: where the opponent tries to observe the pattern, frequency and length of messages being exchanged which could be used in guessing the nature of the communication that is taking place. 18 b) Active Attacks: Active attacks involve some modification of the data stream or the creation of a false stream. It is difficult to prevent active attacks absolutely because to do so would require physical protection of all communications facilities and paths at all times. Instead, the goal is to detect them and to recover from any disruption or delays caused by them. IX.3 Data compression and data encryption In other to send data easily through a network, it is required to compress it in other to reduce space for storage and bandwidth for transmission. Data compression is the process of converting data from a large format into a smaller format, usually by the means of an algorithm. Some popular examples of data compression techniques include: a) Graphic Interchange Format (GIF): This is a widely used compression format that is used for storing and transferring graphic images in relatively small files over computer network such as Internet b) Joint Picture Expert Group (JPEG): This is a popular file compression format for storing and transferring colour photograph and high quality images in relatively small files over computer network such as Internet c) Motion Picture Expert Group (MPEG): This is a standard file compression format for storing and transferring digital audio and video (moving images) in relatively small files over computer network d) Huffman coding: This is a lossless compression technique in which the characters in a data file are converted to a binary code, where the most common characters in the file have the shortest binary code, and the least common have the longest. e) Run-length encoding: This a compression technique that is designed for compressing, long, repetitive character strings in a piece of text, as well as compressing byte of a monochrome image file. An important characteristic feature in any coding scheme is the compression ratio. It is the ratio of a compressed file to the original uncompressed file. There are two basic form of data compression: lossless compression and lossy compression. - - Lossless compression is the form of compression in which the original data can be restores exactly.(ex: zip) Lossy compression is the form of compression in which the original data cannot be restored exactly due to loss of some of its elements (ex: mp3) Data encryption refers to mathematical calculations and algorithmic schemes that transform plaintext into cyphertext, a form that is non-readable to unauthorized parties. The recipient of an encrypted message uses a key which triggers the algorithm mechanism to decrypt the data, transforming it to the original plaintext version. 19 INFORMATION SYSTEM I. DATA PROCESSING CYCLE The term “data processing” (or by abuse information processing) usually refers to the manipulation off raw information (called data) to produce useful information. Information processing cycle refers to the sequence of events which includes four principal stages: Input, processing and output 1- Input: Data input refers to the various manual and automated ways by which data enter the computer. This stage involves collection of data from the outside or also from within the system. The input stage can be further broken down into data acquisition, data entry and data validation. - - - Data acquisition refers to the collection of the raw data from the outside so that it can be put into an Information system. Data entry is the process of putting the acquired data into the IS. Example: typing students details into a database Data validation refers to the process of checking the data to ensure it is error free. It uses routines also called validation routines or check routines, that check for correctness, meaningfulness and security of data that are input to the system.  format check: e.g. date has to be in the format DD/MM/YY  Data type check: e.g. the letter ‘O’ should not be typed instead of the integer 0.  Range check: The month should lie between 1 and 12  Limit check: the age should not be negative  Presence check: e.g. Any customer must have a telephone number  Consistency check: e.g. If Title = “Mrs”, then the gender = “F”  … 2- Processing : In this stage the computer processes the minutest details entered. It is the fact of manipulating data to produce information. Common processing methods  Batch Processing: This is a method where the information to be organized is sorted into groups to allow for efficient and sequential processing.  Online Processing: This is a method that utilizes Internet connections and equipment directly attached to a computer. It is used mainly for information recording and research.  Real-Time Processing: This technique has the ability to respond almost immediately to various signals in order to acquire and process information. 20  Distributed Processing: This method is commonly utilized by remote workstations connected to one big central workstation or server. ATMs are good examples of this data processing method. 3- Output: In this stage, the processed information is now transmitted to the user. Output is the act of sending out information by a data processing system such as the computer. 4- Other stages : Other stages include: (a) Storage: After the data has been processed, along with the output to the user, the data is also stored. (b) Retrieval: This is the reverse of storage (c) Communication: This is the process of sending data or information to another places. (d) Data verification: This is the process whereby the process is checked for accuracy and inconsistencies after data migration. Data verification is used to prevent errors occurring when data is copied from one medium to another. Common data verification methods include: - - - Proof reading (visual check): checked for errors by looking through the data. E.g. proof-reading a typed document Double keying: This is a check to see whether the data has been keyed in correctly. The data is keyed twice, and the computer will only accept the data for processing in the two versions are identical. Parity: Used to check for transmission errors over network or between memory and disk. An extra bit is added to each binary number before it is transmitted. Even parity system makes sure that each number has an even number of “1” bits. After transmission each number is checked to see if it still has an even number of “1” bits. If not, then the computer will conclude that the corruption of data has occurred. (e) Archiving: Archiving means taking the data off the main storage (e.g. hard drive) and storing it offline (not immediately available) usually on tape in the way it will not take up important hard disk space. (f) Deleting: This is the process of erasing or wiping our recorder data (usually from a recorded unit). II. INFORMATION SYSTEM 2.1. What is a System? We can define a System as a combination of resources or functional units working together to accomplish a given task. a) Basic element of a system The basic elements of the system may be listed as: → Resources: Resources can be hardware, software or liveware. → Procedures: Every system functions under a set of rules that govern the system to accomplish the defined goal of the system. This set of rules defines the procedures for the system → Data/Information, → Processes: The systems have some processes that make use of the resources to achieve the set goal under the defined procedures. b) Characteristics of a system Systems also exhibit certain features and characteristics, some of which are: 21 → Objective: Every system has a predefined goal or objective towards which it works. A system cannot exist without a defined objective. → Standards: It is the acceptable level of performance for any system. Systems should be designed to meet standards. → Environment: Every system whether it is natural or man made co-exists with an environment. It is very important for a system to adapt itself to its environment. → Feedback: Feedback is an important element of systems. The output of a system needs to be observed and feedback from the output taken so as to improve the system and make it achieve the laid standards. → Boundaries and interfaces: Every system has defined boundaries within which it operates. Beyond these limits the system has to interact with the other systems. c) Types of Systems → Manual Systems: These are systems that are basically mechanical in nature and do not require or use any automation. Such systems existed predominantly in the past and were not very reliable or fast. → Information Systems: (IS) Any system that makes use of automation and especially harnessed by people, procedures, software, hardware and digital data is called an information system (IS). 2.2. What is an Information System? An Information System (IS) is defined as an organized collection of technical and human resources for the processing, storing and distribution of an organization’s information. An IS using a computer is called a Computer Based Information System (CBIS). 2.2.1. Components of IS The 5 components that must come together in order to produce a Computer-Based Information system are:  Hardware: The term hardware refers to machinery. This category includes the computer itself, which is often referred to as the central processing unit (CPU), and all of its support equipments.  Software: The term software refers to computer programs and the manuals (if any) that support them.  Data: Data are facts that are used by programs to produce useful information.  Procedures: Procedures are the policies that govern the operation of a computer system. "Procedures are to people what software is to hardware" is a common analogy that is used to illustrate the role of procedures in a CBIS.  People: Often the most over-looked element of the CBIS are the people, probably the component that most influence the success or failure of information systems. 2.3. Importance of an IS in an organization To gain the maximum benefits from your company's information system, you have to exploit all its capacities. Importance of IS within an organisation are numerous:  Communication: Part of management is gathering and distributing information, and information systems can make this process more efficient by allowing managers to communicate rapidly.  Operations: How you manage your company's operations depends on the information you have. Information systems can offer more complete and more recent information, allowing you to operate your company more efficiently. 22  Decisions: The company information system can help you make better decisions by delivering all the information you need and by modelling the results of your decisions.  Records: Your Company needs records of its activities for financial and regulatory purposes as well as for finding the causes of problems and taking corrective action. 2.4. Types of Information System Information systems differ in their business needs. Also depending upon different levels in organization information systems differ. Three major information systems are: 1. Transaction processing 2. Management information system 3. Decision support system 4. Executive Information System 2.4.1. Executive Information System (EIS): This is a computer based system intended to help and support the information and decision making needs of senior executives of a company or organization. It provides easy access to internal and external information needed to achieve the strategic goals of the organization. It is commonly considered as a specialized form of DSS. Functions of a EIS in terms of data processing requirements Processing Inputs Outputs External Data Internal Files Pre-defined models Summarizing Simulation "Drilling Down" Summary reports Forecasts Graphs / Plots 2.4.2. Decision support system (DSS) A decision support system is a computer application that helps users analyse problems and make business decisions more confidently. It uses data routinely collected in organizations and special analysis tools to provide information support to complex decisions. To store all the necessary decision-making data, DSSs or EISs often use extremely large databases, called data warehouses. A data warehouse stores and manages the data required to analyze historical and current business circumstances. DSS manipulate and build upon the information from a MIS and/or TPS to generate insights and new information. Functions of a DSS in terms of data processing requirements Processing Inputs Outputs Internal Transactions Internal Files External Information? Modelling Simulation Analysis Summarizing Summary reports Forecasts Graphs / Plots 2.4.3. Management Information system (MIS) 23 The MIS is defined as a system which provides information support for decision making in the organization. They use the results of transaction processing and some other information also. It is an information system that generates accurate, timely and organized information so managers and other users can make decisions, solve problems, supervise activities, and track progress. An important element of MIS system is database. MIS are built on the data provided by the TPS Functions of a MIS in terms of data processing requirements Processing Inputs Outputs Internal Transactions Internal Files Structured data Sorting Merging Summarizing Summary reports Action reports Detailed reports 2.4.4. Transaction Processing System (TPS) A transaction processing system (TPS) is an information system that captures and processes data generated during an organization’s day-to-day transactions. A transaction is any activity of an organization including a business activity such as a deposit, payment, order or reservation. As computers became more powerful, system developers built online transaction processing systems. With online transaction processing (OLTP) the computer processes transactions as they are entered. Functions of a TPS in terms of data processing requirements Processing Inputs Outputs Transactions Events Validation Sorting Listing Merging Updating Calculation Lists Detail reports Action reports Summary reports? 2.4.5. Other types of information systems a) Office Automation System (OAS): These are systems that use varied computer machinery and software to digitally create, collect, store, manipulate and relay office information needed for accomplishing basic tasks in an organisation. All office functions like dictation, typing, filing, copying, fax, telex, microfilm and records management, telephone and telephone switch board operations are included. b) Expert system (ES): An expert system is an information system that captures and stores the knowledge of human experts and then imitates human reasoning and decision-making processes for those who have less expertise. Expert systems are composed of two main components: a knowledge base and inference rules. - - A knowledge base is the combined subject knowledge and experiences of the human experts. The inference rules are a set of logical judgments applied to the knowledge base each time a user describes a situation to the expert system. c) Integrated Information Systems (IIS): With today’s sophisticated hardware, software and communications technologies, it is often difficult to classify a system as belonging uniquely to one of the information system types discussed. Although expert systems still operate primarily as separate 24 systems, organizations increasingly are consolidating their information needs into a single, integrated information system. .4 SYSTEM LIFE CYCLE System life cycle is an organizational process of developing and maintaining systems. It helps in establishing a system project plan, because it gives overall list of processes and sub-processes required developing a system. System development life cycle means combination of various activities. In other words we can say that various activities put together are referred as system development life cycle. In the System Analysis and Design terminology, the system development life cycle means software development life cycle. Following are the different phases of software development cycle:  System study  Feasibility study  System analysis  System design  Coding  Testing  Implementation  Maintenance The different phases of software development life cycle Different phases of Software development Life Cycle 5 PHASES OF SYSTEM DEVELOPMENT LIFE CYCLE Let us now describe the different phases and the related activities of system development life cycle in detail. (a) System Study System study is the first stage of system development life cycle. This gives a clear picture of what actually the physical system is? In practice, the system study is done in two phases. In the first phase, the 25 preliminary survey of the system is done which helps in identifying the scope of the system. The second phase of the system study is more detailed and in-depth study in which the identification of user’s requirement and the limitations and problems of the present system are studied. After completing the system study, a system proposal is prepared by the System Analyst (who studies the system) and placed before the user. The proposed system contains the findings of the present system and recommendations to overcome the limitations and problems of the present system in the light of the user’s requirements. To describe the system study phase more analytically, we would say that system study phase passes through the following steps:  problem identification and project initiation  background analysis  inference or findings (b) Feasibility Study On the basis of result of the initial study, feasibility study takes place. The feasibility study is basically the test of the proposed system in the light of its workability, meeting user’s requirements, effective use of resources and .of course, the cost effectiveness. The main goal of feasibility study is not to solve the problem but to achieve the scope. In the process of feasibility study, the cost and benefits are estimated with greater accuracy. (c) System Analysis Assuming that a new system is to be developed, the next phase is system analysis. Analysis involved a detailed study of the current system, leading to specifications of a new system. Analysis is a detailed study of various operations performed by a system and their relationships within and outside the system. During analysis, data are collected on the available files, decision points and transactions handled by the present system. Interviews, on-site observation and questionnaire are the tools used for system analysis. Using the following steps it becomes easy to draw the exact boundary of the new system under consideration:  Keeping in view the problems and new requirements  Workout the pros and cons including new areas of the system All procedures, requirements must be analysed and documented in the form of detailed data flow diagrams (DFDs), data dictionary, logical data structures and miniature specifications. System Analysis also includes sub-dividing of complex process involving the entire system, identification of data store and manual processes. The main points to be discussed in system analysis are:  Specification of what the new system is to accomplish based on the user requirements.  Functional hierarchy showing the functions to be performed by the new system and their relationship with each other.  Function network which are similar to function hierarchy but they highlight the those functions which are common to more than one procedure.  List of attributes of the entities - these are the data items which need to be held about each entity (record) (d) System Design Based on the user requirements and the detailed analysis of a new system, the new system must be designed. This is the phase of system designing. It is a most crucial phase in the development of a system. Normally, the design proceeds in two stages :  preliminary or general design  Structure or detailed design Preliminary or general design: In the preliminary or general design, the features of the new system are specified. The costs of implementing these features and the benefits to be derived are estimated. If the project is still considered to be feasible, we move to the detailed design stage. Structure or Detailed design: In the detailed design stage, computer oriented work begins in earnest. At this stage, the design of the system becomes more structured. Structure design is a blue print of a computer system solution to a given problem having the same components and inter-relationship among 26 the same components as the original problem. Input, output and processing specifications are drawn up in detail. In the design stage, the programming language and the platform in which the new system will run are also decided. There are several tools and techniques used for designing. These tools and techniques are:  Flowchart  Data flow diagram (DFDs)  Data dictionary  Structured English  Decision table  Decision tree Each of the above tools for designing will be discussed in detailed in the next lesson. (e) Coding After designing the new system, the whole system is required to be converted into computer understanding language. Coding the new system into computer programming language does this. It is an important stage where the defined procedure are transformed into control specifications by the help of a computer language. This is also called the programming phase in which the programmer converts the program specifications into computer instructions, which we refer as programs. The programs coordinate the data movements and control the entire process in a system. It is generally felt that the programs must be modular in nature. This helps in fast development, maintenance and future change, if required. (f) Testing Before actually implementing the new system into operations, a test run of the system is done removing all the bugs, if any. It is an important phase of a successful system. After codifying the whole programs of the system, a test plan should be developed and run on a given set of test data. The output of the test run should match the expected results. Using the test data following test run are carried out:  Unit test  System test Unit test: When the programs have been coded and compiled and brought to working conditions, they must be individually tested with the prepared test data. Any undesirable happening must be noted and debugged (error corrections). System Test: After carrying out the unit test for each of the programs of the system and when errors are removed, then system test is done. At this stage the test is done on actual data. The complete system is executed on the actual data. At each stage of the execution, the results or output of the system is analysed. During the result analysis, it may be found that the outputs are not matching the expected out of the system. In such case, the errors in the particular programs are identified and are fixed and further tested for the expected output. When it is ensured that the system is running error-free, the users are called with their own actual data so that the system could be shown running as per their requirements. (g) Implementation After having the user acceptance of the new system developed, the implementation phase begins. Implementation is the stage of a project during which theory is turned into practice. During this phase, all the programs of the system are loaded onto the user's computer. After loading the system, training of the users starts. Main topics of such type of training are:  How to execute the package  How to enter the data  How to process the data (processing details)  How to take out the reports After the users are trained about the computerised system, manual working has to shift from manual to computerised working. The following two strategies are followed for running the system: 27 i. Parallel run: In such run for a certain defined period, both the systems i.e. computerised and manual are executed in parallel. This strategy is helpful because of the following: o Manual results can be compared with the results of the computerised system. o Failure of the computerised system at the early stage, does not affect the working of the organisation, because the manual system continues to work, as it used to do. i. Pilot run: In this type of run, the new system is installed in parts. Some part of the new system is installed first and executed successfully for considerable time period. When the results are found satisfactory then only other parts are implemented. This strategy builds the confidence and the errors are traced easily. (h) Maintenance Maintenance is necessary to eliminate errors in the system during its working life and to tune the system to any variations in its working environment. It has been seen that there are always some errors found in the system that must be noted and corrected. It also means the review of the system from time to time. The review of the system is done for:  knowing the full capabilities of the system  knowing the required changes or the additional requirements  studying the performance If a major change to a system is needed, a new project may have to be set up to carry out the change. The new project will then proceed through all the above life cycle phases. 6 What You Have Learnt In this lesson systematic approach of any given problem is explained. Computer based systems are defined. System development life cycle is discussed in detail. The different phases of the development of system life cycle are explained in detail. 7 Terminal Question 1. Define a system. Explain the components of a system. 2. What do you understand by system development life cycle? 3. Discuss the importance of system analysis and design in the development of a system? 28 Systems Analysis & Design My experience has shown that many people find it hard to make their design ideas precise. They are willing to express their ideas in loose, general terms, but are unwilling to express them with the precision needed to make them into patterns. Above all, they are unwilling to express them as abstract spatial relations among well-defined spatial parts. I have also found that people aren't always very good at it; it is hard to do..... If you can't draw a diagram of it, it isn't a pattern. If you think you have a pattern, you must be able to draw a diagram of it. This is a crude, but vital rule. A pattern defines a field of spatial relations, and it must always be possible to draw a diagram for every pattern. In the diagram, each part will appear as a labeled or colored zone, and the layout of the parts expresses the relation which the pattern specifies. If you can't draw it, it isn't a pattern. Introduction The work of Christopher Alexander, a mathematician-turned architect, has had a subtle and yet a profound impact on the methodologies for the development of information systems in business. The main idea in architecture, espoused by Alexander, is that buildings and cities can be designed from the combination of certain basic patterns. Such patterns can be documented as diagrams which, in the architectural domain, specify spatial relationships. In the domain of business (and accounting) information systems development, the task is to create languages for describing and manipulating patterns to create systems that meet the needs of business. In this note, we shall study the way in which information systems are specified, and the methodology of Systems Development Life Cycle (SDLC) that is often used in the development of accounting information systems. Specification of Information Systems Why specifications? Specification of any system before its development is crucial. Specifications perform for information systems the same function that blue-prints and engineering specifications perform for physical structures. Specifications serve as benchmarks for evaluating designs as well as their implementation. They also facilitate quality assurance via verification (are we building the system right, ie., do the design and implementation meet the specifications?) and validation ( are we building the right system, ie., does the system meet the user needs?). Components of specifications Specification of an information system is given by their  Structure: How it is organised.  Function: What it does.  Behavior: How it responds to events and stimuli.  Data: Its meaning and organization. Most CASE tools co-ordinate information systems projects through a project or system dictionary. The function of the dictionary is to standardise the use of terms throughout the organisation and to serve as a repository of all common information in the project. It enforces consistency as well as (relative) completeness of the specifications, and facilitates verification & validation of such specifications. It also serves as a means of communication between the different persons on the information systems building team.The figure below shows the various components of the specifications and the modeling techniques utilised. We will be studying some of those techniques in this course. Methodologies for Systems Development There are many methodologies for the development of information systems: Systems Development Life Cycle (SDLC), Data Structure-Oriented design, Object-Oriented design, Prototyping, among others. We shall, however, be concerned here primarily with SDLC. Systems Development Life Cycle: Referred to variously as the waterfall model and linear cycle, this methodology is a coherent description of the steps taken in the development of information systems. The reason why it is referred to as the waterfall model should be obvious from the following figure (from Horner, 1993): The methodology SDLC is closely linked to what has come to be known as structured systems analysis & design. It involves a series of steps to be undertaken in the development of information systems as follows:  Problem definition: On receiving a request from the user for systems development, an investigation is conducted to state the problem to be solved. o Deliverables: Problem statement.  Feasibility study: The objective here is to clearly define the scope and objectives of the systems project, and to identify alternative solutions to the problem defined earlier. o Deliverables: Feasibility report.  Systems analysis phase: The present system is investigated and its specifications documented. They should contain our understanding of HOW the present system works and WHAT it does. o Deliverables: Specifications of the present system.  Systems design phase: The specifications of the present system are studied to determine what changes will be needed to incorporate the user needs not met by the system presently. The output of this phase will consist of the specifications, which must describe both WHAT the proposed system will do and HOW it will work.of the proposed system. o Deliverables:Specifications of the proposed system.  Systems construction: Programming the system, and development of user documentation for the system as well as the programs. o Deliverables: Programs, their documentation, and user manuals.  System testing & evaluation: Testing, verification and validation of the system just built. o Deliverables: Test and evaluation results, and the system ready to be delivered to the user/client. The figure below provides an illustration for the above description. The waterfall model has many attractive features:  Clearly defined deliverables at the end of each phase, so that the client can take decisions on continuing the project.  Incremental resource committment. The client does not have to make a full committment on the project at the beginning.  Isolation of the problem early in the process. It does, however, have some drawbacks:  Requires an all-or-nothing approach to systems development. Does not allow incremental development.  Requires very early isolation of the problem. In the real world, often the problems are uncovered in the process of development of systems. Strategy in Analysis & Design The understanding and management of complexity is perhaps the most important task of the designer of an information system. It is carried out bearing in mind the strategies of abstraction as well as hierarchical ordering (divide & conquer). In the real world, an accounting information systems designer (systems designer for short) is rarely called upon to analyse and design a system from the scratch. Usually, such a system does exist, but the client (user) is not quite satisfied with it. The systems designer starts with the documentation of the existing accounting system, if it does not exist. Often, documentation pertaining to the existing system is contained in the audit workpapers pertaining to the auditor's study of control risk assessment. However, since such documentation is not prepared with a view to design a system, it is used only as a starting point in building the documentation to aid systems design. In this document, we shall study how abstraction and hierarchical ordering strategies are used to manage the complexity of analysing and designing the functions of an information system. The methodology of structured systems analysis & design provides a roadmap for the development of functional specifications for an accounting information system, shown in the Figure below. The functional specifications are documented graphically in Dataflow Diagrams (DFDs) described in the next section below. STEP 0: (Defining the scope of the system under study.) This accomplished by drawing the context diagram for the system. STEP 1: (Documentation of how the existing system works.) This is accomplished by drawing the Physical DFDs of the existing system. These DFDs specify the current implementation of the existing system, and would answer questions such as:  Who performs the tasks?  How they are performed?  When or how often they are performed?  How the data is stored (media)?  How the dataflows are implemented (media)? These physical DFDs may be levelled, or, if the system is not very large, prepared all on a single DFD. STEP 2: (Documentation of what the existing system does.)This is documented in Logical DFDs of the existing system. Deriving these logical DFDs of the existing system from the physical DFDs involve abstraction of all implementation details. Since the systems designer would not like to be tied down by the current implementation of the system, all such details are abstracted. These logical DFDs are usually levelled in order to reduce the perceived complexity of the system, and balanced in order to assure consistency in the design. STEP 3: (Documentation of what the proposed system will do.) After step 2, the systems designer will examine why the existing system does not meet the user requirements, and how it can be modified in order to meet such needs. The result is a set of logical DFDs which describe what the modified (proposed) system will do. These functional specifications are devoid of implementation considerations, and therefore rather abstract specifications of the proposed system. These logical DFDs are also levelled and balanced. STEP 4: (Documentation of how the proposed system will work.) The logical DFDs of the proposed system derived in step 3 above are then examined to determine which implementation of it meets the user requirements most efficiently. The result is a set of physical DFDs of the proposed system. They answer questions such as:  Who will perform the various tasks?  How they will be performed?  When or how often they will be performed?  How the data will be stored (media)?  How the dataflows will be implemented (media)? In this step, man-machine boundaries are drawn, and media selected for all dataflows & datastores. The function of any information system can be expressed in terms of transformation (processing) of certain inputs (which are data) into outputs (which are data too) where memory (which too consists of data) may need to be consulted (or updated). This suggests that two crucial elements in a system's description are data and processing of data. A complete description of an information system demands description of both these elements. In fact, we can reduce this, in a mundane fashion to the equation: System = Data + Processing of data While it is impossible to describe an information system exclusively in terms of data or its processing, it is possible to study a system's functions (what the system must do) in terms of the transformations it must perform of the data which is modeled separately. A coherent description of the information system, however, would require that the models of data and its processing are not inconsistent. An information system's functions, which describe its processing aspects, is modeled in the structured systems approach, as dataflow diagrams.Such a model of an information system is, for obvious reasons, referred to as functional model or process model. A dataflow diagram consists of external entities (represented by rectangles), processes (represented by either rounded rectangles or circles), data stores (represented by either an open rectangle or two parallel lines) and dataflows (represented by arrows). ALGORITHM Contents I. ALGORITHM ............................................................................................................................... 35 I.1. Definition .................................................................................................................................... 35 I.2. Properties of an algorithm .......................................................................................................... 35 I.3. Example of algorithm ................................................................................................................. 35 II. REPRESENTATION OF AN ALGORITHM .............................................................................. 35 II.1. Flowchart ................................................................................................................................... 36 II.2. Pseudocode ................................................................................................................................ 37 III. ALGORITHM STRUCTURES ................................................................................................ 38 III.1 Sequence ................................................................................................................................... 38 III.2 Selection (Decision) .................................................................................................................. 39 III.3 Repetition (Looping) ................................................................................................................. 41 APPLICATION EXERCISES .............................................................................................................. 43 XVI. ALGORITHM I.1. Definition Algorithms are one of the most basic tools that are used to develop the problem-solving logic. An algorithm is defined as a finite sequence of explicit instructions that when provided with a set of input values, produces an output and then terminates. Algorithm is not language specific. We can use the same flowchart to code a program using different programming languages. Many algorithms can be design for the same task. I.2. Properties of an algorithm Note that algorithms are not computer programs, as they cannot be executed by a computer. Some properties of algorithm are as follows: • Finiteness – the algorithm stops after a finite number of instructions are executed. • Definiteness or unambiguous: There must be no ambiguity in any instruction. This means that the action specified by the step cannot be interpreted in multiple ways & can be performed without any confusion. • Input:- an algorithm accepts zero or more inputs • Output:- it produces at least one output. • Effectiveness:- it consists of basic instructions that are realizable. This means that the instructions can be performed by using the given inputs in a finite amount of time. I.3. Example of algorithm We use algorithms in our daily life. For example, to wash hand, the following algorithms may be used. 1. Start 2. Turn on water 3. dispense soap 4. wash hand till clean 5. Rince soap off 6. Turn off water 7. Dry hand 8. Stop 1. Start 2. Turn on water 3. dispense soap 4. Repeat Rub hands together 5. until hand clean 6. Rince soap off 7. Turn off water 8. Dry hand 9. Stop The above-mentioned algorithm terminates after six steps. This explains the feature of finiteness. Every action of the algorithm is precisely defined; hence, there is no scope for ambiguity. XVII. REPRESENTATION OF AN ALGORITHM Algorithms can be represented in different ways: - By Flowchart - By Pseudocode II.1. Flowchart Flowchart is the diagrammatic representation of an algorithm with the help of symbols carrying certain meaning. Using flowchart, we can easily understand a program. a) Flowchart Symbols Symbol Flowcharts use simple geometric symbols and arrows to define relationships. Some standard symbols that are frequently required for flowcharts are shown: Symbol name Flow Lines Description Flow lines are used to connect symbols. These lines indicate the sequence of steps and the direction of flow. Terminal The terminator symbol represents the start points, end points, and potential outcomes of a path. Processing used to illustrate a process, action or an operation. Examples: "Add 1 to X"; "save changes" or similar. Decision These typically contain a Yes/No question or True/False test. Input/output It represents data that is available for input or output. It may also represent resources used or generated. Ex: Get X from the user; display X. Connector Connector symbol is used to join different flow lines. Off- page Connecter This symbol is used to indicate the flowchart continues on the next page Document Document is used to represent a paper document produced during the flowchart process. Manual Input Manual input symbol represents input to be given by a developer / programmer. Magnetic Disk This is used to represent data input or output from and to a magnetic disk. b) Advantages of flowchart The flowchart shows how the program works before you begin actually coding it. Some advantages of flowcharting are the following. - - - - Communication: Flowcharts are helpful in explaining the program to other people. Effective analysis: With the help of flowchart, the problem can be analysed more effectively Proper documentation: Program flowchart serves as a good program documentation, which is needed for various purposes. Efficient coding: Once the flowchart is drawn, it becomes easy to write the program in any high level language - - Proper debugging: The flowchart help in the debugging process Efficient program maintenance: The maintenance of operating program become easy with the help of flowchart c) Limitations of Flowcharts Flowchart can be used for designing the basic concept of the program in pictorial form, but cannot be used for programming purposes. Some of the limitations of the flowchart are given below: • Complex: The major disadvantage in using flowcharts is that when a program is very large, the flowcharts may continue for many pages, making them hard to follow. • Costly: If the flowchart is to be drawn for a huge program, the time and cost factor of program development may get out of proportion, making it a costly affair. • Difficult to Modify: Due to its symbolic nature, any change or modification to a flowchart usually requires redrawing the entire logic again, and redrawing a complex flowchart is not a simple task. • No Update: Usually, programs are updated regularly. However, the corresponding update of flowcharts may not take place, especially in the case of large programs. II.2. Pseudocode Pseudocode is a detailed yet readable description of what an algorithm must do, expressed in a formally-styled natural language rather than in a programming language. It describe the entire logic of the algorithm so that implementation becomes a rote mechanical task of translating line by line into source code. a) Pseudocode Structures Before going ahead with pseudocode, let us discuss some keywords, which are often used to indicate input, output and processing operations. • Input: READ, OBTAIN, GET and PROMPT • Output: PRINT, DISPLAY and SHOW • Compute: COMPUTE, CALCULATE and DETERMINE • Initialize: SET and INITIALIZE • Add One: INCREMENT b) Example of pseudocode The pseudocode given below calculates the area of a rectangle. Pseudocode: To calculate the area of a rectangle START PROMPT the user to enter the length of the rectangle PROMPT the user to enter the width of the rectangle COMPUTE the area by multiplying the length with width DISPLAY the area STOP c) Advantages of Using Pseudocode Some of the most significant benefits of pseudocode are as follows: • It is easier to develop a program from a pseudocode rather than from a flowchart or decision table. • Often, it is easy to translate pseudocode into a programming language, a step which can be accomplished by less-experienced programmers. • Unlike flowcharts, pseudocode is compact and does not tend to run over many pages. Its simple structure and readability makes it easier to modify as well. • Pseudocode allows programmers who work in different computer languages to talk to each other. d) Disadvantages of Using Pseudocode Although pseudocode is a very simple mechanism to simplify problem-solving logic, it has its own limitations. Some of the most notable limitations are as follows: • It does not provide visual representation of the program logic. • There are no accepted standards for writing pseudocodes. Different programmers use their own style of writing pseudocode. • It is quite difficult for the beginners to write pseudocode as compared to drawing a flowchart. XVIII. ALGORITHM STRUCTURES The 'structured' part of pseudocode and flowchart is a notation for representing three general programming constructs: sequence, selection and repetition. Each of these constructs can be embedded inside any other construct. It has been proven that three basic constructs for flow of control are sufficient to implement any 'proper' algorithm. • Sequence, where information can flow in a straight line. • Selection (branched), where the decisions are made according to some predefined condition. • Repetition, where the logic can repeat in a loop, that is, where a sequence of steps is repeated until the desired output is obtained. III.1 Sequence Sequence construct is a linear progression where one task is performed sequentially after another. The actions are performed in the same sequence (top to bottom) in which they are written Fig. Flowchart and Pseudocode for Sequence Construct Example Write an algorithm and flowchart for calculating the perimeter and surface of square, if the default length of the sides of the square is a. Flowchart Pseudocode C Begin Input a P = 4 × a S = A × a Print P, S END #include int main() { int a, P, S; printf(“Enter the length”); scanf(“%d”,&a); P = 4 * a ; S = a * a ; printf(“\nPerimetre = %d”, P); printf(“\nSurface = %d”, S); return 0 ; } Note that there is no branching and no process is repeated again. Each process is contributing something to the next process. III.2 Selection (Decision) Selection is a process of deciding which choice is made between two or more alternative courses of action. Selection logic is depicted as an IF-THEN-ELSE-ENDIF or CASE ENDCASE structure. As the name suggests, in case of the IF-THEN-ELSE-ENDIF construct, if the condition is true, the true alternative actions are performed and if condition is false, then false alternative actions are performed on. a) IF-THEN-ELSE-ENDIF construct Flowchart Pseudocode C • • • IF condition THEN List of actions ELSE List of different actions ENDIF • • • • • if(condition) { List of actions } Else { List of different actions } • • Note that the ELSE keyword and 'Action 2' are optional. In case you do not want to choose between two alternate courses of actions, then simply use IF-THEN-ENDIF Flowchart Pseudocode C • • • IF condition THEN List of actions ENDIF • • • • • • if(condition) { List of actions } • • • Hence, if the condition is true, then perform the list of actions listed in the IF-THEN-ENDIF construct and then move on to the other actions in the process. In case the condition is false, then move on to the rest of the actions in the process directly. Let us write a pseudocode to find the largest of three numbers Example: Write an algorithm and flowchart which a given number N increased by 100 if N is less than 100, otherwise N is decreased by the 100. Print this result. Flowchart Pseudocode START C Input N If N < 100 Then N = N × 100 Else N = N - 100 Print N STOP #include int main() { int N; printf("Enter the number: "); scanf("%d",&N); if(N<100) N=N+100; Else N=N-100; printf("\nnumber is %d",N); return 0; } b) CASE-ENDCASE construct If there are a number of conditions to be checked, then using multiple IFs may look very clumsy. Hence, it is advisable to use the CASE-ENDCASE selection construct for multipleway selection logic. A CASE construct indicates a multiway branch based on many conditions. CASE construct uses four keywords, CASE, OF, OTHERS and ENDCASE, along with conditions that are used to indicate the various alternatives. Flowchart Pseudocode C CASE expression OF Condition 1: Sequence 1 Condition 2: Sequence 2 • • Condition n: Sequence n OTHERS : default sequence ENCASE case (expression) { case value 1: Sequence 1; break ; case value 2: Sequence 2; break ; • • case value n: Sequence n; break ; default : default sequence ; } CASE construct performs the same process as multiple IFs, but it is much easier to read and write. Conditions are normally numbers or characters indicating the value of 'Expression' Example: To assign discount according to the code Flowchart Pseudocode C START READ code CASE Grade OF A : discount = 0.0 B : discount = 0.1 C : discount = 0.2 OTHERS : discount = 0.3 ENDCASE DISPLAY discount STOP #include int main() { char code ; switch ( code ) { case 'A': discount = 0.0; break; case 'B': discount = 0.1; break; case 'C': discount = 0.2; break; default: discount = 0.3; } Printf( "discount is: %f ", discount); } III.3 Repetition (Looping) Looping construct is used when some particular task(s) is to be repeated for a number of times according to the specified condition. By using looping, the programmer avoids repeating the same set of instructions. As the selection, the loop is also represented in flowchart by a diamond. The difference is just at the orientation of the arrows. a) WHILE- ENDWHILE In case of WHILE-ENDWHILE, the loop will continue as long as the condition is true. The loop is entered only if the condition is true. The 'statement' is performed for each iteration. At the conclusion of each iteration, the condition is evaluated and the loop continues as long as the condition is true. Flowchart Pseudocode WHILE condition is True statements ENDWHILE C while (condition) { statements } Example: To display the first ten natural numbers using DO WHILE-ENDDO Flowchart Pseudocode C INITIALIZE Count to zero WHILE Count >= 10 ADD 1 to Count PRINT Count ENDWHILE STOP #include main() { int i=0; while(i<10) { printf("%d ",i); i++; } return 0; } b) REPEAT-UNTIL The REPEAT-UNTIL loop is similar to the WHILE-ENDWHILE, except that the test is performed at the bottom of the loop instead of at the top Flowchart Pseudocode C Repeat Statements Until condition is false Do { } While (condition) The 'statement' in this type of loop is always performed at least once, because the test is performed after the statement is executed. At the end of each iteration, the condition is evaluated, and the loop repeats until the condition gets true. The loop terminates when the condition becomes true. Example To display the first ten natural numbers using REPEAT-UNTIL Flowchart Pseudocode C INITIALIZE Count to zero REPEAT ADD 1 to Count PRINT Count UNTIL Count is less than 10 STOP #include main() { int i=0; do { printf("%d ",i); i++; } while(i<10); return 0; } APPLICATION EXERCISES Exercise 1: Write the flowchart corresponding to the following pseudo code Pseudocode 1 Pseudocode 2 Pseudocode 2 Start num1 = 5 num2 = 10 num3 = 15 sum = num1 + num2 + num3 average = sum/3.0 print average Stop Set total to zero Set grade counter to one While grade counter is less than or equal to ten Input the next grade Add the grade into the total Set the class average to the total divided by ten Print the class average. initialize passes to zero initialize failures to zero initialize student to one while student counter <= to ten input the next exam result if the student passed add one to passes else add one to failures add one to student counter print the number of passes print the number of failures if eight or more students passed print "raise tuition" Exercise 2: Create flowcharts to represent these short tasks: a. “If it’s raining, bring an umbrella.” b. “Take twenty paces, then turn and shoot.” c. “Go forward until the Touch Sensor (on port 1) is pressed in, then stop.” d. “Follow Liberty Avenue for 2 miles, then take a left turn onto 40th Street. Go until you reach the bridge, but don’t cross the bridge. Instead, make a right turn onto Foster Street, then take the first left turn. Follow that road until you reach the National Robotics Engineering Consortium building.” e. “Turn on oven. Cook turkey for 4 hours or until meat thermometer reaches 180 degrees.” Exercise 3: Make the flowchart, and write the pseudocode for the following problem: Given a Fahrenheit temperature, calculate and display the equivalent centigrade temperature. The following formula is used for the conversion: C = 5 / 9 * (F – 32) where F and C are the Fahrenheit and centigrade temperatures. Exercise 4: On a separate sheet of paper, make a flowchart organizing the “flow” of getting ready to go to school in the morning. Be sure to include the following steps in your chart, but don’t be afraid to add other things if you need them! Exercise 5: Let’s consider the following flowchart a) Identity the programming construct available in the flowchart and explain how each of them works. b) Do the dry run of the flowchart c) What does the flowchart do? d) Write the corresponding pseudocode of the flowchart DATA TYPES AND DATA STRUCTURES The primary purpose of most computer programs is to store and retrieve data rather than to perform calculations. There are many different ways to organize data for storage and retrieval, and each type of organization is well suited to solving certain kinds of problems and poorly suited to solving problems of other kinds. Consequently, the way in which a program's data is organized may have a profound effect on the program's running time and memory requirements. The finite set of values along with set of rules for different operations is called data type and the study of data organization is called data structures and is the primary focus of this topic. Learning objectives After studying this chapter, student should be able to:  Give examples of data types and state how their represented in the memory.  Appreciate and use concepts of data structure as array, pointer, structure, linked list, …  Appreciate the advantages of abstract data types as a software development strategy.  To develop significant facility with the Abstract Data Type like Stack, Queue, binary tree, and Hash table  Implement Abstract Data Type used data structures Contents I. INTRODUCTION TO DATA TYPE ..................................................................................................... 47 II. PRIMITIVE DATA TYPES ................................................................................................................. 47 III. COMPOSITE DATA TYPE ..................................................................................................... 48 IV. ABSTRACT DATA TYPES .................................................................................................... 52 XIX. INTRODUCTION TO DATA TYPE A programming language is proposed to help programmer to process certain kinds of data and to provide useful output. A program usually contains different types of data types (integer, float, character etc.). C language is rich of data types. A programmer has to employ proper data type as per his requirements. Data type exists in various types: - - - Primitive or primary, or atomic data type Composite, or complex, or secondary data type Abstract data type NB: The size a data type is compiler dependent. One can be using 2 bytes to represent an integer while another is using 4 bytes. In C, the size of a data type can be obtained using the function sizeof() defined in the library stdio.h. For instance, with the declaration int p, we have sizeof(p) = sizeof(int) = 4; XX. PRIMITIVE DATA TYPES Primitive data types are standard predefined types that you can use as the basis for variables, record fields, or your own Data Item parts. Though exact names may vary, many of these types (like INT) are common to most programming languages. C and other procedural languages often refer to these types as "elementary items" because they are not based on any other type. Classic basic primitive types may include:  Character (character, char);  Integer (integer, int, short, long, byte) with a variety of precisions;  Floating-point number (float, double, real, double precision);  Boolean, logical values true and false.  Pointer (also called reference ), a small value referring to another object's address in memory, possibly a much larger one. II.1 Boolean type The Boolean type represents the values: true and false. Although only two values are possible, they are rarely implemented as a single binary digit for efficiency reasons. Many programming languages like C do not have an explicit Boolean type, instead interpreting (for instance) 0 as false and other values as true. Having a Boolean data type can be important for a programming language because a single bit can be used to store a variable of such type. II.2 Integer Data Types: Integers are whole numbers with a range of values, which are machine dependent. Generally an integer occupies 2 or 4 bytes memory space and its value range limited to 32768 to +32767(that is, -215 to +215-1). (A signed integer use one bit for storing sign and rest 15 bits for number.) To control the range of numbers and storage space, C has three classes of integer storage namely short int, int and long int. All three data types have signed and unsigned forms. A short int requires half the amount of storage than normal integer. Unlike signed integer, unsigned integers are always positive and use all the bits for the magnitude of the number. Therefore, the range of an unsigned integer will be from 0 to 65535. The long integers are used to declare a longer range of values and it occupies 4 bytes of storage space. Data Type Bytes Range Format short int or signed short int 2 -32768 to +32767 %d unsigned short int 2 0 to 65535 %u long int or signed long int or long 4 -2147483648 to +2147483647 %ld unsigned long int or unsigned long 4 0 to 4294967295 %Ld II.3 Floating Point Data Types: The floating point data type is used to store fractional numbers (real numbers) with 6 digits of precision. Floating point numbers are denoted in C by the keyword float. When the accuracy of the floating point number is insufficient, we can use the double to define the number. The double is same as float but with longer precision and takes double space (8 bytes) than float. To extend the precision further we can use long double which occupies 12 bytes of memory space. Data Type Bytes Range Format Float 4 -3.4e 38 to +3.4e38 %f Double 8 -1.7e 308 to +1.7e 308 %lf long double 12 -1.7e 4932 to +1.7e 4932 %Lf II.4 Character Data Type: The character data types are used to store the special character and alphabets. It consists of ASCII characters. It occupies one byte of memory. It can be signed and unsigned i.e they have the range of -128 to +127 and 0 to 255 respectively. The following table shows the different character data types. Data Type Bytes Range Format Signed char or char 1 -128 to 127 %c Unsigned char 1 0 to 255 %c XXI. COMPOSITE DATA TYPE In computer science, a composite data type is any data type which can be constructed in a program using its programming language's primitive data types and other composite types. The act of constructing a composite type is known as composition. III.1 Record A record also called a structure is a group of related data items stored in fields, each with its own name and datatype. Suppose you have various data about an employee such as name, salary, and hire date. These items are logically related but dissimilar in type. A record containing a field for each item lets you treat the data as a logical unit. Thus, records make it easier to organize and represent information. Such a declaration can be as follow: pseudocode In C Type employee = record Name: string Salary: number sex: character endrecord struct person { char name[50]; float salary; char sex; }; The size of a structure depends on the data type of its each field. For instance, for example with the structure defined above, Sizeof (struct person) = 50 * sizeof(char) + sizeof(float) + sizeof(char) = 50*1 + 4 + 1 = 55 bytes III.2 Array data type An array is a sequenced collection of elements of the same data type with a single identifier name. Arrays can have multiple axes (more than one axis). Each axis is a dimension. Thus a single dimension array is also known as a vector. A two dimension array is commonly known as a matrix (a spreadsheet like Excel is a two dimension array). Example: Tab is an array We refer to the individual values as members (or elements) of the array. There is only one identifier name assigned to the array. The position of an element in an array is called index and is written in bracket. If Tab is an array, Tab[i] represent the element at the ith position. Example: Tab[4] = 32, Tab[7] = 15 21 45 65 32 75 98 15 34 11 20 Declaration In pseudocode In C Age = array[1 to 5] of integer int age[5]; Age is an array of 5 integers. Notice that in C the index is not defined by the user but the first is always 0 Here, the size of array age is 5 times the size of int (ie 20 bytes) because there are 5 elements. Suppose, the starting address of age[0] is 2120 and the size of int be 4 bytes. Then, the next address (address of a[1]) will be 2124, address of a[2] will be 2128 and so on. Accessing array elements In pseudocode In C Age[2] ← 4 Age[2] = 4; Read(Age[1]) Scanf(“%d”, &Age[1]) A for loop can be used to easily access elements of an array In pseudocode In C For ind FROM 1 to 5 DO print(Age[i]) ENDFOR For(ind=0; i<5; i++) Printf(“%d” In pseudocode Multidimensional Arrays Multidimensional array is also called arrays of arrays or matrix. For example: A=array[1to 3, 1 to 6] of real In C float A[3][6]; Here, A is an array of two dimension, which is an example of multidimensional array. This array has 3 rows and 6 columns In C the first element of the array is A[0][0], then the next A[0][1], A[0][2], … For better understanding of multidimensional arrays, array elements of above example can be thinked of as below: Col 1 Col 2 Col 3 Col 4 Col 5 Col 6 Row 1 A[1,1] A[1,2] A[1,3] A[1,4] A[1,5] A[1,6] Row 2 A[2,1] A[2,2] A[2,3] A[2,4] A[2,5] A[2,6] Row 3 A[3,1] A[3,2] A[3,3] A[3,4] A[3,5] A[3,6] To access elements of a matrix, a nested for loop can be used. Example In pseudocode In C for (i=0; i<3; i++) for (j=0; j<6; j++) FOR i FROM 1 TO 3 DO FOR j FROM 1 TO 6 DO Print(A[i, j]) ENDFOR ENDFOR printf(“%d”, A[i][j]); III.3 String A string is any finite sequence of characters (i.e., letters, numerals, symbols and punctuation marks). An important characteristic of each string is its length, which is the number of characters in it. In C, a string is represented as an array of characters In pseudocode In C Name : string Char name[20] Here the variable name cannot be more than 20 characters. In the variable name contain “lonlac”, then we have name[0]=’l’, name[1]=’o’, name[2]=’n’ and so on. III.4 Pointer Pointers are widely used in programming; they are used to refer to memory location of another variable without using variable identifier itself. They are mainly used in linked lists and call by reference functions. The figure below illustrates the idea of pointers. As you can see below; Yptr is pointing to memory address 100. Figure: Pointer and memory relationship “pointers contain memory addresses, not data values!” When you declare a simple variable, like int i; a memory location with a certain address is set aside for any values that will be placed in i. We thus have the following picture: • After the statement i=35; the location corresponding to I will be filled You can find out the memory address of a variable by simply using the address operator &. Here is an example of its use: &v = FFD2 The above expression should be read as “address of v”, and it returns the memory address of the variable v. Pointer Declaration Like all other C variables, pointers must be declared before they are used. The syntax for pointer declaration is as follows: Datatype * identifier; Examples int* p; // p is a pointer to an integer double* offset; // offset is a pointer to a double Note that the prefix *defines the variable to a pointer. In the above example, p is the type “pointer to integer” and offset is the type “pointer to double”. Once a pointer has been declared, it can be assigned an address. This is usually done with the address operator. For example, int *p; int count; p = &count; After this assignment, we say that p is “referring to” the variable count or “pointing to” the variable count. The pointer p contains the memory address of the variable count. Application of pointer: Linked list A linked list is a finite sequence of nodes each of which contains a pointer field pointing to the next node. It is a dynamic data structure whose length can be increased or decreased at run time. Comparison between link list and array:  Array size is fix or static and cannot change at run time, But in link list we can create memory according to requirement..  In an array, all the elements are kept at consecutive memory locations while in a linked list the elements (or nodes) may be kept at any location but still connected to each other.  Insertion and deletion are costly in array while in a link list it is simple  Link list has efficient memory utilization. Linked lists are preferred mostly when you don’t know the volume of data to be stored. The capacity can be increased (or decreased) at run time  Random access is not allowed. We have to access elements sequentially starting from the first node. So we cannot do binary search with linked lists.  Linear data structure such as stack and queue can easily implemented using link list The definition For the purpose of this document, we shall define a list as a pointer to a structure of type cell like this: Type list = record Element: integer next: list endrecord struct list { int element; struct list next; }; Doubly linked list In a doubly linked list, each node contains, besides the next-node link, a second link field pointing to the previous node in the sequence. The two links may be called forward(s) and backwards, or next and prev(ious). XXII. ABSTRACT DATA TYPES IV.1 Definition The data types you have seen so far are all concrete, in the sense that we have completely specified how they are implemented. An abstract data type, or ADT, specifies a set of operations (or methods) and the semantics of the operations (what they do), but it does not specify the implementation or the details of the operations. That’s what makes it abstract. A Data structure is an implementation of an ADT; a data structure is concrete, i.e., a data structure makes an ADT a reality by specifying how to represent instances of the data type and how to perform operations on those instances Components of Abstract Data Types An abstract data type is an encapsulation mechanism. In general it is composed of several components  A data type  A set of operations (called the methods or operations).  A signature: A precise description of the types of the methods.  A set of axioms: A precise set of rules about how it behaves  A set of implementation hidden from the programmer who uses the data type. In an ADT, operation can be a function or a predicate. An example ADT already familiar to you appears below. integer: a whole number Operations signatures:  addition (+) : interger x integer → integer  subtraction (-) : interger x integer → integer  multiplication (*) : interger x integer → integer  division (/) : interger x integer → real  modulus (%) : interger x integer → integer There exist two main types of abstract data types: Linear ADT (vector, queue, stack, …) and NON-Linear ADT (binary tree, …) IV.2 Common examples of ADT IV.2.1 The Queue a) Definition A queue is a linear collection of items, where an item to be added to the queue must be placed at the rear (tail) of the queue and items that are removed from the queue must be removed from the front. A queue is referred to as a FIFO data structure: First In, First Out. b) The operations There are actually very few operations on a queue. Operation Signature Enqueue() queue x item → queue specification add an item to the queue Dequeue() queue → item x queue remove an item from the queue Front() queue → item Emptyqueue() queue → Boolean access the first item at the front of the queue Test if the queue is empty Fullqueue() queue → Boolean Test if the queue is full queueSize() Queue → integer return the number of element in a queue c) Example Table : Example Queue Operations Queue Operation Queue Contents Return Value q.isEmpty() isEmpty(q) [] True q.enqueue(4) Enqueue(q,4) [4] q.enqueue('dog') Enqueue(q,’dog’) ['dog',4] q.enqueue(True) Enqueue(q,true) [True,'dog',4] q.size() size(q) [True,'dog',4] 3 q.isEmpty() isEmpty(q) [True,'dog',4] False q.enqueue(8.4) Enqueue(q,8.4) [8.4,True,'dog',4] q.dequeue() Dequeue(q) [8.4,True,'dog'] 4 q.dequeue() Dequeue(q) [8.4,True] 'dog' q.size() Size(q) [8.4,True] 2 d) Queue implementation  Array implementation Since a queue usually holds a bunch of items with the same type, we could implement a queue with an array. One of the things we'll need to keep track of is the number of elements in the queue, i.e., not all the elements in the array may be holding elements of the queue at any given time. So far, the pieces of data we need for our array implementation of the queue are: an array, a count  Linked list implementation The diagrams in Figures below show a simple queue before and after adding a new item and before and after removing an item. At each point, you can add a new item only at the rear of the queue and can remove an item only from the front of the queue. (Note that the front of the queue, where you delete items, is at the left of the diagrams. The rear of the queue, where you add items, appears to the right.) Figure a: A simple queue just before a fourth item is added Figure b: The simple queue after the fourth item is added and before an item is removed Figure c: The simple queue after an item has been removed IV.2.2 The Stack a) The definition A stack is a linear collection of similar items, where an item to be added to the stack must be placed on top of the stack and items that are removed from the stack must be removed from the top. The top of the stack is known as the top. The term push means to add an item to the stack, and the term pop means to remove an item from the stack. A stack is referred to as a LIFO data structure: Last In, First Out. b) The operations There are actually very few operations on a stack. Operation Signature Push() specification stack x item → stack add an item to the stack Pop() stack → item remove an item from the stack Top() stark → item emptyStack() Stack → Boolean access item at the top of the stack test if the stack is empty fullStack() stark → Boolean test if the stack is full c) Using a stack to evaluate postfix Infix, prefix and posfix notation In most programming languages, mathematical expressions are written with the operator between the two operands, as in 1 + 2. This format is called infix. An alternative used by some calculators is called postfix. In postfix, the operator follows the operands, as in 1 2 +. Example: Let’s consider the following expression: x / y + 4*z  The prefix expression is: + / x y * 4 z  The postfix expression is: x y / 4 z * + The reason postfix is sometimes useful is that there is a natural way to evaluate a postfix expression using a stack: 1. Starting at the beginning of the expression, get one term (operator or operand) at a time. o If the term is an operand, push it on the stack. o If the term is an operator, pop two operands off the stack, perform the operation on them, and push the result back on the stack. 2. When you get to the end of the expression, there should be exactly one operand left on the stack. That operand is the result. d) Implementation of a stack Implementation of a stack can also be done using an array or a linked list IV.2.3 Binary Tree a) Abstract idea of a tree: A tree is another data structure that you can use to store information. Unlike stacks and queues, which are linear data structures, trees are hierarchical data structures. Here is an example of a tree holding letters: b) Tree Vocabulary Let's now introduce some vocabulary with our sample tree... The element at the top of the tree is called the root. The elements that are directly under an element are called its children. The element directly above something is called its parent. For example, a is a child of f and f is the parent of a. Finally, elements with no children are called leaves. A tree can be viewed, as a recursive data structure, for it is made up of subtrees c) Uses of trees (1) File systems A file system can be represented as a tree, with the top-most directory as the root. Here are some example of a folder structure in a windows explorer (2) expression tree An arithmetic expression can be represented by a tree the leave nodes are the variables/values the internal nodes are the operations (3) Organization chart (4) Family tree d) Binary Trees A tree whose elements have at most 2 children is called a binary tree. For the rest of this example, we will enforce this to be the case. Since each element in a binary tree can have only 2 children, we typically name them the left and right child. e) Binary search tree A binary search tree (BST), sometimes also called an ordered or sorted binary tree, is a node-based binary tree data structure which has the following properties:  The left subtree of a node contains only nodes with keys less than the node's key.  The right subtree of a node contains only nodes with keys greater than the node's key.  The left and right subtree each must also be a binary search tree.  There must be no duplicate nodes. The major advantage of binary search trees over other data structures is that the related sorting algorithms and search algorithms such as in-order traversal can be very efficient. Binary search trees are a fundamental data structure used to construct more abstract data structures such as sets, multisets, and associative arrays. f) Tree’s operations: As mentioned, there are different kinds of trees (e.g., binary search trees, 2-3 trees, AVL trees, tries, just to name a few). What operations we will need for a tree, and how they work, depends on what kind of tree we use. However, there are some common operations we can mention:  Add(): Places an element in the tree (where elements end up depends on the kind of tree).  Remove(): Removes something from the tree (how the tree is reorganized after a removal depends on the kind of tree).  IsMember: Reports whether some element is in the tree. Other operations may be necessary, depending on the kind of tree we use. g) Tree Traversals A tree traversal is a specific order in which to trace the nodes of a tree. To perform a traversal of a data structure, we use a method of visiting every node in some predetermined order. Traversals can be used  to test data structures for equality  to display a data structure  to construct a data structure of a give size  to copy a data structure There are 3 common tree traversals. 1. in-order: left, root, right 2. pre-order: root, left, right 3. post-order: left, right, root In order to illustrate few of the binary tree traversals, let us consider the below binary tree: 1) Preorder traversal: To traverse a binary tree in Preorder, following operations are carried-out (i) Visit the root, (ii) (iii) Traverse the left subtree, and Traverse the right subtree. Therefore, the Preorder traversal of the above tree will outputs: 15, 5, 3, 12, 10, 6, 7, 13, 16, 20, 18, 23 2) Inorder traversal: To traverse a binary tree in Inorder, following operations are carried out (i) (ii) (iii) Traverse the left most subtree starting at the left external node, Visit the root, and Traverse the right subtree starting at the left external node. Therefore, the Inorder traversal of the above tree will outputs: 3, 5, 6, 7, 10, 12, 13, 15, 16, 18, 20, 23 3) Postorder traversal: To traverse a binary tree in Postorder, following operations are carried-out (i) Traverse all the left external nodes starting with the left most subtree which is then followed by bubble-up all the internal nodes, (ii) Traverse the right subtree starting at the left external node which is then followed by bubble-up all the internal nodes, and (iii) Visit the root. Therefore, the Postorder traversal of the above tree will outputs: 3, 7, 6, 10, 13, 12, 5, 18, 23, 20, 16, 15 Another example The 3 different types of traversal Pre-order Traversal FBADCEGIH In-order Traversal ABCDEFGHI Post-order Traversal ACEDBHIGF NB: The Preorder traversal of an expression tree give the prefix representation of the expression represented by the tree. The Inorder traversal of an expression tree give the infix representation of the expression represented by the tree. The postorder traversal of an expression tree give the postfix representation of the expression represented by the tree. Example: Let’s consider the following expression tree.  The preorder transversal is: + * + a b – a b 2  The inorder transversal is: a + b * a – b + 2  The postorder transversal is: a b + a b - * 2 + IV.2.4 Hash Tables A hash table (hash map) is a data structure used to implement an associative array, a structure that can map keys to values. A hash table is made up of two parts: an array (the actual table where the data to be searched is stored) and a mapping function, known as a hash function. The hash function provides a way for assigning numbers to the input data such that the data can then be stored at the array index corresponding to the assigned number. Let's take a simple example. First, we start with a hash table array of strings (we'll use strings as the data being stored and searched in this example). Let's say the hash table size is 10: Hash Table 0 1 2 3 4 5 6 7 8 Next we need a hash function. There are many possible ways to construct a hash function. Some hash functions will take an integer key and turn it into an index. A common hash method is the division method. Let's say you had the following numbers or keys that you wanted to map into an array of 10 elements: 123456, 123467, 123450 To apply the division method, you could divide the number by 10 (or the maximum number of elements in the array) and use the remainder (the modulo) as an index. The following would result: 123456 % 10 = 6 (the remainder is 6 when dividing by 10) 123467 % 10 = 7 (the remainder is 7) 123450 % 10 = 0 (the remainder is 0) These numbers would be inserted into the array at positions 6, 7, and 0 respectively. It might look something like this: Case of non-integer keys For now, let's assume a simple hash function that takes a string as input. The returned hash value will be the sum of the ASCII characters that make up the string mod the size of the table: Again, the idea is that we will insert items into the hash table using the key and applying the hash function(s) to get the index. Placide --> 690 % 10 --> 0 Spark --> 593 % 10 --> 3 Steve --> 519 % 10 --> 9 A problem occurs when two keys yield the same index. For Instance, say we wanted to include: John --> 399 % 10 --> 9. We have a collision because Steve is already stored at array index 9. We need a method to resolve this. The resolution comes in how you create your hash table. In our case we will use linked list to solve the problem. Applications of a Hash Table Hash tables are good in situations where you have enormous amounts of data from which you would like to quickly search and retrieve information. A few typical hash table implementations would be in the following situations:  For driver's license record's. With a hash table, you could quickly get information about the driver (ie. name, address, age) given the licence number.  For internet search engines.  For telephone book databases. You could make use of a hash table implementatation to quickly look up John Smith's telephone number.  For electronic library catalogs. Hash Table implementations allow for a fast find among the millions of materials stored in the library.  For implementing passwords for systems with multiple users. Hash Tables allow for a fast retrieval of the password which corresponds to a given username. Advantages and disadvantages of hash tables Organization Advantages Disadvantages 9 Hash Table 0 123450 1 2 3 4 5 6 123456 7 123467 8 9 Hash Table 0 Placide 1 2 3 Spark 4 5 6 7 8 9 Steve, John Chaining  Unlimited number of elements  Unlimited number of collisions  Overhead of multiple linked lists Re-hashing  Fast re-hashing  Fast access through use of main table space  Maximum number of elements must be known  Multiple collisions may become probable Overflow area 1. Fast access 2. Collisions don't use primary table space  Two parameters which govern performance need to be estimated EXERCISES 1. For the following binary trees perform the following:Pre-order traversal, In-order traversal and Post-order traversal 2. Give the inorder and postorder traversal for the tree whose preorder traversal is A B C - - D - - E - F - -. The letters correspond to labeled internal nodes; the minus signs to external nodes. 3. Give the preorder, inorder and postorder traversals of the following binary trees. 4. For each tree shown in the Figure below show the order in which the nodes are visited during the following tree traversals: a) preorder traversal, b) inorder traversal (if defined), c) postorder traversal, and 5. What values are dequeued by the following algorithm? Enqueue(5) Enqueue(4) Enqueue(4) Dequeue() Dequeue() Enqueue() 6. What are the value popped by the following algorithm? Push(5) Push(4) Push(4) Pop() Pop() Push(3) Pop () Pop () 7. A letter means push and an asterisk means pop in the following sequence. Give the sequence of values returned by the pop operations when this sequence of operations is performed on an initially empty LIFO stack. E A S * Y * Q U E * * * S T * * * I O * N * * * 8. A letter means enqueue and an asterisk means dequeue in the following sequence. Give the sequence of values returned by the dequeue operation when this sequence of operations is performed on an initially empty FIFO queue. E A S * Y * Q U E * * * S T * * * I O * N * * * 9. Introduce int variables x and y and int* pointer variables p and q. Set x to 2, y to 8, p to the address of x, and q to the address of y. Then print the following information: (1) The address of x and the value of x. (2) The value of p and the value of *p. (3) The address of y and the value of y. (4) The value of q and the value of *q. (5) The address of p (not its contents!). (6) The address of q (not its contents!). XXIII. ALGORITHM STRATEGIES An algorithm strategy is a general approach to solve problems algorithmically. Although more than one technique may be applicable to a specific problem, it is often the case that an algorithm constructed by one approach is clearly superior to equivalent solutions built using alternative techniques. I.1 Examples of strategies 1. Brute Force Brute force is a straightforward approach to solve a problem based on the problem’s statement and definitions of the concepts involved. It is considered as one of the easiest approach to apply and is useful for solving small – size instances of a problem. Some examples of brute force algorithms are: Computing an (a > 0, n a nonnegative integer) by multiplying a*a*…*a, computing n!, Selection sort , Bubble sort, Sequential search 2. Greedy Algorithms "take what you can get now" strategy The solution is constructed through a sequence of steps, each expanding a partially constructed solution obtained so far. At each step the choice must be locally optimal – this is the central point of this technique. Examples: Minimal spanning tree, Shortest distance in graphs 3. Divide-and-Conquer, Decrease and conquer Also known as stepwise refinement, these are methods of designing algorithms that (informally) proceed as follows: Given an instance of the problem to be solved, split this into several smaller sub-instances (of the same problem), independently solve each of the sub-instances and then combine the sub-instance solutions so as to yield a solution for the original instance. With the divide-and-conquer method the size of the problem instance is reduced by a factor (e.g. half the input size), while with the decrease-and-conquer method the size is reduced by a constant. Examples of divide-and-conquer algorithms: Computing an by recursion, Binary search in a sorted array (recursion), Mergesort algorithm, Quicksort algorithm (recursion) Examples of decrease-and-conquer algorithms: Insertion sort, Topological sorting, Binary Tree traversals: inorder, preorder and postorder (recursion) 4. Transform-and-Conquer to These methods work as two-stage procedures. First, the problem is modified to be more amenable solution. In the second stage the solved. Example: consider the problem of finding the two closest numbers in an array of numbers. problem I.2 Design approaches is Different approaches are used to build an algorithm 1. Top-down design: Top-down approach is essentially the breaking down of a problem to gain insight into its compositional subproblems. Top-Down Technique logically progresses from the initial instance down to the smallest sub instance via intermediate sub-instances. 2. Bottom-up design: As you might guess, with this approach the details come first. It is the opposite of the top-down approach. In a Bottom-Up Technique, the smallest sub-instances are explicitly solved first and the results of these used to construct solutions to progressively larger sub-instances. XXIV. RECURSION A recursive function is a function that calls itself during its execution. The main characteristics of a recursive algorithm are: - Stopping condition: It specifies the situation when the result can be obtained directly without the need of a recursive call. - Recursive call: The algorithm calls itself at least once. The value of the parameter corresponding to a cascade of calls should lead eventually to the stopping condition. II.1 An example of recursive function In general, problems that are defined in terms of themselves are good candidates for recursive techniques. The standard example used by many computer science textbooks is the factorial function. Let’s consider the problem of computing n! for n be a natural number. Starting from the definition of 𝑛! = 𝑛 × (𝑛 − 1) ×(𝑛 −2)×…×2×1, and applying the brute force technique (also known as iterative technique) we obtain the following algorithm. factorial(n) f ← 1 for i from n to 1 do f ← f * n endfor return f The factorial function describes the operation of multiplying a number by all the positive integers smaller than it. For example, 5! = 5*4*3*2*1 . And 9! = 9*8*7*6*5*4*3*2*1 . We now see why factorial is often the introductory example for recursion: the factorial function is recursive, it is defined in terms of itself. Taking the factorial of n, we have: � �! = {1 � �𝑓 𝑛 = 0 𝑛 ∗(𝑛−1)! 𝑖𝑓 𝑛>0 Let's try writing our factorial function factorial(n). We want to code in the n! = n*(n - 1)! functionality. Easy enough: Let’s test it to make sure it is working properly factorial(3) = 3 * factorial(2) = 3 * 2 * factorial(1) = 3 * 2 * 1 * factorial(0) = 3 * 2 * 1 * 1 II.2 Other examples of recursive functions a) The Fibonacci sequence The Fibonacci sequence is often used to illustrate the power of dynamic programming. The sequence is defined by the following recurrence relation: This very easily translates into a recursive function: Seems simple enough. What is the running time of Fibonacci()? Consider the call Fibonacci(4). You may remember from your study of binary trees that a nearly complete one, like the one above, has around 2n nodes, where n is the height of the tree (number of levels - 1). That means the number of function calls is around 2n, which is exponential given each function call is O(1). That's very expensive for such a simple little function! b) Power function Let consider the problem of computing xn for x>0 and n a natural number. Starting from the definition, � �𝑛=𝑥∗𝑥∗…∗𝑥=𝑥∗𝑥𝑛−1. Applying the brute force and the recursive techniques respectively, we have c) Hanoi’s tower Let’s consider three vertical pegs labelled as follows: src (source), dest (destination) and int (intermediate). On the src peg there are n disc placed in decreasing order of their diameter (the disc at the bottom is the largest one). We want to move all discs from the peg src to the rod dest by using int as intermediate peg such that the following constraints are satisfied. (i) On the destination peg the disc are placed in the same decreasing order (ii) A disc can never be placed on a smaller disc factorial(int n) if (n= 0)then f ← 1; else f ← n * factorial(n-1); endif return f F0 = 0 F1 = 1 Fn = Fn-1 + Fn-2 Fibonacci( n if ((n == 0) || (n == 1)) fib ← n; else fib ← Fibonacci(n-1) + Fibonacci(n-2) return fib poxer1(real x, integer n) p ← 1 for i from 1 to n do p ← p * 1 endfor retun p poxer2(real x, integer n) if n= 0 then return 1 else retun x * power2(x, n-1) The basic idea of solving this problem is: “move n-1 disc from src to int using dest as intermediate peg; move the largest disc to src to dest; move the n-1 discs from int to dest using s as intermediate peg”. This idea is described very easy in a recursive algotithm hanoi(n,src,dest,int) if n = 1 then src → dest else hanoi(n-1,src,int,dest) src → dest hanoi(n-1,int,dest,src) endif II.3 Evaluation of a recursive function using stack The use of the stack is the best option in many system to execute recursive functions. During the program execution, as the function call itself, a stack of pointer(addresses of instructions of the caller function to which control must return after the called function is executed) is created in the memory. For example for the factorial function described above, the stact is shown below for n = 4 factorial( n) if (n > 0)then return(n * factorial(n-1)); else return(1) endif end Factor ial (0) = 1. Factorial(0) is not put in stack because it does not invoke any other function XXV. PROGRAMMING TECHNIQUES There exist three main types of programming techniques: unstructured programming, structured programming and Object oriented programming. III.1 Unstructured programming Unstructured programming refers to writing small and simple programs, which consist of only one main program. All the actions such as providing input, processing and displaying output are done within one program only. This style of programming is generally restricted for developing a small application; but if the application becomes large, then it poses real difficulties in terms of clarity of the code, modifiability and ease of use. Although this type of programming style is not recommended, still most programmers start programming using this technique only. III.2 Structured programming The programs generated using unstructured approach are meant for simple and small problems. If the problem gets lengthy, this approach becomes too complex and obscure. After some time, even the programmers themselves may find it difficult to understand their own program. Hence, programming should be performed using a 'structured' (organized) approach. Figure. Structured Programming Using structured programming, a program is broken down into small independent tasks that are small enough to be understood easily, without having to understand the whole program at once. Each task has its own functionality and performs a specific part of the actual processing. These tasks are developed independently, and each task can carry out a specified function on its own. When these tasks are completed, they are combined together to solve the problem. III.2.1 Procedural programming This programming has a single program that is divided into small segments called procedures (also known as functions, routines, subroutines or methods). From the main or controlling procedure, a procedure call is used to invoke the required procedure. After the sequence is processed, the flow of control continues from the position from where the call was made. The main program coordinates calls to procedures and hands over appropriate data as parameters. The data are processed by the procedures and once the program has finished, the result data are displayed. a) Variable scope The scope of a variable is the region of code within which a variable is visible. Variable scoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have arguments called x without the two x‘s referring to the same thing. Similarly there are many other cases where different blocks of code can use the same name without referring to the same thing. Most programming languages support global and local scope with the newer programming languages also supporting block scope. Scope can vary by programming language so it is difficult to speak of scope in universal terms.  Local: These variables only exist inside the specific function that creates them. They are unknown to other functions and to the main program. As such, they are normally implemented using a stack. Local variables cease to exist once the function that created them is completed. They are recreated each time a function is executed or called.  Global: These variables can be accessed (ie known) by any function comprising the program. They are implemented by associating memory locations with variable names. They do not get recreated if the function is recalled. b) Passing arguments to functions We have different ways of passing parameter to function such as call by value and call by reference. Whenever we call a function, then sequence of executable statements get executed. We can pass some of the information to the function for processing called argument or parameter  Call by value: The value of a variable is sent to function. The actual parameter cannot be changed by function. copy going into the procedure. This is the mechanism used by both C and Java. Note that this mechanism is used for passing objects, where a reference to the objected is passed by value.  By-Reference When passing parameter using called by address scheme, we are passing the actual address of the variable to the called function. Any update made inside the called function will modify the original copy since we are directly modifying the content of the exact memory location. Illustration call by value Illustration call by reference Example procedure modify (input) begin input = "red" endfunct Algorithm begin x = "blue" modify(x) print(x) {"blue" indicates variable was passed by value, "red" indicates variable was passed by reference} end III.2.2 Modular programming Modular programming is the process of breaking down a problem into smaller independent tasks. These tasks can then be broken down into subtasks. Each module is designed to perform a specific function. Note that each module in itself is a small program, which can be compiled and tested individually and all modules are combined to build the whole program. Modular programming is an important and beneficial approach to programming problems. They make program development easier, and they can also help with future development projects. A module is a component of a larger system that interacts with the rest of the system in a simple and well-defined manner. Importance of modular programming a) Distributed development: By breaking down the problem into multiple tasks, different developers can work in parallel. And this will shorten the development time. b) Code reusability: A program module can be reused in programs. Modules or procedures can also be reused in future projects. c) Program readability: A program that has many functions is straightforward. But a program with no functions can be very long and hard to follow. d) Manageable tasks: Breaking down a programming project into modules makes it more manageable. These individual modules are easier to design, implement and test. e) Maintainability: An error in the system provide from a given module. It is then easier to maintain a single module than to maintain a whole program III.3 Object oriented Algorithms Object Oriented Programming (OOP) is a style of programming that identifies and groups variables and modules into class objects. The class object represents a “thing” like a customer, a purchase, a payment and expresses each in terms of their data (state) and modules (behavior). The class object is stored in a file where it can then be accessed by the programs logic and more important be reused by other programs. A main platform of object-oriented programming is code reusability. Rather than starting from scratch with each new application, a programmer will consult libraries of existing components to see if any are appropriate as starting points for the design of a new application. Reusability is the ability of software elements to serve for the construction of many different applications. Benefits of Reusability     Reliability. Components built by specialists in their field are more likely to be designed correctly and reliably Efficiency. The component developers are likely to be experts in their field and will have used the best possible algorithms and data structures. Time Savings. By relying upon existing components there is less software to develop and hence applications can be built quicker. Decreased maintenance effort. Using someone else’s components decreases the amount of maintenance effort that the application developer needs to expend.  Consistency. Reliance on a library of standard components will tend to spread a consistency of design message throughout a team of programmers working on an application.  Investment. Reusing software will save the cost of developing similar software from scratch. OOP concepts Term Definition Aggregation Objects that are made up of other objects are known as aggregations. The relationship is generally of one of two types:  Composition – the object is composed of other objects. This form of aggregation is a form of code reuse. E.g. A Car is composed of Wheels, a Chassis and an Engine  Collection – the object contains other objects. E.g. a List contains several Items; A Set several Members. Attribute A characteristic of an object. Collectively the attributes of an object describe its state. E.g. a Car may have attributes of Speed, Direction, Registration Number and Driver. Class The definition of objects of the same abstract data type. In Java class is the keyword used to define new types. Encapsulation The combining together of attributes (data) and methods (behaviour/processes) into a single abstract data type with a public interface and a private implementation. This allows the implementation to be altered without affecting the interface. Inheritance The derivation of one class from another so that the attributes and methods of one class are part of the definition of another class. The first class is often referred to the base or parent class. The child is often referred to as a derived or sub-class. Derived classes are always ‘a kind of’ their base classes. Derived classes generally add to the attributes and/or behaviour of the base class. Inheritance is one form of object-oriented code reuse. E.g. Both Motorbikes and Cars are kinds of MotorVehicles and therefore share some common attributes and behaviour but may add their own that are unique to that particular type. Interface The behaviour that a class exposes to the outside world; its public face. Also called its ‘contract’. Method The implementation of some behaviour of an object. Message The invoking of a method of an object. In an object-oriented application objects send each other messages (i.e. execute each others methods) to achieve the desired behaviour. Object An instance of a class. Objects have state, identity and behaviour. Overloading Allowing the same method name to be used for more than one implementation. The different versions of the method vary according to their parameter lists. Polymorphism Giving an action one name that is shared up and down an object hierarchy, with each object in the hierarchy implementing the action in a way appropriate to itself. E.g. Both the Plane and Car types might be able to respond to a turnLeft message. While the behaviour is the same, the means of achieving it are specific to each type. XXVI. SOME STANDARD ALGORITHMS VI.1 Sorting algorithms A sorting algorithm is an algorithm that puts elements of a list in a certain order. We can distinguish many sorting algorithms: Bubble sort , Insertion sort, Selection sort, Heapsort, Mergesort, Quick sort, … a. Selection sort The principle of Selection Sort is to find the smallest element of the data sequence (from index 0 to n-1) and put it to the beginning of the sequence. This procedure is then applied on the yet unsorted areas (1 to n-1, 2 to n-1 and so on), until the area from n-2 to n-1 has been sorted. Now the entire data sequence has been transformed to sorted form. To get the smallest element to the right position, simply exchange it with the first in the (sub-)sequence. Example: Unsorted Sequence 8 4 1 5 4 Step 1 8 4 1 5 4 Step 2 Step 3 Step 4 Result 1 4 8 5 4 1 4 8 5 4 1 4 4 5 8 1 4 4 5 8 Complexity analysis ALGORITHM for i ← 0 to n-2 do min ← i for j ← (i + 1) to n-1 do if A[j] < A[min] min ← j swap A[i] and A[min] Selection sort is not difficult to analyze compared to other sorting algorithms since none of the loops depend on the data in the array. Selecting the lowest element requires scanning all n elements (this takes n − 1 comparisons) and then swapping it into the first position. Finding the next lowest element requires scanning the remaining n − 1 elements and so on, for (n − 1) + (n − 2) + ... + 2 + 1 = n(n − 1) / 2 ∈ Θ(n2) comparisons (see arithmetic progression). Each of these scans requires one swap for n − 1 elements (the final element is already in place). b. Insertion sort The data sequence is divided into two sections: an already sorted target sequence and a still unsorted source sequence. The target sequence initially consists of the first element only. However, it grows by one element per iteration. In every iteration the first element of the current source sequence is compared with the elements of the target sequence in incremental order. If the first element of the source sequence is lower than or equal to an element of the target sequence, all elements to the left of the first element of the source sequence and to the right of the current element of the target sequence are moved to the right, the current element is inserted to the corresponding location in the target sequence and the iteration is stopped. Sorting is finished once all elements belong to the target sequence. ALGORITHM insertionSort(array A) begin for i := 1 to length[A]-1 do begin value := A[i]; j := i-1; while j ≥ 0 and A[j] > value do begin Complexity analysis Worst-case Complexity: 2 + 3 + 4 + … + n = n(n+1)/2 -1 = (n2)/2 + n/2 -1 = O(n2) (For reverse sorted array). Actual run time could be better (loop may terminate earlier than running for p-1 times! The best case scenario (sorted array as input): (n). c. Bubble sort The name of this algorithm is supposed to indicate that the elements "rise" like bubbles. All elements are compared with their successors; if the element with the lower index is the greater one, the elements are exchanged. Once the entire sequence has been processed this way, the whole process is repeated - until there's been an iteration during which no exchange took place. Then the data is sorted. Example (the elements that are currently compared with each other are in bold print): Complexity analysis Bubble Sort is very slow most of the time, except if the unsorted sequence actually is already sorted - then Bubble Sort works faster than the other algorithms: Already after one iteration (consisting of n-1 comparisons) it realizes that the sequence doesn't need to be sorted and stops. Complexity:  i=1n  j=i+1n 1 =  i=1n (n –i) = n2 – n(n+1)/2 = n2/2 – n/2 = (n2) d. Merge sort The unsorted sequence is divided into two sub-sequences. These, again, are divided into two sub sub-sequences, and so on. The smallest partitions consist of just one element each; thus, each of them can be regarded as sorted within its borders. Now neighbouring partitions are merged to larger sub-sequences (that's the source of the name of this algorithm), however not before the elements have been correctly ordered. The resulting sub-sequences are, again, merged until finally the entire data sequence has been reunited. A[j + 1] := A[j]; j := j-1; end; A[j+1] := value; end; end; Example (the target sequence is in bold): Unsorted Sequence 8 4 1 5 4 Step 1 8 4 1 5 4 Step 2 4 8 1 5 4 Step 3 1 4 8 5 4 Step 4 1 4 5 8 4 Result 1 4 4 5 8 Unsorted Sequence 8 4 1 5 4 Step 1 8 4 1 5 4 4 8 1 5 4 4 1 8 5 4 4 1 5 8 4 Step 2 4 1 5 4 8 1 4 5 4 8 => no exchange 1 4 5 4 8 1 4 4 5 8 => no exchange Step 3 1 4 4 5 8 => no exchange 1 4 4 5 8 => no exchange 1 4 4 5 8 => no exchange 1 4 4 5 8 => no exchange Result 1 4 4 5 8 ALGORITHM procedure bubbleSort(A:array) do swapped := false for i from 0 to n - 2 do: if A[i]> A[i+1] then swap(A[i], A[i+1]) swapped := true end if end for while swapped end procedure Example: Unsorted Sequence 8 4 1 5 4 Division 1 8 4 1 | 5 4 Division 2 Division 3 Merge 1 Merge 2 Merge 3 Result 8 4 | 1 | 5 | 4 8 | 4 | 1 | 5 | 4 4 8 | 1 | 5 | 4 1 4 8 | 4 5 1 4 4 5 8 1 4 4 5 8 Example Divide step ALGORITHM MergeSort (Array(First..Last)) Begin If Array contains only one element Then Return Array Else Mid= ((Last + First)/2) LHA = MergeSort(Array(First..Mid)) RHA = MergeSort(Array(Mid+1..Last)) ResultArray = Merge( LHA , RHA ) Return ResultArray EndIf End MergeSort Merge step e. Quicksort Quicksort is a fast and recursive sorting algorithm, which is used not only for educational purposes, but widely applied in practice. On the average, it has O(n log n) complexity, making quicksort suitable for sorting big data volumes. Algorithm The divide-and-conquer strategy is used in quicksort. Below the recursion step is described: 1. Choose a pivot value. The Pivot can be any value, which is in range of sorted values, even if it doesn't present in the array. 2. Partition. Rearrange elements in such a way, that all elements which are lesser than the pivot go to the left part of the array and all elements greater than the pivot, go to the right part of the array. Values equal to the pivot can stay in any part of the array. Notice, that array may be divided in non-equal parts. 3. Sort both parts. Apply quicksort algorithm recursively to the left and the right parts. The algorithm details are as follows: PARTITION(A, p, r) { x = A[r] // pivot: grab last element QUICKSORT(A, p, r) { if p < r i = p – 1 // index of last element ≤ pivot; initially before array for j = p to r-1 // inspect all elements but pivot { if A[j]  {  x // move only elements ≤ pivot to left region i = i + 1 swap A[i] and A[j] } { } } q = PARTITION(A, p, r) QUICKSORT(A, p, q-1) QUICKSORT(A, q+1, r) } swap A[i+1] and A[r] // put pivot in correct place return i+1 } Example VI.2 Searching algorithms Searching for data is one of the fundamental fields of computing. Often, the difference between a fast program and a slow one is the use of a good algorithm for the data set. 1) Linear searching A linear search is the most basic of search algorithm you can have. A linear search sequentially moves through your collection (or data structure) looking for a matching value. int function LinearSearch(Array A , int Lb, int Ub, int Key ); begin for i= Lb to Ub do if A [ i ]= Key then return i ; return –1; end; 2) Binary search binary search or half-interval search algorithm locates the position of an item in a sorted array. Binary search works by comparing an input value to the middle element of the array. The comparison determines whether the element equals the input, less than the input or greater. When the element being compared to equals the input the search stops and typically returns the position of the element. If the element is not equal to the input then a comparison is made to determine whether the input is less than or greater than the element. Comparison Recursive algorithm BinarySearch(A[0..N-1], value, low, high) { if (high < low) return -1 // not found mid = low + ((high - low) / 2) if (A[mid] > value) return BinarySearch(A, value, low, mid-1) else if (A[mid] < value) return BinarySearch(A, value, mid+1, high) else return mid // found } Iterative algorithm BinarySearch(A[0..N-1], value) { { low = 0 high = N - 1 while (low <= high) mid = low + ((high - low) / 2) if (A[mid] > value) high = mid - 1 else if (A[mid] < value) low = mid + 1 else return mid // found } return -1 // not found } Insertion Sort:  Average Case / Worst Case : Θ(n2) ; happens when input is already sorted in descending order  Best Case : Θ(n) ; when input is already sorted  No. of comparisons : Θ(n2) in worst case & Θ(n) in best case  No. of swaps : Θ(n2) in worst/average case & 0 in Best case Selection Sort:  Average Case / Worst Case / Best Case: Θ(n2)  No. of comparisons : Θ(n2)  No. of swaps : Θ(n2) in worst/average case & 0 in best case Merge Sort :  Average Case / Worst Case / Best case : Θ(nlgn) ; doesn't matter at all whether the input is sorted or not  No. of comparisons : Θ(n+m) in worst case & Θ(n) in best case ; assuming we are merging two array of size n & m where n=N. i.e. f is big –O of g if there is c such that f is not larger than cg for sufficiently large value of n ( greater than N) c g(n) is an upper bound on the value of f(n). That is, the number of operations is at worst proportional to g(n) for all large values of n. Categorizing Performance Asymptotic Bound Name O(1) Constant algorithm O(logn) O(n) O(n2) O(n3) O(an) NB: As the size of a O(n!) Logarithmic algorithm Linear algorithm Quadratic algorithm Cubic algorithm Exponential algorithm Factorial algorithm increases, the time requirement for an exponential algorithm usually increases too rapidly to be practical II.3 Algorithm Analysis: Loops problem Let’s consider an n * n two dimensional array. Write a loop to store the row sums in a one dimensional array rows and the overall total in grandTotal. LOOP 1: grandTotal = 0; for (k=0; k Page 106 of 227
                My First Heading
                My first paragraph.
                Example Explained  The text between and describes an HTML document  The text between and provides information about the document  The text between provides a title for the document  The text between and describes the visible page content  The text between
                and
                describes a heading  The text between
                and
                describes paragraph Using this description, a web browser can display a document with a heading and a paragraph. IX.3 HTML Tags HTML tags are keywords (tag names) surrounded by angle brackets: content  HTML tags normally come in pairs like
                and
                The first tag in a pair is the start tag, the second tag is the end tag  The end tag is written like the start tag, but with a slash before the tag name IX.4 Web Browsers The purpose of a web browser (Chrome, IE, Firefox, Safari) is to read HTML documents and display them. The browser does not display the HTML tags, but uses them to determine how to display the document: I X . 5 Common HTML Tags The following table lists some of the most common HTML tags that you'll use to build your website. After you've worked in HTML for a little while, these tags will become second nature to you. Tag Name anchor Code Example Click Here bold Bold Type body of document All of the contents of your Web page.
                line break Soft line break
                Soft line break
                center
                Center your content
                Page 107 of 227 Page 108 of 227 font Example
                form Name:
                heading 1
                Heading 1 Example
                heading 2
                Heading 2 Example
                heading 3
                Heading 3 Example
                heading of document Contains elements describing the document hypertext markup language Webpage contents italic Italic Type list item
                List item 1
                List item 2
                List item 3
                meta
                ordered list
                List item 1
                List item 2
                List item 3
                paragraph
                This creates a line break and a space between lines.


                unordered list
                List item 1
                List item 2
            `
        }
    ]
}; 